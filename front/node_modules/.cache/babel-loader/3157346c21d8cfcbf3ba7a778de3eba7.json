{"ast":null,"code":"\"use strict\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _axios = _interopRequireDefault(require(\"axios\"));\n\nrequire(\"./VideoRoomComponent.css\");\n\nvar _openviduBrowser = require(\"openvidu-browser\");\n\nvar _StreamComponent = _interopRequireDefault(require(\"./stream/StreamComponent\"));\n\nvar _DialogExtension = _interopRequireDefault(require(\"./dialog-extension/DialogExtension\"));\n\nvar _ChatComponent = _interopRequireDefault(require(\"./chat/ChatComponent\"));\n\nvar _openviduLayout = _interopRequireDefault(require(\"../layout/openvidu-layout\"));\n\nvar _userModel = _interopRequireDefault(require(\"../models/user-model\"));\n\nvar _ToolbarComponent = _interopRequireDefault(require(\"./toolbar/ToolbarComponent\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar localUser = new _userModel[\"default\"]();\n\nvar VideoRoomComponent = /*#__PURE__*/function (_Component) {\n  _inherits(VideoRoomComponent, _Component);\n\n  var _super = _createSuper(VideoRoomComponent);\n\n  function VideoRoomComponent(props) {\n    var _this;\n\n    _classCallCheck(this, VideoRoomComponent);\n\n    _this = _super.call(this, props);\n    _this.OPENVIDU_SERVER_URL = _this.props.openviduServerUrl ? _this.props.openviduServerUrl : 'https://' + window.location.hostname + ':4443';\n    _this.OPENVIDU_SERVER_SECRET = _this.props.openviduSecret ? _this.props.openviduSecret : 'MY_SECRET';\n    _this.hasBeenUpdated = false;\n    _this.layout = new _openviduLayout[\"default\"]();\n    var sessionName = _this.props.sessionName ? _this.props.sessionName : 'SessionA';\n    var userName = _this.props.user ? _this.props.user : 'OpenVidu_User' + Math.floor(Math.random() * 100);\n    _this.remotes = [];\n    _this.localUserAccessAllowed = false;\n    _this.state = {\n      mySessionId: sessionName,\n      myUserName: userName,\n      session: undefined,\n      localUser: undefined,\n      subscribers: [],\n      chatDisplay: 'none',\n      currentVideoDevice: undefined\n    };\n    _this.joinSession = _this.joinSession.bind(_assertThisInitialized(_this));\n    _this.leaveSession = _this.leaveSession.bind(_assertThisInitialized(_this));\n    _this.onbeforeunload = _this.onbeforeunload.bind(_assertThisInitialized(_this));\n    _this.updateLayout = _this.updateLayout.bind(_assertThisInitialized(_this));\n    _this.camStatusChanged = _this.camStatusChanged.bind(_assertThisInitialized(_this));\n    _this.micStatusChanged = _this.micStatusChanged.bind(_assertThisInitialized(_this));\n    _this.nicknameChanged = _this.nicknameChanged.bind(_assertThisInitialized(_this));\n    _this.toggleFullscreen = _this.toggleFullscreen.bind(_assertThisInitialized(_this));\n    _this.switchCamera = _this.switchCamera.bind(_assertThisInitialized(_this));\n    _this.screenShare = _this.screenShare.bind(_assertThisInitialized(_this));\n    _this.stopScreenShare = _this.stopScreenShare.bind(_assertThisInitialized(_this));\n    _this.closeDialogExtension = _this.closeDialogExtension.bind(_assertThisInitialized(_this));\n    _this.toggleChat = _this.toggleChat.bind(_assertThisInitialized(_this));\n    _this.checkNotification = _this.checkNotification.bind(_assertThisInitialized(_this));\n    _this.checkSize = _this.checkSize.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(VideoRoomComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var openViduLayoutOptions = {\n        maxRatio: 3 / 2,\n        // The narrowest ratio that will be used (default 2x3)\n        minRatio: 9 / 16,\n        // The widest ratio that will be used (default 16x9)\n        fixedRatio: false,\n        // If this is true then the aspect ratio of the video is maintained and minRatio and maxRatio are ignored (default false)\n        bigClass: 'OV_big',\n        // The class to add to elements that should be sized bigger\n        bigPercentage: 0.8,\n        // The maximum percentage of space the big ones should take up\n        bigFixedRatio: false,\n        // fixedRatio for the big ones\n        bigMaxRatio: 3 / 2,\n        // The narrowest ratio to use for the big elements (default 2x3)\n        bigMinRatio: 9 / 16,\n        // The widest ratio to use for the big elements (default 16x9)\n        bigFirst: true,\n        // Whether to place the big one in the top left (true) or bottom right\n        animate: true // Whether you want to animate the transitions\n\n      };\n      this.layout.initLayoutContainer(document.getElementById('layout'), openViduLayoutOptions);\n      window.addEventListener('beforeunload', this.onbeforeunload);\n      window.addEventListener('resize', this.updateLayout);\n      window.addEventListener('resize', this.checkSize);\n      this.joinSession();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      window.removeEventListener('beforeunload', this.onbeforeunload);\n      window.removeEventListener('resize', this.updateLayout);\n      window.removeEventListener('resize', this.checkSize);\n      this.leaveSession();\n    }\n  }, {\n    key: \"onbeforeunload\",\n    value: function onbeforeunload(event) {\n      this.leaveSession();\n    }\n  }, {\n    key: \"joinSession\",\n    value: function joinSession() {\n      var _this2 = this;\n\n      this.OV = new _openviduBrowser.OpenVidu();\n      this.setState({\n        session: this.OV.initSession()\n      }, function () {\n        _this2.subscribeToStreamCreated();\n\n        _this2.connectToSession();\n      });\n    }\n  }, {\n    key: \"connectToSession\",\n    value: function connectToSession() {\n      var _this3 = this;\n\n      if (this.props.token !== undefined) {\n        console.log('token received: ', this.props.token);\n        this.connect(this.props.token);\n      } else {\n        this.getToken().then(function (token) {\n          console.log(token);\n\n          _this3.connect(token);\n        })[\"catch\"](function (error) {\n          if (_this3.props.error) {\n            _this3.props.error({\n              error: error.error,\n              messgae: error.message,\n              code: error.code,\n              status: error.status\n            });\n          }\n\n          console.log('There was an error getting the token:', error.code, error.message);\n          alert('There was an error getting the token:', error.message);\n        });\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(token) {\n      var _this4 = this;\n\n      this.state.session.connect(token, {\n        clientData: this.state.myUserName\n      }).then(function () {\n        _this4.connectWebCam();\n      })[\"catch\"](function (error) {\n        if (_this4.props.error) {\n          _this4.props.error({\n            error: error.error,\n            messgae: error.message,\n            code: error.code,\n            status: error.status\n          });\n        }\n\n        alert('There was an error connecting to the session:', error.message);\n        console.log('There was an error connecting to the session:', error.code, error.message);\n      });\n    }\n  }, {\n    key: \"connectWebCam\",\n    value: function () {\n      var _connectWebCam = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this5 = this;\n\n        var devices, videoDevices, publisher;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.OV.getDevices();\n\n              case 2:\n                devices = _context.sent;\n                videoDevices = devices.filter(function (device) {\n                  return device.kind === 'videoinput';\n                });\n                publisher = this.OV.initPublisher(undefined, {\n                  audioSource: undefined,\n                  videoSource: videoDevices[0].deviceId,\n                  publishAudio: localUser.isAudioActive(),\n                  publishVideo: localUser.isVideoActive(),\n                  resolution: '640x480',\n                  frameRate: 30,\n                  insertMode: 'APPEND'\n                });\n\n                if (this.state.session.capabilities.publish) {\n                  publisher.on('accessAllowed', function () {\n                    _this5.state.session.publish(publisher).then(function () {\n                      _this5.updateSubscribers();\n\n                      _this5.localUserAccessAllowed = true;\n\n                      if (_this5.props.joinSession) {\n                        _this5.props.joinSession();\n                      }\n                    });\n                  });\n                }\n\n                localUser.setNickname(this.state.myUserName);\n                localUser.setConnectionId(this.state.session.connection.connectionId);\n                localUser.setScreenShareActive(false);\n                localUser.setStreamManager(publisher);\n                this.subscribeToUserChanged();\n                this.subscribeToStreamDestroyed();\n                this.sendSignalUserChanged({\n                  isScreenShareActive: localUser.isScreenShareActive()\n                });\n                this.setState({\n                  currentVideoDevice: videoDevices[0],\n                  localUser: localUser\n                }, function () {\n                  _this5.state.localUser.getStreamManager().on('streamPlaying', function (e) {\n                    _this5.updateLayout();\n\n                    publisher.videos[0].video.parentElement.classList.remove('custom-class');\n                  });\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connectWebCam() {\n        return _connectWebCam.apply(this, arguments);\n      }\n\n      return connectWebCam;\n    }()\n  }, {\n    key: \"updateSubscribers\",\n    value: function updateSubscribers() {\n      var _this6 = this;\n\n      var subscribers = this.remotes;\n      this.setState({\n        subscribers: subscribers\n      }, function () {\n        if (_this6.state.localUser) {\n          _this6.sendSignalUserChanged({\n            isAudioActive: _this6.state.localUser.isAudioActive(),\n            isVideoActive: _this6.state.localUser.isVideoActive(),\n            nickname: _this6.state.localUser.getNickname(),\n            isScreenShareActive: _this6.state.localUser.isScreenShareActive()\n          });\n        }\n\n        _this6.updateLayout();\n      });\n    }\n  }, {\n    key: \"leaveSession\",\n    value: function leaveSession() {\n      var mySession = this.state.session;\n\n      if (mySession) {\n        mySession.disconnect();\n      } // Empty all properties...\n\n\n      this.OV = null;\n      this.setState({\n        session: undefined,\n        subscribers: [],\n        mySessionId: 'SessionA',\n        myUserName: 'OpenVidu_User' + Math.floor(Math.random() * 100),\n        localUser: undefined\n      });\n\n      if (this.props.leaveSession) {\n        this.props.leaveSession();\n      }\n    }\n  }, {\n    key: \"camStatusChanged\",\n    value: function camStatusChanged() {\n      localUser.setVideoActive(!localUser.isVideoActive());\n      localUser.getStreamManager().publishVideo(localUser.isVideoActive());\n      this.sendSignalUserChanged({\n        isVideoActive: localUser.isVideoActive()\n      });\n      this.setState({\n        localUser: localUser\n      });\n    }\n  }, {\n    key: \"micStatusChanged\",\n    value: function micStatusChanged() {\n      localUser.setAudioActive(!localUser.isAudioActive());\n      localUser.getStreamManager().publishAudio(localUser.isAudioActive());\n      this.sendSignalUserChanged({\n        isAudioActive: localUser.isAudioActive()\n      });\n      this.setState({\n        localUser: localUser\n      });\n    }\n  }, {\n    key: \"nicknameChanged\",\n    value: function nicknameChanged(nickname) {\n      var localUser = this.state.localUser;\n      localUser.setNickname(nickname);\n      this.setState({\n        localUser: localUser\n      });\n      this.sendSignalUserChanged({\n        nickname: this.state.localUser.getNickname()\n      });\n    }\n  }, {\n    key: \"deleteSubscriber\",\n    value: function deleteSubscriber(stream) {\n      var remoteUsers = this.state.subscribers;\n      var userStream = remoteUsers.filter(function (user) {\n        return user.getStreamManager().stream === stream;\n      })[0];\n      var index = remoteUsers.indexOf(userStream, 0);\n\n      if (index > -1) {\n        remoteUsers.splice(index, 1);\n        this.setState({\n          subscribers: remoteUsers\n        });\n      }\n    }\n  }, {\n    key: \"subscribeToStreamCreated\",\n    value: function subscribeToStreamCreated() {\n      var _this7 = this;\n\n      this.state.session.on('streamCreated', function (event) {\n        var subscriber = _this7.state.session.subscribe(event.stream, undefined); // var subscribers = this.state.subscribers;\n\n\n        subscriber.on('streamPlaying', function (e) {\n          _this7.checkSomeoneShareScreen();\n\n          subscriber.videos[0].video.parentElement.classList.remove('custom-class');\n        });\n        var newUser = new _userModel[\"default\"]();\n        newUser.setStreamManager(subscriber);\n        newUser.setConnectionId(event.stream.connection.connectionId);\n        newUser.setType('remote');\n        var nickname = event.stream.connection.data.split('%')[0];\n        newUser.setNickname(JSON.parse(nickname).clientData);\n\n        _this7.remotes.push(newUser);\n\n        if (_this7.localUserAccessAllowed) {\n          _this7.updateSubscribers();\n        }\n      });\n    }\n  }, {\n    key: \"subscribeToStreamDestroyed\",\n    value: function subscribeToStreamDestroyed() {\n      var _this8 = this; // On every Stream destroyed...\n\n\n      this.state.session.on('streamDestroyed', function (event) {\n        // Remove the stream from 'subscribers' array\n        _this8.deleteSubscriber(event.stream);\n\n        setTimeout(function () {\n          _this8.checkSomeoneShareScreen();\n        }, 20);\n        event.preventDefault();\n\n        _this8.updateLayout();\n      });\n    }\n  }, {\n    key: \"subscribeToUserChanged\",\n    value: function subscribeToUserChanged() {\n      var _this9 = this;\n\n      this.state.session.on('signal:userChanged', function (event) {\n        var remoteUsers = _this9.state.subscribers;\n        remoteUsers.forEach(function (user) {\n          if (user.getConnectionId() === event.from.connectionId) {\n            var data = JSON.parse(event.data);\n            console.log('EVENTO REMOTE: ', event.data);\n\n            if (data.isAudioActive !== undefined) {\n              user.setAudioActive(data.isAudioActive);\n            }\n\n            if (data.isVideoActive !== undefined) {\n              user.setVideoActive(data.isVideoActive);\n            }\n\n            if (data.nickname !== undefined) {\n              user.setNickname(data.nickname);\n            }\n\n            if (data.isScreenShareActive !== undefined) {\n              user.setScreenShareActive(data.isScreenShareActive);\n            }\n          }\n        });\n\n        _this9.setState({\n          subscribers: remoteUsers\n        }, function () {\n          return _this9.checkSomeoneShareScreen();\n        });\n      });\n    }\n  }, {\n    key: \"updateLayout\",\n    value: function updateLayout() {\n      var _this10 = this;\n\n      setTimeout(function () {\n        _this10.layout.updateLayout();\n      }, 20);\n    }\n  }, {\n    key: \"sendSignalUserChanged\",\n    value: function sendSignalUserChanged(data) {\n      var signalOptions = {\n        data: JSON.stringify(data),\n        type: 'userChanged'\n      };\n      this.state.session.signal(signalOptions);\n    }\n  }, {\n    key: \"toggleFullscreen\",\n    value: function toggleFullscreen() {\n      var document = window.document;\n      var fs = document.getElementById('container');\n\n      if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {\n        if (fs.requestFullscreen) {\n          fs.requestFullscreen();\n        } else if (fs.msRequestFullscreen) {\n          fs.msRequestFullscreen();\n        } else if (fs.mozRequestFullScreen) {\n          fs.mozRequestFullScreen();\n        } else if (fs.webkitRequestFullscreen) {\n          fs.webkitRequestFullscreen();\n        }\n      } else {\n        if (document.exitFullscreen) {\n          document.exitFullscreen();\n        } else if (document.msExitFullscreen) {\n          document.msExitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n          document.mozCancelFullScreen();\n        } else if (document.webkitExitFullscreen) {\n          document.webkitExitFullscreen();\n        }\n      }\n    }\n  }, {\n    key: \"switchCamera\",\n    value: function () {\n      var _switchCamera = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this11 = this;\n\n        var devices, videoDevices, newVideoDevice, newPublisher;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.OV.getDevices();\n\n              case 3:\n                devices = _context2.sent;\n                videoDevices = devices.filter(function (device) {\n                  return device.kind === 'videoinput';\n                });\n\n                if (!(videoDevices && videoDevices.length > 1)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                newVideoDevice = videoDevices.filter(function (device) {\n                  return device.deviceId !== _this11.state.currentVideoDevice.deviceId;\n                });\n\n                if (!(newVideoDevice.length > 0)) {\n                  _context2.next = 15;\n                  break;\n                } // Creating a new publisher with specific videoSource\n                // In mobile devices the default and first camera is the front one\n\n\n                newPublisher = this.OV.initPublisher(undefined, {\n                  audioSource: undefined,\n                  videoSource: newVideoDevice[0].deviceId,\n                  publishAudio: localUser.isAudioActive(),\n                  publishVideo: localUser.isVideoActive(),\n                  mirror: true\n                }); //newPublisher.once(\"accessAllowed\", () => {\n\n                _context2.next = 11;\n                return this.state.session.unpublish(this.state.localUser.getStreamManager());\n\n              case 11:\n                _context2.next = 13;\n                return this.state.session.publish(newPublisher);\n\n              case 13:\n                this.state.localUser.setStreamManager(newPublisher);\n                this.setState({\n                  currentVideoDevice: newVideoDevice,\n                  localUser: localUser\n                });\n\n              case 15:\n                _context2.next = 20;\n                break;\n\n              case 17:\n                _context2.prev = 17;\n                _context2.t0 = _context2[\"catch\"](0);\n                console.error(_context2.t0);\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 17]]);\n      }));\n\n      function switchCamera() {\n        return _switchCamera.apply(this, arguments);\n      }\n\n      return switchCamera;\n    }()\n  }, {\n    key: \"screenShare\",\n    value: function screenShare() {\n      var _this12 = this;\n\n      var videoSource = navigator.userAgent.indexOf('Firefox') !== -1 ? 'window' : 'screen';\n      var publisher = this.OV.initPublisher(undefined, {\n        videoSource: videoSource,\n        publishAudio: localUser.isAudioActive(),\n        publishVideo: localUser.isVideoActive(),\n        mirror: false\n      }, function (error) {\n        if (error && error.name === 'SCREEN_EXTENSION_NOT_INSTALLED') {\n          _this12.setState({\n            showExtensionDialog: true\n          });\n        } else if (error && error.name === 'SCREEN_SHARING_NOT_SUPPORTED') {\n          alert('Your browser does not support screen sharing');\n        } else if (error && error.name === 'SCREEN_EXTENSION_DISABLED') {\n          alert('You need to enable screen sharing extension');\n        } else if (error && error.name === 'SCREEN_CAPTURE_DENIED') {\n          alert('You need to choose a window or application to share');\n        }\n      });\n      publisher.once('accessAllowed', function () {\n        _this12.state.session.unpublish(localUser.getStreamManager());\n\n        localUser.setStreamManager(publisher);\n\n        _this12.state.session.publish(localUser.getStreamManager()).then(function () {\n          localUser.setScreenShareActive(true);\n\n          _this12.setState({\n            localUser: localUser\n          }, function () {\n            _this12.sendSignalUserChanged({\n              isScreenShareActive: localUser.isScreenShareActive()\n            });\n          });\n        });\n      });\n      publisher.on('streamPlaying', function () {\n        _this12.updateLayout();\n\n        publisher.videos[0].video.parentElement.classList.remove('custom-class');\n      });\n    }\n  }, {\n    key: \"closeDialogExtension\",\n    value: function closeDialogExtension() {\n      this.setState({\n        showExtensionDialog: false\n      });\n    }\n  }, {\n    key: \"stopScreenShare\",\n    value: function stopScreenShare() {\n      this.state.session.unpublish(localUser.getStreamManager());\n      this.connectWebCam();\n    }\n  }, {\n    key: \"checkSomeoneShareScreen\",\n    value: function checkSomeoneShareScreen() {\n      var isScreenShared; // return true if at least one passes the test\n\n      isScreenShared = this.state.subscribers.some(function (user) {\n        return user.isScreenShareActive();\n      }) || localUser.isScreenShareActive();\n      var openviduLayoutOptions = {\n        maxRatio: 3 / 2,\n        minRatio: 9 / 16,\n        fixedRatio: isScreenShared,\n        bigClass: 'OV_big',\n        bigPercentage: 0.8,\n        bigFixedRatio: false,\n        bigMaxRatio: 3 / 2,\n        bigMinRatio: 9 / 16,\n        bigFirst: true,\n        animate: true\n      };\n      this.layout.setLayoutOptions(openviduLayoutOptions);\n      this.updateLayout();\n    }\n  }, {\n    key: \"toggleChat\",\n    value: function toggleChat(property) {\n      var display = property;\n\n      if (display === undefined) {\n        display = this.state.chatDisplay === 'none' ? 'block' : 'none';\n      }\n\n      if (display === 'block') {\n        this.setState({\n          chatDisplay: display,\n          messageReceived: false\n        });\n      } else {\n        console.log('chat', display);\n        this.setState({\n          chatDisplay: display\n        });\n      }\n\n      this.updateLayout();\n    }\n  }, {\n    key: \"checkNotification\",\n    value: function checkNotification(event) {\n      this.setState({\n        messageReceived: this.state.chatDisplay === 'none'\n      });\n    }\n  }, {\n    key: \"checkSize\",\n    value: function checkSize() {\n      if (document.getElementById('layout').offsetWidth <= 700 && !this.hasBeenUpdated) {\n        this.toggleChat('none');\n        this.hasBeenUpdated = true;\n      }\n\n      if (document.getElementById('layout').offsetWidth > 700 && this.hasBeenUpdated) {\n        this.hasBeenUpdated = false;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var mySessionId = this.state.mySessionId;\n      var localUser = this.state.localUser;\n      var chatDisplay = {\n        display: this.state.chatDisplay\n      };\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"container\",\n        id: \"container\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(_ToolbarComponent[\"default\"], {\n        sessionId: mySessionId,\n        user: localUser,\n        showNotification: this.state.messageReceived,\n        camStatusChanged: this.camStatusChanged,\n        micStatusChanged: this.micStatusChanged,\n        screenShare: this.screenShare,\n        stopScreenShare: this.stopScreenShare,\n        toggleFullscreen: this.toggleFullscreen,\n        switchCamera: this.switchCamera,\n        leaveSession: this.leaveSession,\n        toggleChat: this.toggleChat\n      }), /*#__PURE__*/_react[\"default\"].createElement(_DialogExtension[\"default\"], {\n        showDialog: this.state.showExtensionDialog,\n        cancelClicked: this.closeDialogExtension\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        id: \"layout\",\n        className: \"bounds\"\n      }, localUser !== undefined && localUser.getStreamManager() !== undefined && /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"OT_root OT_publisher custom-class\",\n        id: \"localUser\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(_StreamComponent[\"default\"], {\n        user: localUser,\n        handleNickname: this.nicknameChanged\n      })), this.state.subscribers.map(function (sub, i) {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          key: i,\n          className: \"OT_root OT_publisher custom-class\",\n          id: \"remoteUsers\"\n        }, /*#__PURE__*/_react[\"default\"].createElement(_StreamComponent[\"default\"], {\n          user: sub,\n          streamId: sub.streamManager.stream.streamId\n        }));\n      }), localUser !== undefined && localUser.getStreamManager() !== undefined && /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"OT_root OT_publisher custom-class\",\n        style: chatDisplay\n      }, /*#__PURE__*/_react[\"default\"].createElement(_ChatComponent[\"default\"], {\n        user: localUser,\n        chatDisplay: this.state.chatDisplay,\n        close: this.toggleChat,\n        messageReceived: this.checkNotification\n      }))));\n    }\n    /**\n     * --------------------------\n     * SERVER-SIDE RESPONSIBILITY\n     * --------------------------\n     * These methods retrieve the mandatory user token from OpenVidu Server.\n     * This behaviour MUST BE IN YOUR SERVER-SIDE IN PRODUCTION (by using\n     * the API REST, openvidu-java-client or openvidu-node-client):\n     *   1) Initialize a session in OpenVidu Server\t(POST /api/sessions)\n     *   2) Generate a token in OpenVidu Server\t\t(POST /api/tokens)\n     *   3) The token must be consumed in Session.connect() method\n     */\n\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var _this13 = this;\n\n      return this.createSession(this.state.mySessionId).then(function (sessionId) {\n        return _this13.createToken(sessionId);\n      });\n    }\n  }, {\n    key: \"createSession\",\n    value: function createSession(sessionId) {\n      var _this14 = this;\n\n      return new Promise(function (resolve, reject) {\n        var data = JSON.stringify({\n          customSessionId: sessionId\n        });\n\n        _axios[\"default\"].post(_this14.OPENVIDU_SERVER_URL + '/openvidu/api/sessions', data, {\n          headers: {\n            Authorization: 'Basic ' + btoa('OPENVIDUAPP:' + _this14.OPENVIDU_SERVER_SECRET),\n            'Content-Type': 'application/json'\n          }\n        }).then(function (response) {\n          console.log('CREATE SESION', response);\n          resolve(response.data.id);\n        })[\"catch\"](function (response) {\n          var error = Object.assign({}, response);\n\n          if (error.response && error.response.status === 409) {\n            resolve(sessionId);\n          } else {\n            console.log(error);\n            console.warn('No connection to OpenVidu Server. This may be a certificate error at ' + _this14.OPENVIDU_SERVER_URL);\n\n            if (window.confirm('No connection to OpenVidu Server. This may be a certificate error at \"' + _this14.OPENVIDU_SERVER_URL + '\"\\n\\nClick OK to navigate and accept it. ' + 'If no certificate warning is shown, then check that your OpenVidu Server is up and running at \"' + _this14.OPENVIDU_SERVER_URL + '\"')) {\n              window.location.assign(_this14.OPENVIDU_SERVER_URL + '/accept-certificate');\n            }\n          }\n        });\n      });\n    }\n  }, {\n    key: \"createToken\",\n    value: function createToken(sessionId) {\n      var _this15 = this;\n\n      return new Promise(function (resolve, reject) {\n        var data = JSON.stringify({});\n\n        _axios[\"default\"].post(_this15.OPENVIDU_SERVER_URL + '/openvidu/api/sessions/' + sessionId + '/connection', data, {\n          headers: {\n            Authorization: 'Basic ' + btoa('OPENVIDUAPP:' + _this15.OPENVIDU_SERVER_SECRET),\n            'Content-Type': 'application/json'\n          }\n        }).then(function (response) {\n          console.log('TOKEN', response);\n          resolve(response.data.token);\n        })[\"catch\"](function (error) {\n          return reject(error);\n        });\n      });\n    }\n  }]);\n\n  return VideoRoomComponent;\n}(_react.Component);\n\nvar _default = VideoRoomComponent;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
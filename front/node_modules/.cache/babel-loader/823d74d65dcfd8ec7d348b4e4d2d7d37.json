{"ast":null,"code":"var defineProperty_IE8 = false;\n\nif (Object.defineProperty) {\n  try {\n    Object.defineProperty({}, \"x\", {});\n  } catch (e) {\n    defineProperty_IE8 = true;\n  }\n}\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function fNOP() {},\n        fBound = function fBound() {\n      return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('inherits');\n\nvar packers = require('./packers');\n\nvar Mapper = require('./Mapper');\n\nvar BASE_TIMEOUT = 5000;\n\nfunction unifyResponseMethods(responseMethods) {\n  if (!responseMethods) return {};\n\n  for (var key in responseMethods) {\n    var value = responseMethods[key];\n    if (typeof value == 'string') responseMethods[key] = {\n      response: value\n    };\n  }\n\n  ;\n  return responseMethods;\n}\n\n;\n\nfunction unifyTransport(transport) {\n  if (!transport) return;\n  if (transport instanceof Function) return {\n    send: transport\n  };\n  if (transport.send instanceof Function) return transport;\n\n  if (transport.postMessage instanceof Function) {\n    transport.send = transport.postMessage;\n    return transport;\n  }\n\n  if (transport.write instanceof Function) {\n    transport.send = transport.write;\n    return transport;\n  }\n\n  if (transport.onmessage !== undefined) return;\n  if (transport.pause instanceof Function) return;\n  throw new SyntaxError(\"Transport is not a function nor a valid object\");\n}\n\n;\n\nfunction RpcNotification(method, params) {\n  if (defineProperty_IE8) {\n    this.method = method;\n    this.params = params;\n  } else {\n    Object.defineProperty(this, 'method', {\n      value: method,\n      enumerable: true\n    });\n    Object.defineProperty(this, 'params', {\n      value: params,\n      enumerable: true\n    });\n  }\n}\n\n;\n\nfunction RpcBuilder(packer, options, transport, onRequest) {\n  var self = this;\n  if (!packer) throw new SyntaxError('Packer is not defined');\n  if (!packer.pack || !packer.unpack) throw new SyntaxError('Packer is invalid');\n  var responseMethods = unifyResponseMethods(packer.responseMethods);\n\n  if (options instanceof Function) {\n    if (transport != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n    onRequest = options;\n    transport = undefined;\n    options = undefined;\n  }\n\n  ;\n\n  if (options && options.send instanceof Function) {\n    if (transport && !(transport instanceof Function)) throw new SyntaxError(\"Only a function can be after transport\");\n    onRequest = transport;\n    transport = options;\n    options = undefined;\n  }\n\n  ;\n\n  if (transport instanceof Function) {\n    if (onRequest != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n    onRequest = transport;\n    transport = undefined;\n  }\n\n  ;\n  if (transport && transport.send instanceof Function) if (onRequest && !(onRequest instanceof Function)) throw new SyntaxError(\"Only a function can be after transport\");\n  options = options || {};\n  EventEmitter.call(this);\n  if (onRequest) this.on('request', onRequest);\n  if (defineProperty_IE8) this.peerID = options.peerID;else Object.defineProperty(this, 'peerID', {\n    value: options.peerID\n  });\n  var max_retries = options.max_retries || 0;\n\n  function transportMessage(event) {\n    self.decode(event.data || event);\n  }\n\n  ;\n\n  this.getTransport = function () {\n    return transport;\n  };\n\n  this.setTransport = function (value) {\n    if (transport) {\n      if (transport.removeEventListener) transport.removeEventListener('message', transportMessage);else if (transport.removeListener) transport.removeListener('data', transportMessage);\n    }\n\n    ;\n\n    if (value) {\n      if (value.addEventListener) value.addEventListener('message', transportMessage);else if (value.addListener) value.addListener('data', transportMessage);\n    }\n\n    ;\n    transport = unifyTransport(value);\n  };\n\n  if (!defineProperty_IE8) Object.defineProperty(this, 'transport', {\n    get: this.getTransport.bind(this),\n    set: this.setTransport.bind(this)\n  });\n  this.setTransport(transport);\n  var request_timeout = options.request_timeout || BASE_TIMEOUT;\n  var ping_request_timeout = options.ping_request_timeout || request_timeout;\n  var response_timeout = options.response_timeout || BASE_TIMEOUT;\n  var duplicates_timeout = options.duplicates_timeout || BASE_TIMEOUT;\n  var requestID = 0;\n  var requests = new Mapper();\n  var responses = new Mapper();\n  var processedResponses = new Mapper();\n  var message2Key = {};\n\n  function storeResponse(message, id, dest) {\n    var response = {\n      message: message,\n      timeout: setTimeout(function () {\n        responses.remove(id, dest);\n      }, response_timeout)\n    };\n    responses.set(response, id, dest);\n  }\n\n  ;\n\n  function storeProcessedResponse(ack, from) {\n    var timeout = setTimeout(function () {\n      processedResponses.remove(ack, from);\n    }, duplicates_timeout);\n    processedResponses.set(timeout, ack, from);\n  }\n\n  ;\n\n  function RpcRequest(method, params, id, from, transport) {\n    RpcNotification.call(this, method, params);\n\n    this.getTransport = function () {\n      return transport;\n    };\n\n    this.setTransport = function (value) {\n      transport = unifyTransport(value);\n    };\n\n    if (!defineProperty_IE8) Object.defineProperty(this, 'transport', {\n      get: this.getTransport.bind(this),\n      set: this.setTransport.bind(this)\n    });\n    var response = responses.get(id, from);\n\n    if (!(transport || self.getTransport())) {\n      if (defineProperty_IE8) this.duplicated = Boolean(response);else Object.defineProperty(this, 'duplicated', {\n        value: Boolean(response)\n      });\n    }\n\n    var responseMethod = responseMethods[method];\n    this.pack = packer.pack.bind(packer, this, id);\n\n    this.reply = function (error, result, transport) {\n      if (error instanceof Function || error && error.send instanceof Function) {\n        if (result != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n        transport = error;\n        result = null;\n        error = undefined;\n      } else if (result instanceof Function || result && result.send instanceof Function) {\n        if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n        transport = result;\n        result = null;\n      }\n\n      ;\n      transport = unifyTransport(transport);\n      if (response) clearTimeout(response.timeout);\n\n      if (from != undefined) {\n        if (error) error.dest = from;\n        if (result) result.dest = from;\n      }\n\n      ;\n      var message;\n\n      if (error || result != undefined) {\n        if (self.peerID != undefined) {\n          if (error) error.from = self.peerID;else result.from = self.peerID;\n        }\n\n        if (responseMethod) {\n          if (responseMethod.error == undefined && error) message = {\n            error: error\n          };else {\n            var method = error ? responseMethod.error : responseMethod.response;\n            message = {\n              method: method,\n              params: error || result\n            };\n          }\n        } else message = {\n          error: error,\n          result: result\n        };\n\n        message = packer.pack(message, id);\n      } else if (response) message = response.message;else message = packer.pack({\n        result: null\n      }, id);\n\n      storeResponse(message, id, from);\n      transport = transport || this.getTransport() || self.getTransport();\n      if (transport) return transport.send(message);\n      return message;\n    };\n  }\n\n  ;\n  inherits(RpcRequest, RpcNotification);\n\n  function cancel(message) {\n    var key = message2Key[message];\n    if (!key) return;\n    delete message2Key[message];\n    var request = requests.pop(key.id, key.dest);\n    if (!request) return;\n    clearTimeout(request.timeout);\n    storeProcessedResponse(key.id, key.dest);\n  }\n\n  ;\n\n  this.cancel = function (message) {\n    if (message) return cancel(message);\n\n    for (var message in message2Key) {\n      cancel(message);\n    }\n  };\n\n  this.close = function () {\n    var transport = this.getTransport();\n    if (transport && transport.close) transport.close(4003, \"Cancel request\");\n    this.cancel();\n    processedResponses.forEach(clearTimeout);\n    responses.forEach(function (response) {\n      clearTimeout(response.timeout);\n    });\n  };\n\n  this.encode = function (method, params, dest, transport, callback) {\n    if (params instanceof Function) {\n      if (dest != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = params;\n      transport = undefined;\n      dest = undefined;\n      params = undefined;\n    } else if (dest instanceof Function) {\n      if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = dest;\n      transport = undefined;\n      dest = undefined;\n    } else if (transport instanceof Function) {\n      if (callback != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = transport;\n      transport = undefined;\n    }\n\n    ;\n\n    if (self.peerID != undefined) {\n      params = params || {};\n      params.from = self.peerID;\n    }\n\n    ;\n\n    if (dest != undefined) {\n      params = params || {};\n      params.dest = dest;\n    }\n\n    ;\n    var message = {\n      method: method,\n      params: params\n    };\n\n    if (callback) {\n      var dispatchCallback = function dispatchCallback(error, result) {\n        self.cancel(message);\n        callback(error, result);\n      };\n\n      var sendRequest = function sendRequest(transport) {\n        var rt = method === 'ping' ? ping_request_timeout : request_timeout;\n        request.timeout = setTimeout(timeout, rt * Math.pow(2, retried++));\n        message2Key[message] = {\n          id: id,\n          dest: dest\n        };\n        requests.set(request, id, dest);\n        transport = transport || encode_transport || self.getTransport();\n        if (transport) return transport.send(message);\n        return message;\n      };\n\n      var retry = function retry(transport) {\n        transport = unifyTransport(transport);\n        console.warn(retried + ' retry for request message:', message);\n        var timeout = processedResponses.pop(id, dest);\n        clearTimeout(timeout);\n        return sendRequest(transport);\n      };\n\n      var timeout = function timeout() {\n        if (retried < max_retries) return retry(transport);\n        var error = new Error('Request has timed out');\n        error.request = message;\n        error.retry = retry;\n        dispatchCallback(error);\n      };\n\n      var id = requestID++;\n      var retried = 0;\n      message = packer.pack(message, id);\n      ;\n      var request = {\n        message: message,\n        callback: dispatchCallback,\n        responseMethods: responseMethods[method] || {}\n      };\n      var encode_transport = unifyTransport(transport);\n      ;\n      ;\n      ;\n      return sendRequest(transport);\n    }\n\n    ;\n    message = packer.pack(message);\n    transport = transport || this.getTransport();\n    if (transport) return transport.send(message);\n    return message;\n  };\n\n  this.decode = function (message, transport) {\n    if (!message) throw new TypeError(\"Message is not defined\");\n\n    try {\n      message = packer.unpack(message);\n    } catch (e) {\n      return console.debug(e, message);\n    }\n\n    ;\n    var id = message.id;\n    var ack = message.ack;\n    var method = message.method;\n    var params = message.params || {};\n    var from = params.from;\n    var dest = params.dest;\n    if (self.peerID != undefined && from == self.peerID) return;\n\n    if (id == undefined && ack == undefined) {\n      var notification = new RpcNotification(method, params);\n      if (self.emit('request', notification)) return;\n      return notification;\n    }\n\n    ;\n\n    function processRequest() {\n      transport = unifyTransport(transport) || self.getTransport();\n\n      if (transport) {\n        var response = responses.get(id, from);\n        if (response) return transport.send(response.message);\n      }\n\n      ;\n      var idAck = id != undefined ? id : ack;\n      var request = new RpcRequest(method, params, idAck, from, transport);\n      if (self.emit('request', request)) return;\n      return request;\n    }\n\n    ;\n\n    function processResponse(request, error, result) {\n      request.callback(error, result);\n    }\n\n    ;\n\n    function duplicatedResponse(timeout) {\n      console.warn(\"Response already processed\", message);\n      clearTimeout(timeout);\n      storeProcessedResponse(ack, from);\n    }\n\n    ;\n\n    if (method) {\n      if (dest == undefined || dest == self.peerID) {\n        var request = requests.get(ack, from);\n\n        if (request) {\n          var responseMethods = request.responseMethods;\n          if (method == responseMethods.error) return processResponse(request, params);\n          if (method == responseMethods.response) return processResponse(request, null, params);\n          return processRequest();\n        }\n\n        var processed = processedResponses.get(ack, from);\n        if (processed) return duplicatedResponse(processed);\n      }\n\n      return processRequest();\n    }\n\n    ;\n    var error = message.error;\n    var result = message.result;\n    if (error && error.dest && error.dest != self.peerID) return;\n    if (result && result.dest && result.dest != self.peerID) return;\n    var request = requests.get(ack, from);\n\n    if (!request) {\n      var processed = processedResponses.get(ack, from);\n      if (processed) return duplicatedResponse(processed);\n      return console.warn(\"No callback was defined for this message\", message);\n    }\n\n    ;\n    processResponse(request, error, result);\n  };\n}\n\n;\ninherits(RpcBuilder, EventEmitter);\nRpcBuilder.RpcNotification = RpcNotification;\nmodule.exports = RpcBuilder;\n\nvar clients = require('./clients');\n\nvar transports = require('./clients/transports');\n\nRpcBuilder.clients = clients;\nRpcBuilder.clients.transports = transports;\nRpcBuilder.packers = packers;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Publisher = void 0;\n\nvar Session_1 = require(\"./Session\");\n\nvar Stream_1 = require(\"./Stream\");\n\nvar StreamManager_1 = require(\"./StreamManager\");\n\nvar StreamEvent_1 = require(\"../OpenViduInternal/Events/StreamEvent\");\n\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\n\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with [[OpenVidu.initPublisher]] method.\n *\n * See available event listeners at [[PublisherEventMap]].\n */\n\nvar Publisher =\n/** @class */\nfunction (_super) {\n  __extends(Publisher, _super);\n  /**\n   * @hidden\n   */\n\n\n  function Publisher(targEl, properties, openvidu) {\n    var _this = _super.call(this, new Stream_1.Stream(!!openvidu.session ? openvidu.session : new Session_1.Session(openvidu), {\n      publisherProperties: properties,\n      mediaConstraints: {}\n    }), targEl) || this;\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n\n\n    _this.accessAllowed = false;\n    /**\n     * Whether you have called [[Publisher.subscribeToRemote]] with value `true` or `false` (*false* by default)\n     */\n\n    _this.isSubscribedToRemote = false;\n    _this.accessDenied = false;\n    platform = Platform_1.PlatformUtils.getInstance();\n    _this.properties = properties;\n    _this.openvidu = openvidu;\n\n    _this.stream.ee.on('local-stream-destroyed', function (reason) {\n      _this.stream.isLocalStreamPublished = false;\n      var streamEvent = new StreamEvent_1.StreamEvent(true, _this, 'streamDestroyed', _this.stream, reason);\n\n      _this.emitEvent('streamDestroyed', [streamEvent]);\n\n      streamEvent.callDefaultBehavior();\n    });\n\n    return _this;\n  }\n  /**\n   * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The [[Session]] object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The [[Publisher]] object of the local participant will also dispatch the exact same event\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The respective [[Subscriber]] object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See [[StreamPropertyChangedEvent]] to learn more.\n   *\n   * @param enabled `true` to publish the audio stream, `false` to unpublish it\n   */\n\n\n  Publisher.prototype.publishAudio = function (enabled) {\n    var _this = this;\n\n    if (this.stream.audioActive !== enabled) {\n      var affectedMediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n      affectedMediaStream.getAudioTracks().forEach(function (track) {\n        track.enabled = enabled;\n      });\n\n      if (!!this.session && !!this.stream.streamId) {\n        this.session.openvidu.sendRequest('streamPropertyChanged', {\n          streamId: this.stream.streamId,\n          property: 'audioActive',\n          newValue: enabled,\n          reason: 'publishAudio'\n        }, function (error, response) {\n          if (error) {\n            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n          } else {\n            _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n\n            _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n\n            _this.session.sendVideoData(_this.stream.streamManager);\n          }\n        });\n      }\n\n      this.stream.audioActive = enabled;\n      logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n    }\n  };\n  /**\n   * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The [[Session]] object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The [[Publisher]] object of the local participant will also dispatch the exact same event\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The respective [[Subscriber]] object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See [[StreamPropertyChangedEvent]] to learn more.\n   *\n   * @param enabled `true` to publish the video stream, `false` to unpublish it\n   * @param resource\n   * - If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n   * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n   * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.</li>\n   * - If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n   * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n   * will be used instead.\n   */\n\n\n  Publisher.prototype.publishVideo = function (enabled, resource) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var affectedMediaStream_1, mustRestartMediaStream_1, oldVideoTrack, replaceVideoTrack, mediaStream, error_1;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.stream.videoActive !== enabled)) return [3\n              /*break*/\n              , 9];\n              affectedMediaStream_1 = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n              mustRestartMediaStream_1 = false;\n              affectedMediaStream_1.getVideoTracks().forEach(function (track) {\n                track.enabled = enabled;\n\n                if (!enabled && resource === true) {\n                  track.stop();\n                } else if (enabled && track.readyState === 'ended') {\n                  // Resource was freed\n                  mustRestartMediaStream_1 = true;\n                }\n              });\n              if (!(!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:'))) return [3\n              /*break*/\n              , 2];\n              this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n\n              return [4\n              /*yield*/\n              , this.stream.removeFilterAux(true)];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              if (!mustRestartMediaStream_1) return [3\n              /*break*/\n              , 8];\n              oldVideoTrack = affectedMediaStream_1.getVideoTracks()[0];\n              affectedMediaStream_1.removeTrack(oldVideoTrack);\n\n              replaceVideoTrack = function replaceVideoTrack(tr) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var _this = this;\n\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        affectedMediaStream_1.addTrack(tr);\n                        if (!this.stream.isLocalStreamPublished) return [3\n                        /*break*/\n                        , 2];\n                        return [4\n                        /*yield*/\n                        , this.replaceTrackInRtcRtpSender(tr)];\n\n                      case 1:\n                        _a.sent();\n\n                        _a.label = 2;\n\n                      case 2:\n                        if (!!this.stream.lastVBFilter) {\n                          setTimeout(function () {\n                            return __awaiter(_this, void 0, void 0, function () {\n                              var options, lastExecMethod;\n                              return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                  case 0:\n                                    options = this.stream.lastVBFilter.options;\n                                    lastExecMethod = this.stream.lastVBFilter.lastExecMethod;\n\n                                    if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                      options = Object.assign({}, options, lastExecMethod.params);\n                                    }\n\n                                    return [4\n                                    /*yield*/\n                                    , this.stream.applyFilter(this.stream.lastVBFilter.type, options)];\n\n                                  case 1:\n                                    _a.sent();\n\n                                    delete this.stream.lastVBFilter;\n                                    return [2\n                                    /*return*/\n                                    ];\n                                }\n                              });\n                            });\n                          }, 1);\n                        }\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n\n              if (!(!!resource && resource instanceof MediaStreamTrack)) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , replaceVideoTrack(resource)];\n\n            case 3:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 4:\n              _a.trys.push([4, 7,, 8]);\n\n              return [4\n              /*yield*/\n              , navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: this.stream.lastVideoTrackConstraints\n              })];\n\n            case 5:\n              mediaStream = _a.sent();\n              return [4\n              /*yield*/\n              , replaceVideoTrack(mediaStream.getVideoTracks()[0])];\n\n            case 6:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 7:\n              error_1 = _a.sent();\n              return [2\n              /*return*/\n              , reject(error_1)];\n\n            case 8:\n              if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest('streamPropertyChanged', {\n                  streamId: this.stream.streamId,\n                  property: 'videoActive',\n                  newValue: enabled,\n                  reason: 'publishVideo'\n                }, function (error, response) {\n                  if (error) {\n                    logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                  } else {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n\n                    _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n\n                    _this.session.sendVideoData(_this.stream.streamManager);\n                  }\n                });\n              }\n\n              this.stream.videoActive = enabled;\n              logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n              return [2\n              /*return*/\n              , resolve()];\n\n            case 9:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Call this method before [[Session.publish]] if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n   */\n\n\n  Publisher.prototype.subscribeToRemote = function (value) {\n    value = value !== undefined ? value : true;\n    this.isSubscribedToRemote = value;\n    this.stream.subscribeToMyRemote(value);\n  };\n  /**\n   * See [[EventDispatcher.on]]\n   */\n\n\n  Publisher.prototype.on = function (type, handler) {\n    var _this = this;\n\n    _super.prototype.on.call(this, type, handler);\n\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.on('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.once]]\n   */\n\n\n  Publisher.prototype.once = function (type, handler) {\n    var _this = this;\n\n    _super.prototype.once.call(this, type, handler);\n\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.once('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.off]]\n   */\n\n\n  Publisher.prototype.off = function (type, handler) {\n    _super.prototype.off.call(this, type, handler);\n\n    return this;\n  };\n  /**\n   * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n   * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n   * and publishing the new one).\n   *\n   * You can get this new MediaStreamTrack by using the native Web API or simply with [[OpenVidu.getUserMedia]] method.\n   *\n   * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n   * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n   * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n   *\n   * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n   * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n   */\n\n\n  Publisher.prototype.replaceTrack = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.replaceTrackAux(track, true)];\n      });\n    });\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.initialize = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var constraints = {};\n      var constraintsAux = {};\n      var timeForDialogEvent = 2000;\n      var startTime;\n\n      var errorCallback = function errorCallback(openViduError) {\n        _this.accessDenied = true;\n        _this.accessAllowed = false;\n        logger.error(\"Publisher initialization failed. \".concat(openViduError.name, \": \").concat(openViduError.message));\n        return reject(openViduError);\n      };\n\n      var successCallback = function successCallback(mediaStream) {\n        var _a, _b;\n\n        _this.accessAllowed = true;\n        _this.accessDenied = false;\n\n        if (typeof MediaStreamTrack !== 'undefined' && _this.properties.audioSource instanceof MediaStreamTrack) {\n          mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n          mediaStream.addTrack(_this.properties.audioSource);\n        }\n\n        if (typeof MediaStreamTrack !== 'undefined' && _this.properties.videoSource instanceof MediaStreamTrack) {\n          mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n          mediaStream.addTrack(_this.properties.videoSource);\n        } // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n\n\n        if (!!mediaStream.getAudioTracks()[0]) {\n          var enabled = _this.stream.audioActive !== undefined && _this.stream.audioActive !== null ? _this.stream.audioActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n          mediaStream.getAudioTracks()[0].enabled = enabled;\n        }\n\n        if (!!mediaStream.getVideoTracks()[0]) {\n          var enabled = _this.stream.videoActive !== undefined && _this.stream.videoActive !== null ? _this.stream.videoActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n          mediaStream.getVideoTracks()[0].enabled = enabled;\n        } // Set Content Hint on all MediaStreamTracks\n\n\n        for (var _i = 0, _c = mediaStream.getAudioTracks(); _i < _c.length; _i++) {\n          var track = _c[_i];\n\n          if (!((_a = track.contentHint) === null || _a === void 0 ? void 0 : _a.length)) {\n            // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n            // https://w3c.github.io/mst-content-hint/#audio-content-hints\n            track.contentHint = '';\n            logger.info(\"Audio track Content Hint set: '\".concat(track.contentHint, \"'\"));\n          }\n        }\n\n        for (var _d = 0, _e = mediaStream.getVideoTracks(); _d < _e.length; _d++) {\n          var track = _e[_d];\n\n          if (!((_b = track.contentHint) === null || _b === void 0 ? void 0 : _b.length)) {\n            // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n            // https://w3c.github.io/mst-content-hint/#video-content-hints\n            switch (_this.stream.typeOfVideo) {\n              case TypeOfVideo_1.TypeOfVideo.SCREEN:\n                track.contentHint = \"detail\";\n                break;\n\n              case TypeOfVideo_1.TypeOfVideo.CUSTOM:\n                logger.warn(\"CUSTOM type video track was provided without Content Hint!\");\n                track.contentHint = \"motion\";\n                break;\n\n              case TypeOfVideo_1.TypeOfVideo.CAMERA:\n              case TypeOfVideo_1.TypeOfVideo.IPCAM:\n              default:\n                track.contentHint = \"motion\";\n                break;\n            }\n\n            logger.info(\"Video track Content Hint set: '\".concat(track.contentHint, \"'\"));\n          }\n        }\n\n        _this.initializeVideoReference(mediaStream);\n\n        if (!_this.stream.displayMyRemote()) {\n          // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n          // avoid early 'streamPlaying' event\n          _this.stream.updateMediaStreamInVideos();\n        }\n\n        delete _this.firstVideoElement;\n\n        if (_this.stream.isSendVideo()) {\n          // Has video track\n          _this.getVideoDimensions().then(function (dimensions) {\n            _this.stream.videoDimensions = {\n              width: dimensions.width,\n              height: dimensions.height\n            };\n\n            if (_this.stream.isSendScreen()) {\n              // Set interval to listen for screen resize events\n              _this.screenShareResizeInterval = setInterval(function () {\n                var settings = mediaStream.getVideoTracks()[0].getSettings();\n                var newWidth = settings.width;\n                var newHeight = settings.height;\n                var widthChanged = newWidth != null && newWidth !== _this.stream.videoDimensions.width;\n                var heightChanged = newHeight != null && newHeight !== _this.stream.videoDimensions.height;\n\n                if (_this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                  _this.openvidu.sendVideoDimensionsChangedEvent(_this, 'screenResized', _this.stream.videoDimensions.width, _this.stream.videoDimensions.height, newWidth || 0, newHeight || 0);\n                }\n              }, 650);\n            }\n\n            _this.stream.isLocalStreamReadyToPublish = true;\n\n            _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n          });\n        } else {\n          // Only audio track (no videoDimensions)\n          _this.stream.isLocalStreamReadyToPublish = true;\n\n          _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n        }\n\n        return resolve();\n      };\n\n      var getMediaSuccess = function getMediaSuccess(mediaStream, definedAudioConstraint) {\n        _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n        if (_this.stream.isSendScreen() && _this.stream.isSendAudio()) {\n          // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n          constraintsAux.audio = definedAudioConstraint;\n          constraintsAux.video = false;\n          startTime = Date.now();\n\n          _this.setPermissionDialogTimer(timeForDialogEvent);\n\n          navigator.mediaDevices.getUserMedia(constraintsAux).then(function (audioOnlyStream) {\n            _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n            mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n            successCallback(mediaStream);\n          }).catch(function (error) {\n            _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n            mediaStream.getAudioTracks().forEach(function (track) {\n              track.stop();\n            });\n            mediaStream.getVideoTracks().forEach(function (track) {\n              track.stop();\n            });\n            errorCallback(_this.openvidu.generateAudioDeviceError(error, constraints));\n            return;\n          });\n        } else {\n          successCallback(mediaStream);\n        }\n      };\n\n      var getMediaError = function getMediaError(error) {\n        logger.error(\"getMediaError: \".concat(error.toString()));\n\n        _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n        if (error.name === 'Error') {\n          // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n          error.name = error.constructor.name;\n        }\n\n        var errorName, errorMessage;\n\n        switch (error.name.toLowerCase()) {\n          case 'notfounderror':\n            navigator.mediaDevices.getUserMedia({\n              audio: false,\n              video: constraints.video\n            }).then(function (mediaStream) {\n              mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n              errorMessage = error.toString();\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            }).catch(function (e) {\n              errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n              errorMessage = error.toString();\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            });\n            break;\n\n          case 'notallowederror':\n            errorName = _this.stream.isSendScreen() ? OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED : OpenViduError_1.OpenViduErrorName.DEVICE_ACCESS_DENIED;\n            errorMessage = error.toString();\n            errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            break;\n\n          case 'overconstrainederror':\n            navigator.mediaDevices.getUserMedia({\n              audio: false,\n              video: constraints.video\n            }).then(function (mediaStream) {\n              mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n\n              if (error.constraint.toLowerCase() === 'deviceid') {\n                errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                errorMessage = \"Audio input device with deviceId '\" + constraints.audio.deviceId.exact + \"' not found\";\n              } else {\n                errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                errorMessage = \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n              }\n\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            }).catch(function (e) {\n              if (error.constraint.toLowerCase() === 'deviceid') {\n                errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                errorMessage = \"Video input device with deviceId '\" + constraints.video.deviceId.exact + \"' not found\";\n              } else {\n                errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                errorMessage = \"Video input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n              }\n\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            });\n            break;\n\n          case 'aborterror':\n          case 'notreadableerror':\n            errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n            errorMessage = error.toString();\n            errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            break;\n\n          default:\n            errorName = OpenViduError_1.OpenViduErrorName.GENERIC_ERROR;\n            errorMessage = error.toString();\n            errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            break;\n        }\n      };\n\n      _this.openvidu.generateMediaConstraints(_this.properties).then(function (myConstraints) {\n        var _a, _b;\n\n        if (!!myConstraints.videoTrack && !!myConstraints.audioTrack || !!myConstraints.audioTrack && ((_a = myConstraints.constraints) === null || _a === void 0 ? void 0 : _a.video) === false || !!myConstraints.videoTrack && ((_b = myConstraints.constraints) === null || _b === void 0 ? void 0 : _b.audio) === false) {\n          // No need to call getUserMedia at all. MediaStreamTracks already provided\n          successCallback(_this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), _this.stream)); // Return as we do not need to process further\n\n          return;\n        }\n\n        constraints = myConstraints.constraints;\n        var outboundStreamOptions = {\n          mediaConstraints: constraints,\n          publisherProperties: _this.properties\n        };\n\n        _this.stream.setOutboundStreamOptions(outboundStreamOptions);\n\n        var definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n        constraintsAux.audio = _this.stream.isSendScreen() ? false : definedAudioConstraint;\n        constraintsAux.video = constraints.video;\n        startTime = Date.now();\n\n        _this.setPermissionDialogTimer(timeForDialogEvent);\n\n        if (_this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron()) {\n          navigator.mediaDevices['getDisplayMedia']({\n            video: true\n          }).then(function (mediaStream) {\n            _this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n\n            getMediaSuccess(mediaStream, definedAudioConstraint);\n          }).catch(function (error) {\n            getMediaError(error);\n          });\n        } else {\n          _this.stream.lastVideoTrackConstraints = constraintsAux.video;\n          navigator.mediaDevices.getUserMedia(constraintsAux).then(function (mediaStream) {\n            _this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, _this.stream);\n\n            getMediaSuccess(mediaStream, definedAudioConstraint);\n          }).catch(function (error) {\n            getMediaError(error);\n          });\n        }\n      }).catch(function (error) {\n        errorCallback(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.replaceTrackAux = function (track, updateLastConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trackOriginalEnabledValue, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            trackOriginalEnabledValue = track.enabled;\n\n            if (track.kind === 'video') {\n              track.enabled = this.stream.videoActive;\n            } else if (track.kind === 'audio') {\n              track.enabled = this.stream.audioActive;\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7,, 8]);\n\n            if (!this.stream.isLocalStreamPublished) return [3\n            /*break*/\n            , 4]; // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n            // If it has not been published yet, replacing it on the MediaStream object is enough\n\n            return [4\n            /*yield*/\n            , this.replaceTrackInMediaStream(track, updateLastConstraints)];\n\n          case 2:\n            // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n            // If it has not been published yet, replacing it on the MediaStream object is enough\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.replaceTrackInRtcRtpSender(track)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            return [4\n            /*yield*/\n            , this.replaceTrackInMediaStream(track, updateLastConstraints)];\n\n          case 5:\n            // Publisher not published. Simply replace the track on the local MediaStream\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            error_2 = _a.sent();\n            track.enabled = trackOriginalEnabledValue;\n            throw error_2;\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   *\n   * To obtain the videoDimensions we wait for the video reference to have enough metadata\n   * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n   * use the HTMLVideoElement properties videoWidth and videoHeight\n   */\n\n\n  Publisher.prototype.getVideoDimensions = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n      var requiresDomInsertion = platform.isIonicIos() || platform.isIOSWithSafari();\n      var loadedmetadataListener;\n\n      var resolveDimensions = function resolveDimensions() {\n        var width;\n        var height;\n\n        if (typeof _this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n          var settings = _this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n\n          width = settings.width || _this.videoReference.videoWidth;\n          height = settings.height || _this.videoReference.videoHeight;\n        } else {\n          logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n          width = _this.videoReference.videoWidth;\n          height = _this.videoReference.videoHeight;\n        }\n\n        if (loadedmetadataListener != null) {\n          _this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n        }\n\n        if (requiresDomInsertion) {\n          document.body.removeChild(_this.videoReference);\n        }\n\n        return resolve({\n          width: width,\n          height: height\n        });\n      };\n\n      if (_this.videoReference.readyState >= 1) {\n        // The video already has metadata available\n        // No need of loadedmetadata event\n        resolveDimensions();\n      } else {\n        // The video does not have metadata available yet\n        // Must listen to loadedmetadata event\n        loadedmetadataListener = function loadedmetadataListener() {\n          if (!_this.videoReference.videoWidth) {\n            var interval_1 = setInterval(function () {\n              if (!!_this.videoReference.videoWidth) {\n                clearInterval(interval_1);\n                resolveDimensions();\n              }\n            }, 40);\n          } else {\n            resolveDimensions();\n          }\n        };\n\n        _this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n\n        if (requiresDomInsertion) {\n          document.body.appendChild(_this.videoReference);\n        }\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.reestablishStreamPlayingEvent = function () {\n    if (this.ee.getListeners('streamPlaying').length > 0) {\n      this.addPlayEventToFirstVideo();\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.initializeVideoReference = function (mediaStream) {\n    this.videoReference = document.createElement('video');\n    this.videoReference.setAttribute('muted', 'true');\n    this.videoReference.style.display = 'none';\n\n    if (platform.isSafariBrowser() || platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser())) {\n      this.videoReference.setAttribute('playsinline', 'true');\n    }\n\n    this.stream.setMediaStream(mediaStream);\n\n    if (!!this.firstVideoElement) {\n      this.createVideoElement(this.firstVideoElement.targetElement, this.properties.insertMode);\n    }\n\n    this.videoReference.srcObject = mediaStream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.replaceTrackInMediaStream = function (track, updateLastConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mediaStream, removedTrack;\n      return __generator(this, function (_a) {\n        mediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n\n        if (track.kind === 'video') {\n          removedTrack = mediaStream.getVideoTracks()[0];\n\n          if (updateLastConstraints) {\n            this.stream.lastVideoTrackConstraints = track.getConstraints();\n          }\n        } else {\n          removedTrack = mediaStream.getAudioTracks()[0];\n        }\n\n        mediaStream.removeTrack(removedTrack);\n        removedTrack.stop();\n        mediaStream.addTrack(track);\n\n        if (track.kind === 'video' && this.stream.isLocalStreamPublished && updateLastConstraints) {\n          this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n          this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /* Private methods */\n\n\n  Publisher.prototype.setPermissionDialogTimer = function (waitTime) {\n    var _this = this;\n\n    this.permissionDialogTimeout = setTimeout(function () {\n      _this.emitEvent('accessDialogOpened', []);\n    }, waitTime);\n  };\n\n  Publisher.prototype.clearPermissionDialogTimer = function (startTime, waitTime) {\n    clearTimeout(this.permissionDialogTimeout);\n\n    if (Date.now() - startTime > waitTime) {\n      // Permission dialog was shown and now is closed\n      this.emitEvent('accessDialogClosed', []);\n    }\n  };\n\n  Publisher.prototype.replaceTrackInRtcRtpSender = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      var senders, sender;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            senders = this.stream.getRTCPeerConnection().getSenders();\n\n            if (track.kind === 'video') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'video';\n              });\n\n              if (!sender) {\n                throw new Error('There\\'s no replaceable track for that kind of MediaStreamTrack in this Publisher object');\n              }\n            } else if (track.kind === 'audio') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'audio';\n              });\n\n              if (!sender) {\n                throw new Error('There\\'s no replaceable track for that kind of MediaStreamTrack in this Publisher object');\n              }\n            } else {\n              throw new Error('Unknown track kind ' + track.kind);\n            }\n\n            return [4\n            /*yield*/\n            , sender.replaceTrack(track)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Publisher;\n}(StreamManager_1.StreamManager);\n\nexports.Publisher = Publisher;","map":null,"metadata":{},"sourceType":"script"}
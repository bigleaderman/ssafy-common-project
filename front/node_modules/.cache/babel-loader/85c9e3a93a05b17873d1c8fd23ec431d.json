{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\"; //슬라이스를 생성하려면 슬라이스를 식별하기 위한\n//문자열 이름, 초기 상태 값, 상태 업데이트 방법을 정의하는 하나 이상의 리듀서 함수가 필요합니다.\n//슬라이스가 생성되면 생성된 Redux 액션 생성자와\n//전체 슬라이스에 대한 리듀서 기능을 내보낼 수 있습니다.\n//Redux는 데이터 복사본을 만들고 복사본을 업데이트하여\n//모든 상태 업데이트를 변경 불가능하게 작성하도록 요구합니다.\n//그러나 Redux Toolkit의 createSlice 및 createReducer API는 Immer 내부를 사용하여\n//올바른 변경 불가능한 업데이트가 되는 \"변경\" 업데이트 로직을 작성할 수 있도록 합니다.\n\nexport var counterSlice = createSlice({\n  name: \"counter\",\n  initialState: {\n    value: 0\n  },\n  reducers: {\n    increment: function increment(state) {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: function decrement(state) {\n      state.value -= 1;\n    },\n    incrementByAmount: function incrementByAmount(state, action) {\n      state.value += action.payload;\n    }\n  }\n});\nvar _counterSlice$actions = counterSlice.actions,\n    increment = _counterSlice$actions.increment,\n    decrement = _counterSlice$actions.decrement,\n    incrementByAmount = _counterSlice$actions.incrementByAmount; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched\n\nexport { increment, decrement, incrementByAmount };\nexport var incrementAsync = function incrementAsync(amount) {\n  return function (dispatch) {\n    setTimeout(function () {\n      dispatch(incrementByAmount(amount));\n    }, 1000);\n  };\n}; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state) => state.counter.value)`\n\nexport var selectCount = function selectCount(state) {\n  return state.counter.value;\n};\nexport default counterSlice.reducer;","map":{"version":3,"names":["createSlice","counterSlice","name","initialState","value","reducers","increment","state","decrement","incrementByAmount","action","payload","actions","incrementAsync","amount","dispatch","setTimeout","selectCount","counter","reducer"],"sources":["C:/SSAFY/2nd semester/S07P12D106/front/src/components/example/counterSlice.js"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\r\n\r\n//슬라이스를 생성하려면 슬라이스를 식별하기 위한\r\n//문자열 이름, 초기 상태 값, 상태 업데이트 방법을 정의하는 하나 이상의 리듀서 함수가 필요합니다.\r\n//슬라이스가 생성되면 생성된 Redux 액션 생성자와\r\n//전체 슬라이스에 대한 리듀서 기능을 내보낼 수 있습니다.\r\n\r\n//Redux는 데이터 복사본을 만들고 복사본을 업데이트하여\r\n//모든 상태 업데이트를 변경 불가능하게 작성하도록 요구합니다.\r\n//그러나 Redux Toolkit의 createSlice 및 createReducer API는 Immer 내부를 사용하여\r\n//올바른 변경 불가능한 업데이트가 되는 \"변경\" 업데이트 로직을 작성할 수 있도록 합니다.\r\nexport const counterSlice = createSlice({\r\n    name: \"counter\",\r\n    initialState: {\r\n        value: 0,\r\n    },\r\n    reducers: {\r\n        increment: (state) => {\r\n            // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\r\n            // doesn't actually mutate the state because it uses the immer library,\r\n            // which detects changes to a \"draft state\" and produces a brand new\r\n            // immutable state based off those changes\r\n            state.value += 1;\r\n        },\r\n\r\n        decrement: (state) => {\r\n            state.value -= 1;\r\n        },\r\n\r\n        incrementByAmount: (state, action) => {\r\n            state.value += action.payload;\r\n        },\r\n    },\r\n});\r\n\r\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\r\n\r\n// The function below is called a thunk and allows us to perform async logic. It\r\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\r\n// will call the thunk with the `dispatch` function as the first argument. Async\r\n// code can then be executed and other actions can be dispatched\r\nexport const incrementAsync = (amount) => (dispatch) => {\r\n    setTimeout(() => {\r\n        dispatch(incrementByAmount(amount));\r\n    }, 1000);\r\n};\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice file. For example: `useSelector((state) => state.counter.value)`\r\nexport const selectCount = (state) => state.counter.value;\r\n\r\nexport default counterSlice.reducer;\r\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,kBAA5B,C,CAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,YAAY,GAAGD,WAAW,CAAC;EACpCE,IAAI,EAAE,SAD8B;EAEpCC,YAAY,EAAE;IACVC,KAAK,EAAE;EADG,CAFsB;EAKpCC,QAAQ,EAAE;IACNC,SAAS,EAAE,mBAACC,KAAD,EAAW;MAClB;MACA;MACA;MACA;MACAA,KAAK,CAACH,KAAN,IAAe,CAAf;IACH,CAPK;IASNI,SAAS,EAAE,mBAACD,KAAD,EAAW;MAClBA,KAAK,CAACH,KAAN,IAAe,CAAf;IACH,CAXK;IAaNK,iBAAiB,EAAE,2BAACF,KAAD,EAAQG,MAAR,EAAmB;MAClCH,KAAK,CAACH,KAAN,IAAeM,MAAM,CAACC,OAAtB;IACH;EAfK;AAL0B,CAAD,CAAhC;4BAwBoDV,YAAY,CAACW,O;IAAzDN,S,yBAAAA,S;IAAWE,S,yBAAAA,S;IAAWC,iB,yBAAAA,iB,EAErC;AACA;AACA;AACA;;;AACA,OAAO,IAAMI,cAAc,GAAG,SAAjBA,cAAiB,CAACC,MAAD;EAAA,OAAY,UAACC,QAAD,EAAc;IACpDC,UAAU,CAAC,YAAM;MACbD,QAAQ,CAACN,iBAAiB,CAACK,MAAD,CAAlB,CAAR;IACH,CAFS,EAEP,IAFO,CAAV;EAGH,CAJ6B;AAAA,CAAvB,C,CAMP;AACA;AACA;;AACA,OAAO,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACV,KAAD;EAAA,OAAWA,KAAK,CAACW,OAAN,CAAcd,KAAzB;AAAA,CAApB;AAEP,eAAeH,YAAY,CAACkB,OAA5B"},"metadata":{},"sourceType":"module"}
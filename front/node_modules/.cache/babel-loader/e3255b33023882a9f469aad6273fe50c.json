{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Session = void 0;\n\nvar Connection_1 = require(\"./Connection\");\n\nvar Filter_1 = require(\"./Filter\");\n\nvar Subscriber_1 = require(\"./Subscriber\");\n\nvar EventDispatcher_1 = require(\"./EventDispatcher\");\n\nvar ConnectionEvent_1 = require(\"../OpenViduInternal/Events/ConnectionEvent\");\n\nvar FilterEvent_1 = require(\"../OpenViduInternal/Events/FilterEvent\");\n\nvar RecordingEvent_1 = require(\"../OpenViduInternal/Events/RecordingEvent\");\n\nvar SessionDisconnectedEvent_1 = require(\"../OpenViduInternal/Events/SessionDisconnectedEvent\");\n\nvar SignalEvent_1 = require(\"../OpenViduInternal/Events/SignalEvent\");\n\nvar StreamEvent_1 = require(\"../OpenViduInternal/Events/StreamEvent\");\n\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\n\nvar ConnectionPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/ConnectionPropertyChangedEvent\");\n\nvar NetworkQualityLevelChangedEvent_1 = require(\"../OpenViduInternal/Events/NetworkQualityLevelChangedEvent\");\n\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\n\nvar VideoInsertMode_1 = require(\"../OpenViduInternal/Enums/VideoInsertMode\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n/**\n * @hidden\n */\n\n\nvar semverMajor = require(\"semver/functions/major\");\n/**\n * @hidden\n */\n\n\nvar semverMinor = require(\"semver/functions/minor\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Represents a video call. It can also be seen as a videoconference room where multiple users can connect.\n * Participants who publish their videos to a session can be seen by the rest of users connected to that specific session.\n * Initialized with [[OpenVidu.initSession]] method.\n *\n * See available event listeners at [[SessionEventMap]].\n */\n\nvar Session =\n/** @class */\nfunction (_super) {\n  __extends(Session, _super);\n  /**\n   * @hidden\n   */\n\n\n  function Session(openvidu) {\n    var _this = _super.call(this) || this;\n    /**\n     * Collection of all StreamManagers of this Session ([[Publisher]] and [[Subscriber]])\n     */\n\n\n    _this.streamManagers = []; // This map is only used to avoid race condition between 'joinRoom' response and 'onParticipantPublished' notification\n\n    /**\n     * @hidden\n     */\n\n    _this.remoteStreamsCreated = new Map();\n    /**\n     * @hidden\n     */\n\n    _this.remoteConnections = new Map();\n    platform = Platform_1.PlatformUtils.getInstance();\n    _this.openvidu = openvidu;\n    return _this;\n  }\n  /**\n   * Connects to the session using `token`. Parameter `metadata` allows you to pass extra data to share with other users when\n   * they receive `streamCreated` event. The structure of `metadata` string is up to you (maybe some standardized format\n   * as JSON or XML is a good idea).\n   *\n   * This metadata is not considered secure, as it is generated in the client side. To pass secure data, add it as a parameter in the\n   * token generation operation (through the API REST, openvidu-java-client or openvidu-node-client).\n   *\n   * Only after the returned Promise is successfully resolved [[Session.connection]] object will be available and properly defined.\n   *\n   * #### Events dispatched\n   *\n   * The [[Session]] object of the local participant will first dispatch one or more `connectionCreated` events upon successful termination of this method:\n   * - First one for your own local Connection object, so you can retrieve [[Session.connection]] property.\n   * - Then one for each remote Connection previously connected to the Session, if any. Any other remote user connecting to the Session after you have\n   * successfully connected will also dispatch a `connectionCreated` event when they do so.\n   *\n   * The [[Session]] object of the local participant will also dispatch a `streamCreated` event for each remote active [[Publisher]] that was already streaming\n   * when connecting, just after dispatching all remote `connectionCreated` events.\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `connectionCreated` event.\n   *\n   * See [[ConnectionEvent]] and [[StreamEvent]] to learn more.\n   *\n   * @returns A Promise to which you must subscribe that is resolved if the the connection to the Session was successful and rejected with an Error object if not\n   *\n   */\n\n\n  Session.prototype.connect = function (token, metadata) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.processToken(token);\n\n      if (_this.openvidu.checkSystemRequirements()) {\n        // Early configuration to deactivate automatic subscription to streams\n        _this.options = {\n          sessionId: _this.sessionId,\n          participantId: token,\n          metadata: !!metadata ? _this.stringClientMetadata(metadata) : ''\n        };\n\n        _this.connectAux(token).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      } else {\n        return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.BROWSER_NOT_SUPPORTED, 'Browser ' + platform.getName() + ' (version ' + platform.getVersion() + ') for ' + platform.getFamily() + ' is not supported in OpenVidu'));\n      }\n    });\n  };\n  /**\n   * Leaves the session, destroying all streams and deleting the user as a participant.\n   *\n   * #### Events dispatched\n   *\n   * The [[Session]] object of the local participant will dispatch a `sessionDisconnected` event.\n   * This event will automatically unsubscribe the leaving participant from every Subscriber object of the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)\n   * and also deletes any HTML video element associated to each Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n   * For every video removed, each Subscriber object will dispatch a `videoElementDestroyed` event.\n   * Call `event.preventDefault()` upon event `sessionDisconnected` to avoid this behavior and take care of disposing and cleaning all the Subscriber objects yourself.\n   * See [[SessionDisconnectedEvent]] and [[VideoElementEvent]] to learn more to learn more.\n   *\n   * The [[Publisher]] object of the local participant will dispatch a `streamDestroyed` event if there is a [[Publisher]] object publishing to the session.\n   * This event will automatically stop all media tracks and delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n   * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.\n   * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session (to do so it is a mandatory requirement to call `Session.unpublish()`\n   * or/and `Session.disconnect()` in the previous session). See [[StreamEvent]] and [[VideoElementEvent]] to learn more.\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamDestroyed` event if the disconnected participant was publishing.\n   * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)\n   * and also deletes any HTML video element associated to that Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n   * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.\n   * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object yourself.\n   * See [[StreamEvent]] and [[VideoElementEvent]] to learn more.\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `connectionDestroyed` event in any case. See [[ConnectionEvent]] to learn more.\n   */\n\n\n  Session.prototype.disconnect = function () {\n    this.leave(false, 'disconnect');\n  };\n  /**\n   * Subscribes to a `stream`, adding a new HTML video element to DOM with `subscriberProperties` settings. This method is usually called in the callback of `streamCreated` event.\n   *\n   * #### Events dispatched\n   *\n   * The [[Subscriber]] object will dispatch a `videoElementCreated` event once the HTML video element has been added to DOM (only if you\n   * [let OpenVidu take care of the video players](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)). See [[VideoElementEvent]] to learn more.\n   *\n   * The [[Subscriber]] object will dispatch a `streamPlaying` event once the remote stream starts playing. See [[StreamManagerEvent]] to learn more.\n   *\n   * @param stream Stream object to subscribe to\n   * @param targetElement HTML DOM element (or its `id` attribute) in which the video element of the Subscriber will be inserted (see [[SubscriberProperties.insertMode]]). If *null* or *undefined* no default video will be created for this Subscriber.\n   * You can always call method [[Subscriber.addVideoElement]] or [[Subscriber.createVideoElement]] to manage the video elements on your own (see [Manage video players](/en/stable/cheatsheet/manage-videos) section)\n   * @param completionHandler `error` parameter is null if `subscribe` succeeds, and is defined if it fails.\n   */\n\n\n  Session.prototype.subscribe = function (stream, targetElement, param3, param4) {\n    var properties = {};\n\n    if (!!param3 && typeof param3 !== 'function') {\n      properties = {\n        insertMode: typeof param3.insertMode !== 'undefined' ? typeof param3.insertMode === 'string' ? VideoInsertMode_1.VideoInsertMode[param3.insertMode] : properties.insertMode : VideoInsertMode_1.VideoInsertMode.APPEND,\n        subscribeToAudio: typeof param3.subscribeToAudio !== 'undefined' ? param3.subscribeToAudio : true,\n        subscribeToVideo: typeof param3.subscribeToVideo !== 'undefined' ? param3.subscribeToVideo : true\n      };\n    } else {\n      properties = {\n        insertMode: VideoInsertMode_1.VideoInsertMode.APPEND,\n        subscribeToAudio: true,\n        subscribeToVideo: true\n      };\n    }\n\n    var completionHandler = undefined;\n\n    if (!!param3 && typeof param3 === 'function') {\n      completionHandler = param3;\n    } else if (!!param4) {\n      completionHandler = param4;\n    }\n\n    if (!this.sessionConnected()) {\n      if (completionHandler !== undefined) {\n        completionHandler(this.notConnectedError());\n      }\n\n      throw this.notConnectedError();\n    }\n\n    logger.info('Subscribing to ' + stream.connection.connectionId);\n    stream.subscribe().then(function () {\n      logger.info('Subscribed correctly to ' + stream.connection.connectionId);\n\n      if (completionHandler !== undefined) {\n        completionHandler(undefined);\n      }\n    }).catch(function (error) {\n      if (completionHandler !== undefined) {\n        completionHandler(error);\n      }\n    });\n    var subscriber = new Subscriber_1.Subscriber(stream, targetElement, properties);\n\n    if (!!subscriber.targetElement) {\n      stream.streamManager.createVideoElement(subscriber.targetElement, properties.insertMode);\n    }\n\n    return subscriber;\n  };\n\n  Session.prototype.subscribeAsync = function (stream, targetElement, properties) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        return reject(_this.notConnectedError());\n      }\n\n      var subscriber;\n\n      var callback = function (error) {\n        if (!!error) {\n          return reject(error);\n        } else {\n          return resolve(subscriber);\n        }\n      };\n\n      if (!!properties) {\n        subscriber = _this.subscribe(stream, targetElement, properties, callback);\n      } else {\n        subscriber = _this.subscribe(stream, targetElement, callback);\n      }\n    });\n  };\n  /**\n   * Unsubscribes from `subscriber`, automatically removing its associated HTML video elements.\n   *\n   * #### Events dispatched\n   *\n   * The [[Subscriber]] object will dispatch a `videoElementDestroyed` event for each video associated to it that was removed from DOM.\n   * Only videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)) will be automatically removed\n   *\n   * See [[VideoElementEvent]] to learn more\n   */\n\n\n  Session.prototype.unsubscribe = function (subscriber) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        return reject(_this.notConnectedError());\n      } else {\n        var connectionId_1 = subscriber.stream.connection.connectionId;\n        logger.info('Unsubscribing from ' + connectionId_1);\n\n        _this.openvidu.sendRequest('unsubscribeFromVideo', {\n          sender: subscriber.stream.connection.connectionId\n        }, function (error, response) {\n          if (error) {\n            logger.error('Error unsubscribing from ' + connectionId_1);\n            return reject(error);\n          } else {\n            logger.info('Unsubscribed correctly from ' + connectionId_1);\n            subscriber.stream.streamManager.removeAllVideos();\n            subscriber.stream.disposeWebRtcPeer();\n            subscriber.stream.disposeMediaStream();\n            return resolve();\n          }\n        });\n      }\n    });\n  };\n  /**\n   * Publishes to the Session the Publisher object\n   *\n   * #### Events dispatched\n   *\n   * The local [[Publisher]] object will dispatch a `streamCreated` event upon successful termination of this method. See [[StreamEvent]] to learn more.\n   *\n   * The local [[Publisher]] object will dispatch a `streamPlaying` once the media stream starts playing. See [[StreamManagerEvent]] to learn more.\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamCreated` event so they can subscribe to it. See [[StreamEvent]] to learn more.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the publisher was successfully published and rejected with an Error object if not\n   */\n\n\n  Session.prototype.publish = function (publisher) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        return reject(_this.notConnectedError());\n      }\n\n      publisher.session = _this;\n      publisher.stream.session = _this;\n\n      if (!publisher.stream.publishedOnce) {\n        // 'Session.unpublish(Publisher)' has NOT been called\n        _this.connection.addStream(publisher.stream);\n\n        publisher.stream.publish().then(function () {\n          _this.sendVideoData(publisher, 8, true, 5);\n\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      } else {\n        // 'Session.unpublish(Publisher)' has been called. Must initialize again Publisher\n        publisher.initialize().then(function () {\n          _this.connection.addStream(publisher.stream);\n\n          publisher.reestablishStreamPlayingEvent();\n          publisher.stream.publish().then(function () {\n            _this.sendVideoData(publisher, 8, true, 5);\n\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        }).catch(function (error) {\n          return reject(error);\n        });\n      }\n    });\n  };\n  /**\n   * Unpublishes from the Session the Publisher object.\n   *\n   * #### Events dispatched\n   *\n   * The [[Publisher]] object of the local participant will dispatch a `streamDestroyed` event.\n   * This event will automatically stop all media tracks and delete any HTML video element associated to this Publisher\n   * (only those videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n   * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.\n   * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session.\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamDestroyed` event.\n   * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks) and\n   * delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n   * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.\n   * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object on your own.\n   *\n   * See [[StreamEvent]] and [[VideoElementEvent]] to learn more.\n   */\n\n\n  Session.prototype.unpublish = function (publisher) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        throw _this.notConnectedError();\n      }\n\n      var stream = publisher.stream;\n\n      if (!stream.connection) {\n        return reject(new Error('The associated Connection object of this Publisher is null'));\n      } else if (stream.connection !== _this.connection) {\n        return reject(new Error('The associated Connection object of this Publisher is not your local Connection.' + \"Only moderators can force unpublish on remote Streams via 'forceUnpublish' method\"));\n      } else {\n        logger.info('Unpublishing local media (' + stream.connection.connectionId + ')');\n\n        _this.openvidu.sendRequest('unpublishVideo', function (error, response) {\n          if (error) {\n            return reject(error);\n          } else {\n            logger.info('Media unpublished correctly');\n            stream.disposeWebRtcPeer();\n\n            if (stream.connection.stream == stream) {\n              // The Connection.stream may have changed if Session.publish was called with other Publisher\n              delete stream.connection.stream;\n            }\n\n            var streamEvent = new StreamEvent_1.StreamEvent(true, publisher, 'streamDestroyed', publisher.stream, 'unpublish');\n            publisher.emitEvent('streamDestroyed', [streamEvent]);\n            streamEvent.callDefaultBehavior();\n            return resolve();\n          }\n        });\n      }\n    });\n  };\n  /**\n   * Forces some user to leave the session\n   *\n   * #### Events dispatched\n   *\n   * The behavior is the same as when some user calls [[Session.disconnect]], but `reason` property in all events will be `\"forceDisconnectByUser\"`.\n   *\n   * The [[Session]] object of every participant will dispatch a `streamDestroyed` event if the evicted user was publishing a stream, with property `reason` set to `\"forceDisconnectByUser\"`.\n   * The [[Session]] object of every participant except the evicted one will dispatch a `connectionDestroyed` event for the evicted user, with property `reason` set to `\"forceDisconnectByUser\"`.\n   *\n   * If any, the [[Publisher]] object of the evicted participant will also dispatch a `streamDestroyed` event with property `reason` set to `\"forceDisconnectByUser\"`.\n   * The [[Session]] object of the evicted participant will dispatch a `sessionDisconnected` event with property `reason` set to `\"forceDisconnectByUser\"`.\n   *\n   * See [[StreamEvent]], [[ConnectionEvent]] and [[SessionDisconnectedEvent]] to learn more.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the participant has been successfully evicted from the session and rejected with an Error object if not\n   */\n\n\n  Session.prototype.forceDisconnect = function (connection) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        return reject(_this.notConnectedError());\n      }\n\n      logger.info('Forcing disconnect for connection ' + connection.connectionId);\n\n      _this.openvidu.sendRequest('forceDisconnect', {\n        connectionId: connection.connectionId\n      }, function (error, response) {\n        if (error) {\n          logger.error('Error forcing disconnect for Connection ' + connection.connectionId, error);\n\n          if (error.code === 401) {\n            return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to force a disconnection\"));\n          } else {\n            return reject(error);\n          }\n        } else {\n          logger.info('Forcing disconnect correctly for Connection ' + connection.connectionId);\n          return resolve();\n        }\n      });\n    });\n  };\n  /**\n   * Forces some user to unpublish a Stream\n   *\n   * #### Events dispatched\n   *\n   * The behavior is the same as when some user calls [[Session.unpublish]], but `reason` property in all events will be `\"forceUnpublishByUser\"`\n   *\n   * The [[Session]] object of every participant will dispatch a `streamDestroyed` event with property `reason` set to `\"forceDisconnectByUser\"`\n   *\n   * The [[Publisher]] object of the affected participant will also dispatch a `streamDestroyed` event with property `reason` set to `\"forceDisconnectByUser\"`\n   *\n   * See [[StreamEvent]] to learn more.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the remote Stream has been successfully unpublished from the session and rejected with an Error object if not\n   */\n\n\n  Session.prototype.forceUnpublish = function (stream) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        return reject(_this.notConnectedError());\n      }\n\n      logger.info('Forcing unpublish for stream ' + stream.streamId);\n\n      _this.openvidu.sendRequest('forceUnpublish', {\n        streamId: stream.streamId\n      }, function (error, response) {\n        if (error) {\n          logger.error('Error forcing unpublish for Stream ' + stream.streamId, error);\n\n          if (error.code === 401) {\n            return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to force an unpublishing\"));\n          } else {\n            return reject(error);\n          }\n        } else {\n          logger.info('Forcing unpublish correctly for Stream ' + stream.streamId);\n          return resolve();\n        }\n      });\n    });\n  };\n  /**\n   * Sends one signal. `signal` object has the following optional properties:\n   * ```json\n   * {data:string, to:Connection[], type:string}\n   * ```\n   * All users subscribed to that signal (`session.on('signal:type', ...)` or `session.on('signal', ...)` for all signals) and whose Connection objects are in `to` array will receive it. Their local\n   * Session objects will dispatch a `signal` or `signal:type` event. See [[SignalEvent]] to learn more.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the message successfully reached openvidu-server and rejected with an Error object if not. _This doesn't\n   * mean that openvidu-server could resend the message to all the listed receivers._\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  Session.prototype.signal = function (signal) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.sessionConnected()) {\n        return reject(_this.notConnectedError());\n      }\n\n      var signalMessage = {};\n\n      if (signal.to && signal.to.length > 0) {\n        var connectionIds_1 = [];\n        signal.to.forEach(function (connection) {\n          if (!!connection.connectionId) {\n            connectionIds_1.push(connection.connectionId);\n          }\n        });\n        signalMessage['to'] = connectionIds_1;\n      } else {\n        signalMessage['to'] = [];\n      }\n\n      signalMessage['data'] = signal.data ? signal.data : '';\n      var typeAux = signal.type ? signal.type : 'signal';\n\n      if (!!typeAux) {\n        if (typeAux.substring(0, 7) !== 'signal:') {\n          typeAux = 'signal:' + typeAux;\n        }\n      }\n\n      signalMessage['type'] = typeAux;\n\n      _this.openvidu.sendRequest('sendMessage', {\n        message: JSON.stringify(signalMessage)\n      }, function (error, response) {\n        if (!!error) {\n          return reject(error);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  };\n  /* tslint:enable:no-string-literal */\n\n  /**\n   * See [[EventDispatcher.on]]\n   */\n\n\n  Session.prototype.on = function (type, handler) {\n    var _a, _b, _c, _d;\n\n    _super.prototype.onAux.call(this, type, \"Event '\" + type + \"' triggered by 'Session'\", handler);\n\n    if (type === 'publisherStartSpeaking') {\n      // If there are already available remote streams with audio, enable hark 'speaking' event in all of them\n      this.remoteConnections.forEach(function (remoteConnection) {\n        var _a;\n\n        if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {\n          remoteConnection.stream.enableHarkSpeakingEvent();\n        }\n      });\n\n      if (!!((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.hasAudio)) {\n        // If connected to the Session and publishing with audio, also enable hark 'speaking' event for the Publisher\n        this.connection.stream.enableHarkSpeakingEvent();\n      }\n    }\n\n    if (type === 'publisherStopSpeaking') {\n      // If there are already available remote streams with audio, enable hark 'stopped_speaking' event in all of them\n      this.remoteConnections.forEach(function (remoteConnection) {\n        var _a;\n\n        if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {\n          remoteConnection.stream.enableHarkStoppedSpeakingEvent();\n        }\n      });\n\n      if (!!((_d = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.stream) === null || _d === void 0 ? void 0 : _d.hasAudio)) {\n        // If connected to the Session and publishing with audio, also enable hark 'stopped_speaking' event for the Publisher\n        this.connection.stream.enableHarkStoppedSpeakingEvent();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.once]]\n   */\n\n\n  Session.prototype.once = function (type, handler) {\n    var _a, _b, _c, _d;\n\n    _super.prototype.onceAux.call(this, type, \"Event '\" + type + \"' triggered once by 'Session'\", handler);\n\n    if (type === 'publisherStartSpeaking') {\n      // If there are already available remote streams with audio, enable hark 'speaking' event (once) in all of them once\n      this.remoteConnections.forEach(function (remoteConnection) {\n        var _a;\n\n        if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {\n          remoteConnection.stream.enableOnceHarkSpeakingEvent();\n        }\n      });\n\n      if (!!((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.hasAudio)) {\n        // If connected to the Session and publishing with audio, also enable hark 'speaking' event (once) for the Publisher\n        this.connection.stream.enableOnceHarkSpeakingEvent();\n      }\n    }\n\n    if (type === 'publisherStopSpeaking') {\n      // If there are already available remote streams with audio, enable hark 'stopped_speaking' event (once) in all of them once\n      this.remoteConnections.forEach(function (remoteConnection) {\n        var _a;\n\n        if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {\n          remoteConnection.stream.enableOnceHarkStoppedSpeakingEvent();\n        }\n      });\n\n      if (!!((_d = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.stream) === null || _d === void 0 ? void 0 : _d.hasAudio)) {\n        // If connected to the Session and publishing with audio, also enable hark 'stopped_speaking' event (once) for the Publisher\n        this.connection.stream.enableOnceHarkStoppedSpeakingEvent();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.off]]\n   */\n\n\n  Session.prototype.off = function (type, handler) {\n    var _this = this;\n\n    var _a, _b, _c, _d;\n\n    _super.prototype.offAux.call(this, type, handler);\n\n    if (type === 'publisherStartSpeaking') {\n      // Check if Session object still has some listener for the event\n      if (!this.anySpeechEventListenerEnabled('publisherStartSpeaking', false)) {\n        this.remoteConnections.forEach(function (remoteConnection) {\n          var _a;\n\n          if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.streamManager)) {\n            // Check if Subscriber object still has some listener for the event\n            if (!_this.anySpeechEventListenerEnabled('publisherStartSpeaking', false, remoteConnection.stream.streamManager)) {\n              remoteConnection.stream.disableHarkSpeakingEvent(false);\n            }\n          }\n        });\n\n        if (!!((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.streamManager)) {\n          // Check if Publisher object still has some listener for the event\n          if (!this.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.connection.stream.streamManager)) {\n            this.connection.stream.disableHarkSpeakingEvent(false);\n          }\n        }\n      }\n    }\n\n    if (type === 'publisherStopSpeaking') {\n      // Check if Session object still has some listener for the event\n      if (!this.anySpeechEventListenerEnabled('publisherStopSpeaking', false)) {\n        this.remoteConnections.forEach(function (remoteConnection) {\n          var _a;\n\n          if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.streamManager)) {\n            // Check if Subscriber object still has some listener for the event\n            if (!_this.anySpeechEventListenerEnabled('publisherStopSpeaking', false, remoteConnection.stream.streamManager)) {\n              remoteConnection.stream.disableHarkStoppedSpeakingEvent(false);\n            }\n          }\n        });\n\n        if (!!((_d = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.stream) === null || _d === void 0 ? void 0 : _d.streamManager)) {\n          // Check if Publisher object still has some listener for the event\n          if (!this.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.connection.stream.streamManager)) {\n            this.connection.stream.disableHarkStoppedSpeakingEvent(false);\n          }\n        }\n      }\n    }\n\n    return this;\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onParticipantJoined = function (event) {\n    var _this = this; // Connection shouldn't exist\n\n\n    this.getConnection(event.id, '').then(function (connection) {\n      logger.warn('Connection ' + connection.connectionId + ' already exists in connections list');\n    }).catch(function (openViduError) {\n      var connection = new Connection_1.Connection(_this, event);\n\n      _this.remoteConnections.set(event.id, connection);\n\n      _this.ee.emitEvent('connectionCreated', [new ConnectionEvent_1.ConnectionEvent(false, _this, 'connectionCreated', connection, '')]);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onParticipantLeft = function (event) {\n    var _this = this;\n\n    this.getRemoteConnection(event.connectionId, 'onParticipantLeft').then(function (connection) {\n      if (!!connection.stream) {\n        var stream = connection.stream;\n        var streamEvent = new StreamEvent_1.StreamEvent(true, _this, 'streamDestroyed', stream, event.reason);\n\n        _this.ee.emitEvent('streamDestroyed', [streamEvent]);\n\n        streamEvent.callDefaultBehavior();\n\n        _this.remoteStreamsCreated.delete(stream.streamId);\n      }\n\n      _this.remoteConnections.delete(connection.connectionId);\n\n      _this.ee.emitEvent('connectionDestroyed', [new ConnectionEvent_1.ConnectionEvent(false, _this, 'connectionDestroyed', connection, event.reason)]);\n    }).catch(function (openViduError) {\n      logger.error(openViduError);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onParticipantPublished = function (event) {\n    var _this = this;\n\n    var afterConnectionFound = function (connection) {\n      _this.remoteConnections.set(connection.connectionId, connection);\n\n      if (!_this.remoteStreamsCreated.get(connection.stream.streamId)) {\n        // Avoid race condition between stream.subscribe() in \"onParticipantPublished\" and in \"joinRoom\" rpc callback\n        // This condition is false if openvidu-server sends \"participantPublished\" event to a subscriber participant that has\n        // already subscribed to certain stream in the callback of \"joinRoom\" method\n        _this.ee.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', connection.stream, '')]);\n      }\n\n      _this.remoteStreamsCreated.set(connection.stream.streamId, true);\n    }; // Get the existing Connection created on 'onParticipantJoined' for\n    // existing participants or create a new one for new participants\n\n\n    var connection;\n    this.getRemoteConnection(event.id, 'onParticipantPublished').then(function (con) {\n      // Update existing Connection\n      connection = con;\n      event.metadata = con.data;\n      connection.remoteOptions = event;\n      connection.initRemoteStreams(event.streams);\n      afterConnectionFound(connection);\n    }).catch(function (openViduError) {\n      // Create new Connection\n      connection = new Connection_1.Connection(_this, event);\n      afterConnectionFound(connection);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onParticipantUnpublished = function (event) {\n    var _this = this;\n\n    if (event.connectionId === this.connection.connectionId) {\n      // Your stream has been forcedly unpublished from the session\n      this.stopPublisherStream(event.reason);\n    } else {\n      this.getRemoteConnection(event.connectionId, 'onParticipantUnpublished').then(function (connection) {\n        var streamEvent = new StreamEvent_1.StreamEvent(true, _this, 'streamDestroyed', connection.stream, event.reason);\n\n        _this.ee.emitEvent('streamDestroyed', [streamEvent]);\n\n        streamEvent.callDefaultBehavior(); // Deleting the remote stream\n\n        var streamId = connection.stream.streamId;\n\n        _this.remoteStreamsCreated.delete(streamId);\n\n        connection.removeStream(streamId);\n      }).catch(function (openViduError) {\n        logger.error(openViduError);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onParticipantEvicted = function (event) {\n    if (event.connectionId === this.connection.connectionId) {\n      // You have been evicted from the session\n      if (!!this.sessionId && !this.connection.disposed) {\n        this.leave(true, event.reason);\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onNewMessage = function (event) {\n    var _this = this;\n\n    logger.info('New signal: ' + JSON.stringify(event));\n    var strippedType = !!event.type ? event.type.replace(/^(signal:)/, '') : undefined;\n\n    if (!!event.from) {\n      // Signal sent by other client\n      this.getConnection(event.from, \"Connection '\" + event.from + \"' unknown when 'onNewMessage'. Existing remote connections: \" + JSON.stringify(this.remoteConnections.keys()) + '. Existing local connection: ' + this.connection.connectionId).then(function (connection) {\n        _this.ee.emitEvent('signal', [new SignalEvent_1.SignalEvent(_this, strippedType, event.data, connection)]);\n\n        if (!!event.type && event.type !== 'signal') {\n          _this.ee.emitEvent(event.type, [new SignalEvent_1.SignalEvent(_this, strippedType, event.data, connection)]);\n        }\n      }).catch(function (openViduError) {\n        logger.error(openViduError);\n      });\n    } else {\n      // Signal sent by server\n      this.ee.emitEvent('signal', [new SignalEvent_1.SignalEvent(this, strippedType, event.data, undefined)]);\n\n      if (!!event.type && event.type !== 'signal') {\n        this.ee.emitEvent(event.type, [new SignalEvent_1.SignalEvent(this, strippedType, event.data, undefined)]);\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onStreamPropertyChanged = function (event) {\n    var _this = this;\n\n    var callback = function (connection) {\n      if (!!connection.stream && connection.stream.streamId === event.streamId) {\n        var stream = connection.stream;\n        var oldValue = void 0;\n\n        switch (event.property) {\n          case 'audioActive':\n            oldValue = stream.audioActive;\n            event.newValue = event.newValue === 'true';\n            stream.audioActive = event.newValue;\n            break;\n\n          case 'videoActive':\n            oldValue = stream.videoActive;\n            event.newValue = event.newValue === 'true';\n            stream.videoActive = event.newValue;\n            break;\n\n          case 'videoDimensions':\n            oldValue = stream.videoDimensions;\n            event.newValue = JSON.parse(JSON.parse(event.newValue));\n            stream.videoDimensions = event.newValue;\n            break;\n\n          case 'filter':\n            oldValue = stream.filter;\n            event.newValue = Object.keys(event.newValue).length > 0 ? event.newValue : undefined;\n\n            if (event.newValue !== undefined) {\n              stream.filter = new Filter_1.Filter(event.newValue.type, event.newValue.options);\n              stream.filter.stream = stream;\n\n              if (event.newValue.lastExecMethod) {\n                stream.filter.lastExecMethod = event.newValue.lastExecMethod;\n              }\n            } else {\n              delete stream.filter;\n            }\n\n            event.newValue = stream.filter;\n            break;\n        }\n\n        _this.ee.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, stream, event.property, event.newValue, oldValue, event.reason)]);\n\n        if (!!stream.streamManager) {\n          stream.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(stream.streamManager, stream, event.property, event.newValue, oldValue, event.reason)]);\n        }\n      } else {\n        logger.error(\"No stream with streamId '\" + event.streamId + \"' found for connection '\" + event.connectionId + \"' on 'streamPropertyChanged' event\");\n      }\n    };\n\n    if (event.connectionId === this.connection.connectionId) {\n      // Your stream has been forcedly changed (filter feature)\n      callback(this.connection);\n    } else {\n      this.getRemoteConnection(event.connectionId, 'onStreamPropertyChanged').then(function (connection) {\n        callback(connection);\n      }).catch(function (openViduError) {\n        logger.error(openViduError);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onConnectionPropertyChanged = function (event) {\n    var oldValue;\n\n    switch (event.property) {\n      case 'role':\n        oldValue = this.connection.role.slice();\n        this.connection.role = event.newValue;\n        this.connection.localOptions.role = event.newValue;\n        break;\n\n      case 'record':\n        oldValue = this.connection.record;\n        event.newValue = event.newValue === 'true';\n        this.connection.record = event.newValue;\n        this.connection.localOptions.record = event.newValue;\n        break;\n    }\n\n    this.ee.emitEvent('connectionPropertyChanged', [new ConnectionPropertyChangedEvent_1.ConnectionPropertyChangedEvent(this, this.connection, event.property, event.newValue, oldValue)]);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onNetworkQualityLevelChangedChanged = function (event) {\n    var _this = this;\n\n    if (event.connectionId === this.connection.connectionId) {\n      this.ee.emitEvent('networkQualityLevelChanged', [new NetworkQualityLevelChangedEvent_1.NetworkQualityLevelChangedEvent(this, event.newValue, event.oldValue, this.connection)]);\n    } else {\n      this.getConnection(event.connectionId, 'Connection not found for connectionId ' + event.connectionId).then(function (connection) {\n        _this.ee.emitEvent('networkQualityLevelChanged', [new NetworkQualityLevelChangedEvent_1.NetworkQualityLevelChangedEvent(_this, event.newValue, event.oldValue, connection)]);\n      }).catch(function (openViduError) {\n        logger.error(openViduError);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.recvIceCandidate = function (event) {\n    // The event contains fields that can be used to obtain a proper candidate,\n    // using the RTCIceCandidate constructor:\n    // https://w3c.github.io/webrtc-pc/#dom-rtcicecandidate-constructor\n    var candidateInit = {\n      candidate: event.candidate,\n      sdpMLineIndex: event.sdpMLineIndex,\n      sdpMid: event.sdpMid\n    };\n    var iceCandidate = new RTCIceCandidate(candidateInit);\n    this.getConnection(event.senderConnectionId, 'Connection not found for connectionId ' + event.senderConnectionId + ' owning endpoint ' + event.endpointName + '. Ice candidate will be ignored: ' + iceCandidate).then(function (connection) {\n      var stream = connection.stream;\n      stream.getWebRtcPeer().addIceCandidate(iceCandidate).catch(function (error) {\n        logger.error('Error adding candidate for ' + stream.streamId + ' stream of endpoint ' + event.endpointName + ': ' + error);\n      });\n    }).catch(function (openViduError) {\n      logger.error(openViduError);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onSessionClosed = function (msg) {\n    logger.info('Session closed: ' + JSON.stringify(msg));\n    var s = msg.sessionId;\n\n    if (s !== undefined) {\n      this.ee.emitEvent('session-closed', [{\n        session: s\n      }]);\n    } else {\n      logger.warn('Session undefined on session closed', msg);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onLostConnection = function (reason) {\n    logger.warn('Lost connection in Session ' + this.sessionId);\n\n    if (!!this.sessionId && !!this.connection && !this.connection.disposed) {\n      this.leave(true, reason);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onRecoveredConnection = function () {\n    logger.info('Recovered connection in Session ' + this.sessionId);\n    this.reconnectBrokenStreams();\n    this.ee.emitEvent('reconnected', []);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onMediaError = function (event) {\n    logger.error('Media error: ' + JSON.stringify(event));\n    var err = event.error;\n\n    if (err) {\n      this.ee.emitEvent('error-media', [{\n        error: err\n      }]);\n    } else {\n      logger.warn('Received undefined media error:', event);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onRecordingStarted = function (event) {\n    this.ee.emitEvent('recordingStarted', [new RecordingEvent_1.RecordingEvent(this, 'recordingStarted', event.id, event.name)]);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onRecordingStopped = function (event) {\n    this.ee.emitEvent('recordingStopped', [new RecordingEvent_1.RecordingEvent(this, 'recordingStopped', event.id, event.name, event.reason)]);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onFilterEventDispatched = function (event) {\n    var _this = this;\n\n    var connectionId = event.connectionId;\n    this.getConnection(connectionId, 'No connection found for connectionId ' + connectionId).then(function (connection) {\n      logger.info(\"Filter event of type \\\"\".concat(event.eventType, \"\\\" dispatched\"));\n      var stream = connection.stream;\n\n      if (!stream || !stream.filter) {\n        return logger.error(\"Filter event of type \\\"\".concat(event.eventType, \"\\\" dispatched for stream \").concat(stream.streamId, \" but there is no \").concat(!stream ? 'stream' : 'filter', \" defined\"));\n      }\n\n      var eventHandler = stream.filter.handlers.get(event.eventType);\n\n      if (!eventHandler || typeof eventHandler !== 'function') {\n        var actualHandlers = Array.from(stream.filter.handlers.keys());\n        return logger.error(\"Filter event of type \\\"\".concat(event.eventType, \"\\\" not handled or not a function! Active filter events: \").concat(actualHandlers.join(',')));\n      } else {\n        eventHandler.call(_this, new FilterEvent_1.FilterEvent(stream.filter, event.eventType, event.data));\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.onForciblyReconnectSubscriber = function (event) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.getRemoteConnection(event.connectionId, 'onForciblyReconnectSubscriber').then(function (connection) {\n        if (!!connection.stream && connection.stream.streamId === event.streamId) {\n          var stream_1 = connection.stream;\n\n          if (stream_1.setupReconnectionEventEmitter(resolve, reject)) {\n            // Ongoing reconnection\n            // Wait for the event emitter to be free (with success or error) and call the method again\n            if (stream_1.reconnectionEventEmitter['onForciblyReconnectSubscriberLastEvent'] != null) {\n              // Two or more onForciblyReconnectSubscriber events were received while a reconnection process\n              // of the subscriber was already taking place. Always use the last one to retry the re-subscription\n              // process, as that SDP offer will be the only one available at the server side. Ignore previous ones\n              stream_1.reconnectionEventEmitter['onForciblyReconnectSubscriberLastEvent'] = event;\n              return reject('Ongoing forced subscriber reconnection');\n            } else {\n              // One onForciblyReconnectSubscriber even has been received while a reconnection process\n              // of the subscriber was already taking place. Set up a listener to wait for it to retry the\n              // forced reconnection process\n              stream_1.reconnectionEventEmitter['onForciblyReconnectSubscriberLastEvent'] = event;\n\n              var callback_1 = function () {\n                var eventAux = stream_1.reconnectionEventEmitter['onForciblyReconnectSubscriberLastEvent'];\n                delete stream_1.reconnectionEventEmitter['onForciblyReconnectSubscriberLastEvent'];\n\n                _this.onForciblyReconnectSubscriber(eventAux);\n              };\n\n              stream_1.reconnectionEventEmitter.once('success', function () {\n                callback_1();\n              });\n              stream_1.reconnectionEventEmitter.once('error', function () {\n                callback_1();\n              });\n            }\n\n            return;\n          }\n\n          stream_1.completeWebRtcPeerReceive(true, true, event.sdpOffer).then(function () {\n            return stream_1.finalResolveForSubscription(true, resolve);\n          }).catch(function (error) {\n            return stream_1.finalRejectForSubscription(true, \"Error while forcibly reconnecting remote stream \".concat(event.streamId, \": \").concat(error.toString()), reject);\n          });\n        } else {\n          var errMsg = \"No stream with streamId '\" + event.streamId + \"' found for connection '\" + event.connectionId + \"' on 'streamPropertyChanged' event\";\n          logger.error(errMsg);\n          return reject(errMsg);\n        }\n      }).catch(function (openViduError) {\n        logger.error(openViduError);\n        return reject(openViduError);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.reconnectBrokenStreams = function () {\n    logger.info('Re-establishing media connections...');\n    var someReconnection = false; // Re-establish Publisher stream\n\n    if (!!this.connection.stream && this.connection.stream.streamIceConnectionStateBroken()) {\n      logger.warn('Re-establishing Publisher ' + this.connection.stream.streamId);\n      this.connection.stream.initWebRtcPeerSend(true);\n      someReconnection = true;\n    } // Re-establish Subscriber streams\n\n\n    this.remoteConnections.forEach(function (remoteConnection) {\n      if (!!remoteConnection.stream && remoteConnection.stream.streamIceConnectionStateBroken()) {\n        logger.warn('Re-establishing Subscriber ' + remoteConnection.stream.streamId);\n        remoteConnection.stream.initWebRtcPeerReceive(true);\n        someReconnection = true;\n      }\n    });\n\n    if (!someReconnection) {\n      logger.info('There were no media streams in need of a reconnection');\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.emitEvent = function (type, eventArray) {\n    this.ee.emitEvent(type, eventArray);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.leave = function (forced, reason) {\n    var _this = this;\n\n    forced = !!forced;\n    logger.info('Leaving Session (forced=' + forced + ')');\n    this.stopVideoDataIntervals();\n\n    if (!!this.connection) {\n      if (!this.connection.disposed && !forced) {\n        this.openvidu.sendRequest('leaveRoom', function (error, response) {\n          if (error) {\n            logger.error(\"leaveRoom error: \".concat(JSON.stringify(error)));\n          }\n\n          _this.openvidu.closeWs();\n        });\n      } else {\n        this.openvidu.closeWs();\n      }\n\n      this.stopPublisherStream(reason);\n\n      if (!this.connection.disposed) {\n        // Make Session object dispatch 'sessionDisconnected' event (if it is not already disposed)\n        var sessionDisconnectEvent = new SessionDisconnectedEvent_1.SessionDisconnectedEvent(this, reason);\n        this.ee.emitEvent('sessionDisconnected', [sessionDisconnectEvent]);\n        sessionDisconnectEvent.callDefaultBehavior();\n      }\n    } else {\n      logger.warn('You were not connected to the session ' + this.sessionId);\n    }\n\n    logger.flush();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.initializeParams = function (token) {\n    var joinParams = {\n      token: !!token ? token : '',\n      session: this.sessionId,\n      platform: !!platform.getDescription() ? platform.getDescription() : 'unknown',\n      sdkVersion: this.openvidu.libraryVersion,\n      metadata: !!this.options.metadata ? this.options.metadata : '',\n      secret: this.openvidu.getSecret(),\n      recorder: this.openvidu.getRecorder()\n    };\n    return joinParams;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.sendVideoData = function (streamManager, intervalSeconds, doInterval, maxLoops) {\n    var _this = this;\n\n    var _a, _b;\n\n    if (intervalSeconds === void 0) {\n      intervalSeconds = 1;\n    }\n\n    if (doInterval === void 0) {\n      doInterval = false;\n    }\n\n    if (maxLoops === void 0) {\n      maxLoops = 1;\n    }\n\n    if (platform.isChromeBrowser() || platform.isChromeMobileBrowser() || platform.isOperaBrowser() || platform.isOperaMobileBrowser() || platform.isEdgeBrowser() || platform.isEdgeMobileBrowser() || platform.isElectron() || platform.isSafariBrowser() && !platform.isIonicIos() || platform.isAndroidBrowser() || platform.isSamsungBrowser() || platform.isIonicAndroid() || platform.isIOSWithSafari()) {\n      var obtainAndSendVideo_1 = function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var pc, statsMap, arr_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                pc = streamManager.stream.getRTCPeerConnection();\n                if (!(pc.connectionState === 'connected')) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , pc.getStats()];\n\n              case 1:\n                statsMap = _a.sent();\n                arr_1 = [];\n                statsMap.forEach(function (stats) {\n                  if (\"frameWidth\" in stats && \"frameHeight\" in stats && arr_1.length === 0) {\n                    arr_1.push(stats);\n                  }\n                });\n\n                if (arr_1.length > 0) {\n                  this.openvidu.sendRequest('videoData', {\n                    height: arr_1[0].frameHeight,\n                    width: arr_1[0].frameWidth,\n                    videoActive: streamManager.stream.videoActive != null ? streamManager.stream.videoActive : false,\n                    audioActive: streamManager.stream.audioActive != null ? streamManager.stream.audioActive : false\n                  }, function (error, response) {\n                    if (error) {\n                      logger.error(\"Error sending 'videoData' event\", error);\n                    }\n                  });\n                }\n\n                _a.label = 2;\n\n              case 2:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n\n      if (doInterval) {\n        var loops_1 = 1;\n        this.videoDataInterval = setInterval(function () {\n          if (loops_1 < maxLoops) {\n            loops_1++;\n            obtainAndSendVideo_1();\n          } else {\n            clearInterval(_this.videoDataInterval);\n          }\n        }, intervalSeconds * 1000);\n      } else {\n        this.videoDataTimeout = setTimeout(obtainAndSendVideo_1, intervalSeconds * 1000);\n      }\n    } else if (platform.isFirefoxBrowser() || platform.isFirefoxMobileBrowser() || platform.isIonicIos() || platform.isReactNative()) {\n      // Basic version for Firefox and Ionic iOS. They do not support stats\n      this.openvidu.sendRequest('videoData', {\n        height: ((_a = streamManager.stream.videoDimensions) === null || _a === void 0 ? void 0 : _a.height) || 0,\n        width: ((_b = streamManager.stream.videoDimensions) === null || _b === void 0 ? void 0 : _b.width) || 0,\n        videoActive: streamManager.stream.videoActive != null ? streamManager.stream.videoActive : false,\n        audioActive: streamManager.stream.audioActive != null ? streamManager.stream.audioActive : false\n      }, function (error, response) {\n        if (error) {\n          logger.error(\"Error sending 'videoData' event\", error);\n        }\n      });\n    } else {\n      logger.error('Browser ' + platform.getName() + ' (version ' + platform.getVersion() + ') for ' + platform.getFamily() + ' is not supported in OpenVidu for Network Quality');\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.sessionConnected = function () {\n    return this.connection != null;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.notConnectedError = function () {\n    return new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_NOT_CONNECTED, \"There is no connection to the session. Method 'Session.connect' must be successfully completed first\");\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.anySpeechEventListenerEnabled = function (event, onlyOnce, streamManager) {\n    var handlersInSession = this.ee.getListeners(event);\n\n    if (onlyOnce) {\n      handlersInSession = handlersInSession.filter(function (h) {\n        return h.once;\n      });\n    }\n\n    var listenersInSession = handlersInSession.length;\n    if (listenersInSession > 0) return true;\n    var listenersInStreamManager = 0;\n\n    if (!!streamManager) {\n      var handlersInStreamManager = streamManager.ee.getListeners(event);\n\n      if (onlyOnce) {\n        handlersInStreamManager = handlersInStreamManager.filter(function (h) {\n          return h.once;\n        });\n      }\n\n      listenersInStreamManager = handlersInStreamManager.length;\n    }\n\n    return listenersInStreamManager > 0;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Session.prototype.getTokenParams = function (token) {\n    var match = token.match(/^(wss?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)([\\/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/);\n\n    if (!!match) {\n      var url = {\n        protocol: match[1],\n        host: match[2],\n        hostname: match[3],\n        port: match[4],\n        pathname: match[5],\n        search: match[6],\n        hash: match[7]\n      };\n      var params = token.split('?');\n      var queryParams = decodeURI(params[1]).split('&').map(function (param) {\n        return param.split('=');\n      }).reduce(function (values, _a) {\n        var key = _a[0],\n            value = _a[1];\n        values[key] = value;\n        return values;\n      }, {});\n      return {\n        sessionId: queryParams['sessionId'],\n        secret: queryParams['secret'],\n        recorder: queryParams['recorder'],\n        webrtcStatsInterval: queryParams['webrtcStatsInterval'],\n        sendBrowserLogs: queryParams['sendBrowserLogs'],\n        edition: queryParams['edition'],\n        wsUri: 'wss://' + url.host + '/openvidu',\n        httpUri: 'https://' + url.host\n      };\n    } else {\n      throw new Error(\"Token not valid: \\\"\".concat(token, \"\\\"\"));\n    }\n  };\n  /* Private methods */\n\n\n  Session.prototype.connectAux = function (token) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.openvidu.startWs(function (error) {\n        if (!!error) {\n          return reject(error);\n        } else {\n          var joinParams = _this.initializeParams(token);\n\n          _this.openvidu.sendRequest('joinRoom', joinParams, function (error, response) {\n            if (!!error) {\n              return reject(error);\n            } else {\n              // Process join room response\n              _this.processJoinRoomResponse(response, token); // Initialize local Connection object with values returned by openvidu-server\n\n\n              _this.connection = new Connection_1.Connection(_this, response); // Initialize remote Connections with value returned by openvidu-server\n\n              var events_1 = {\n                connections: new Array(),\n                streams: new Array()\n              };\n              var existingParticipants = response.value;\n              existingParticipants.forEach(function (remoteConnectionOptions) {\n                var connection = new Connection_1.Connection(_this, remoteConnectionOptions);\n\n                _this.remoteConnections.set(connection.connectionId, connection);\n\n                events_1.connections.push(connection);\n\n                if (!!connection.stream) {\n                  _this.remoteStreamsCreated.set(connection.stream.streamId, true);\n\n                  events_1.streams.push(connection.stream);\n                }\n              }); // Own 'connectionCreated' event\n\n              _this.ee.emitEvent('connectionCreated', [new ConnectionEvent_1.ConnectionEvent(false, _this, 'connectionCreated', _this.connection, '')]); // One 'connectionCreated' event for each existing connection in the session\n\n\n              events_1.connections.forEach(function (connection) {\n                _this.ee.emitEvent('connectionCreated', [new ConnectionEvent_1.ConnectionEvent(false, _this, 'connectionCreated', connection, '')]);\n              }); // One 'streamCreated' event for each active stream in the session\n\n              events_1.streams.forEach(function (stream) {\n                _this.ee.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', stream, '')]);\n              });\n              return resolve();\n            }\n          });\n        }\n      });\n    });\n  };\n\n  Session.prototype.stopPublisherStream = function (reason) {\n    if (!!this.connection.stream) {\n      // Dispose Publisher's  local stream\n      this.connection.stream.disposeWebRtcPeer();\n\n      if (this.connection.stream.isLocalStreamPublished) {\n        // Make Publisher object dispatch 'streamDestroyed' event if the Stream was published\n        this.connection.stream.ee.emitEvent('local-stream-destroyed', [reason]);\n      }\n    }\n  };\n\n  Session.prototype.stopVideoDataIntervals = function () {\n    clearInterval(this.videoDataInterval);\n    clearTimeout(this.videoDataTimeout);\n  };\n\n  Session.prototype.stringClientMetadata = function (metadata) {\n    if (typeof metadata !== 'string') {\n      return JSON.stringify(metadata);\n    } else {\n      return metadata;\n    }\n  };\n\n  Session.prototype.getConnection = function (connectionId, errorMessage) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var connection = _this.remoteConnections.get(connectionId);\n\n      if (!!connection) {\n        // Resolve remote connection\n        return resolve(connection);\n      } else {\n        if (_this.connection.connectionId === connectionId) {\n          // Resolve local connection\n          return resolve(_this.connection);\n        } else {\n          // Connection not found. Reject with OpenViduError\n          return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, errorMessage));\n        }\n      }\n    });\n  };\n\n  Session.prototype.getRemoteConnection = function (connectionId, operation) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var connection = _this.remoteConnections.get(connectionId);\n\n      if (!!connection) {\n        // Resolve remote connection\n        return resolve(connection);\n      } else {\n        // Remote connection not found. Reject with OpenViduError\n        var errorMessage = 'Remote connection ' + connectionId + \" unknown when '\" + operation + \"'. \" + 'Existing remote connections: ' + JSON.stringify(_this.remoteConnections.keys());\n        return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, errorMessage));\n      }\n    });\n  };\n\n  Session.prototype.processToken = function (token) {\n    var tokenParams = this.getTokenParams(token);\n    this.sessionId = tokenParams.sessionId;\n\n    if (!!tokenParams.secret) {\n      this.openvidu.secret = tokenParams.secret;\n    }\n\n    if (!!tokenParams.recorder) {\n      this.openvidu.recorder = true;\n    }\n\n    if (!!tokenParams.webrtcStatsInterval) {\n      this.openvidu.webrtcStatsInterval = tokenParams.webrtcStatsInterval;\n    }\n\n    if (!!tokenParams.sendBrowserLogs) {\n      this.openvidu.sendBrowserLogs = tokenParams.sendBrowserLogs;\n    }\n\n    this.openvidu.isAtLeastPro = tokenParams.edition === 'pro' || tokenParams.edition === 'enterprise';\n    this.openvidu.isEnterprise = tokenParams.edition === 'enterprise';\n    this.openvidu.wsUri = tokenParams.wsUri;\n    this.openvidu.httpUri = tokenParams.httpUri;\n  };\n\n  Session.prototype.processJoinRoomResponse = function (opts, token) {\n    this.sessionId = opts.session;\n\n    if (opts.customIceServers != null && opts.customIceServers.length > 0) {\n      this.openvidu.iceServers = [];\n\n      for (var _i = 0, _a = opts.customIceServers; _i < _a.length; _i++) {\n        var iceServer = _a[_i];\n        var rtcIceServer = {\n          urls: [iceServer.url]\n        };\n        logger.log(\"STUN/TURN server IP: \" + iceServer.url);\n\n        if (iceServer.username != null && iceServer.credential != null) {\n          rtcIceServer.username = iceServer.username;\n          rtcIceServer.credential = iceServer.credential;\n          logger.log('TURN credentials [' + iceServer.username + ':' + iceServer.credential + ']');\n        }\n\n        this.openvidu.iceServers.push(rtcIceServer);\n      }\n    } else if (opts.coturnIp != null && opts.coturnPort != null && opts.turnUsername != null && opts.turnCredential != null) {\n      var turnUrl1 = 'turn:' + opts.coturnIp + ':' + opts.coturnPort;\n      this.openvidu.iceServers = [{\n        urls: [turnUrl1],\n        username: opts.turnUsername,\n        credential: opts.turnCredential\n      }];\n      logger.log(\"STUN/TURN server IP: \" + opts.coturnIp);\n      logger.log('TURN temp credentials [' + opts.turnUsername + ':' + opts.turnCredential + ']');\n    }\n\n    this.openvidu.role = opts.role;\n    this.openvidu.finalUserId = opts.finalUserId;\n    this.openvidu.mediaServer = opts.mediaServer;\n    this.openvidu.videoSimulcast = opts.videoSimulcast;\n    this.capabilities = {\n      subscribe: true,\n      publish: this.openvidu.role !== 'SUBSCRIBER',\n      forceUnpublish: this.openvidu.role === 'MODERATOR',\n      forceDisconnect: this.openvidu.role === 'MODERATOR'\n    };\n    logger.info(\"openvidu-server version: \" + opts.version);\n\n    if (opts.life != null) {\n      this.openvidu.life = opts.life;\n    }\n\n    var minorDifference = semverMinor(opts.version) - semverMinor(this.openvidu.libraryVersion);\n\n    if (semverMajor(opts.version) !== semverMajor(this.openvidu.libraryVersion) || !(minorDifference == 0 || minorDifference == 1)) {\n      logger.error(\"openvidu-browser (\".concat(this.openvidu.libraryVersion, \") and openvidu-server (\").concat(opts.version, \") versions are incompatible. \") + 'Errors are likely to occur. openvidu-browser SDK is only compatible with the same version or the immediately following minor version of an OpenVidu deployment');\n    } else if (minorDifference == 1) {\n      logger.warn(\"openvidu-browser version \".concat(this.openvidu.libraryVersion, \" does not match openvidu-server version \").concat(opts.version, \". \") + \"These versions are still compatible with each other, but openvidu-browser version must be updated as soon as possible to \".concat(semverMajor(opts.version), \".\").concat(semverMinor(opts.version), \".x. \") + \"This client using openvidu-browser \".concat(this.openvidu.libraryVersion, \" will become incompatible with the next release of openvidu-server\"));\n    } // Configure JSNLogs\n\n\n    OpenViduLogger_1.OpenViduLogger.configureJSNLog(this.openvidu, token); // Store token\n\n    this.token = token;\n  };\n\n  return Session;\n}(EventDispatcher_1.EventDispatcher);\n\nexports.Session = Session;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","__extends","openvidu","_super","_this","Map","Platform_1","Session","token","metadata","Promise","resolve","reject","processToken","checkSystemRequirements","options","sessionId","participantId","stringClientMetadata","connectAux","then","catch","error","OpenViduError_1","BROWSER_NOT_SUPPORTED","getName","getVersion","getFamily","leave","stream","targetElement","param3","param4","properties","insertMode","VideoInsertMode_1","APPEND","subscribeToAudio","subscribeToVideo","completionHandler","undefined","sessionConnected","notConnectedError","info","connection","connectionId","subscribe","subscriber","Subscriber_1","streamManager","createVideoElement","callback","connectionId_1","sendRequest","sender","response","removeAllVideos","disposeWebRtcPeer","disposeMediaStream","publisher","session","publishedOnce","addStream","publish","sendVideoData","initialize","reestablishStreamPlayingEvent","Error","streamEvent","StreamEvent_1","emitEvent","callDefaultBehavior","code","OPENVIDU_PERMISSION_DENIED","streamId","signal","signalMessage","to","length","connectionIds_1","forEach","push","data","typeAux","type","substring","message","JSON","stringify","handler","onAux","call","remoteConnections","_a","hasAudio","remoteConnection","enableHarkSpeakingEvent","_b","enableHarkStoppedSpeakingEvent","_c","_d","onceAux","enableOnceHarkSpeakingEvent","enableOnceHarkStoppedSpeakingEvent","offAux","anySpeechEventListenerEnabled","disableHarkSpeakingEvent","disableHarkStoppedSpeakingEvent","event","getConnection","id","warn","Connection_1","set","ee","ConnectionEvent_1","getRemoteConnection","reason","remoteStreamsCreated","delete","openViduError","afterConnectionFound","get","con","remoteOptions","initRemoteStreams","streams","stopPublisherStream","removeStream","disposed","strippedType","replace","from","keys","SignalEvent_1","oldValue","property","audioActive","newValue","videoActive","videoDimensions","parse","filter","Object","Filter_1","lastExecMethod","StreamPropertyChangedEvent_1","role","slice","localOptions","record","ConnectionPropertyChangedEvent_1","NetworkQualityLevelChangedEvent_1","candidateInit","candidate","sdpMLineIndex","sdpMid","iceCandidate","RTCIceCandidate","senderConnectionId","endpointName","getWebRtcPeer","addIceCandidate","msg","s","reconnectBrokenStreams","err","RecordingEvent_1","name","eventType","concat","eventHandler","handlers","actualHandlers","Array","join","FilterEvent_1","stream_1","setupReconnectionEventEmitter","reconnectionEventEmitter","callback_1","eventAux","onForciblyReconnectSubscriber","once","completeWebRtcPeerReceive","sdpOffer","finalResolveForSubscription","finalRejectForSubscription","toString","errMsg","someReconnection","streamIceConnectionStateBroken","initWebRtcPeerSend","initWebRtcPeerReceive","eventArray","forced","stopVideoDataIntervals","closeWs","sessionDisconnectEvent","SessionDisconnectedEvent_1","flush","joinParams","getDescription","sdkVersion","libraryVersion","secret","getSecret","recorder","getRecorder","intervalSeconds","doInterval","maxLoops","isChromeBrowser","isChromeMobileBrowser","isOperaBrowser","isOperaMobileBrowser","isEdgeBrowser","isEdgeMobileBrowser","isElectron","isSafariBrowser","isIonicIos","isAndroidBrowser","isSamsungBrowser","isIonicAndroid","isIOSWithSafari","obtainAndSendVideo_1","pc","getRTCPeerConnection","connectionState","getStats","statsMap","arr_1","stats","height","frameHeight","width","frameWidth","loops_1","videoDataInterval","setInterval","clearInterval","videoDataTimeout","setTimeout","isFirefoxBrowser","isFirefoxMobileBrowser","isReactNative","OPENVIDU_NOT_CONNECTED","onlyOnce","handlersInSession","getListeners","h","listenersInSession","listenersInStreamManager","handlersInStreamManager","match","url","protocol","host","hostname","port","pathname","search","hash","params","split","queryParams","decodeURI","map","reduce","values","key","value","webrtcStatsInterval","sendBrowserLogs","edition","wsUri","httpUri","startWs","initializeParams","processJoinRoomResponse","events_1","connections","existingParticipants","remoteConnectionOptions","isLocalStreamPublished","clearTimeout","errorMessage","GENERIC_ERROR","operation","tokenParams","getTokenParams","isAtLeastPro","isEnterprise","opts","customIceServers","iceServers","_i","iceServer","rtcIceServer","urls","log","username","credential","coturnIp","coturnPort","turnUsername","turnCredential","turnUrl1","finalUserId","mediaServer","videoSimulcast","capabilities","forceUnpublish","forceDisconnect","version","life","minorDifference","semverMinor","semverMajor","configureJSNLog","EventDispatcher_1","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenVidu\\Session.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Connection } from './Connection';\nimport { Filter } from './Filter';\nimport { OpenVidu } from './OpenVidu';\nimport { Publisher } from './Publisher';\nimport { Stream } from './Stream';\nimport { StreamManager } from './StreamManager';\nimport { Subscriber } from './Subscriber';\nimport { Capabilities } from '../OpenViduInternal/Interfaces/Public/Capabilities';\nimport { EventDispatcher } from './EventDispatcher';\nimport { SignalOptions } from '../OpenViduInternal/Interfaces/Public/SignalOptions';\nimport { SubscriberProperties } from '../OpenViduInternal/Interfaces/Public/SubscriberProperties';\nimport { RemoteConnectionOptions } from '../OpenViduInternal/Interfaces/Private/RemoteConnectionOptions';\nimport { LocalConnectionOptions } from '../OpenViduInternal/Interfaces/Private/LocalConnectionOptions';\nimport { SessionOptions } from '../OpenViduInternal/Interfaces/Private/SessionOptions';\nimport { SessionEventMap } from '../OpenViduInternal/Events/EventMap/SessionEventMap';\nimport { ConnectionEvent } from '../OpenViduInternal/Events/ConnectionEvent';\nimport { FilterEvent } from '../OpenViduInternal/Events/FilterEvent';\nimport { RecordingEvent } from '../OpenViduInternal/Events/RecordingEvent';\nimport { SessionDisconnectedEvent } from '../OpenViduInternal/Events/SessionDisconnectedEvent';\nimport { SignalEvent } from '../OpenViduInternal/Events/SignalEvent';\nimport { StreamEvent } from '../OpenViduInternal/Events/StreamEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { ConnectionPropertyChangedEvent } from '../OpenViduInternal/Events/ConnectionPropertyChangedEvent';\nimport { NetworkQualityLevelChangedEvent } from '../OpenViduInternal/Events/NetworkQualityLevelChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { VideoInsertMode } from '../OpenViduInternal/Enums/VideoInsertMode';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\n/**\n * @hidden\n */\nimport semverMajor = require('semver/functions/major');\n/**\n * @hidden\n */\nimport semverMinor = require('semver/functions/minor');\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Represents a video call. It can also be seen as a videoconference room where multiple users can connect.\n * Participants who publish their videos to a session can be seen by the rest of users connected to that specific session.\n * Initialized with [[OpenVidu.initSession]] method.\n *\n * See available event listeners at [[SessionEventMap]].\n */\nexport class Session extends EventDispatcher {\n\n    /**\n     * Local connection to the Session. This object is defined only after [[Session.connect]] has been successfully executed, and can be retrieved subscribing to `connectionCreated` event\n     */\n    connection: Connection;\n\n    /**\n     * Unique identifier of the Session\n     */\n    sessionId: string;\n\n    /**\n     * Collection of all StreamManagers of this Session ([[Publisher]] and [[Subscriber]])\n     */\n    streamManagers: StreamManager[] = [];\n\n    /**\n     * Object defining the methods that the client is able to call. These are defined by the [[Connection.role]].\n     * This object is only defined after [[Session.connect]] has been successfully resolved\n     */\n    capabilities: Capabilities;\n\n    // This map is only used to avoid race condition between 'joinRoom' response and 'onParticipantPublished' notification\n    /**\n     * @hidden\n     */\n    remoteStreamsCreated: Map<string, boolean> = new Map();\n\n    /**\n     * @hidden\n     */\n    remoteConnections: Map<string, Connection> = new Map();\n    /**\n     * @hidden\n     */\n    openvidu: OpenVidu;\n    /**\n     * @hidden\n     */\n    options: SessionOptions;\n    /**\n     * @hidden\n     */\n    token: string;\n    /**\n     * @hidden\n     */\n    private videoDataInterval: NodeJS.Timeout;\n    /**\n     * @hidden\n     */\n    private videoDataTimeout: NodeJS.Timeout;\n\n    /**\n     * @hidden\n     */\n    constructor(openvidu: OpenVidu) {\n        super();\n        platform = PlatformUtils.getInstance();\n        this.openvidu = openvidu;\n    }\n\n    connect(token: string): Promise<any>;\n    connect(token: string, metadata: any): Promise<any>;\n\n    /**\n     * Connects to the session using `token`. Parameter `metadata` allows you to pass extra data to share with other users when\n     * they receive `streamCreated` event. The structure of `metadata` string is up to you (maybe some standardized format\n     * as JSON or XML is a good idea).\n     *\n     * This metadata is not considered secure, as it is generated in the client side. To pass secure data, add it as a parameter in the\n     * token generation operation (through the API REST, openvidu-java-client or openvidu-node-client).\n     *\n     * Only after the returned Promise is successfully resolved [[Session.connection]] object will be available and properly defined.\n     *\n     * #### Events dispatched\n     *\n     * The [[Session]] object of the local participant will first dispatch one or more `connectionCreated` events upon successful termination of this method:\n     * - First one for your own local Connection object, so you can retrieve [[Session.connection]] property.\n     * - Then one for each remote Connection previously connected to the Session, if any. Any other remote user connecting to the Session after you have\n     * successfully connected will also dispatch a `connectionCreated` event when they do so.\n     *\n     * The [[Session]] object of the local participant will also dispatch a `streamCreated` event for each remote active [[Publisher]] that was already streaming\n     * when connecting, just after dispatching all remote `connectionCreated` events.\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `connectionCreated` event.\n     *\n     * See [[ConnectionEvent]] and [[StreamEvent]] to learn more.\n     *\n     * @returns A Promise to which you must subscribe that is resolved if the the connection to the Session was successful and rejected with an Error object if not\n     *\n     */\n    connect(token: string, metadata?: any): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            this.processToken(token);\n\n            if (this.openvidu.checkSystemRequirements()) {\n                // Early configuration to deactivate automatic subscription to streams\n                this.options = {\n                    sessionId: this.sessionId,\n                    participantId: token,\n                    metadata: !!metadata ? this.stringClientMetadata(metadata) : ''\n                };\n                this.connectAux(token)\n                    .then(() => resolve())\n                    .catch(error => reject(error));\n            } else {\n                return reject(new OpenViduError(OpenViduErrorName.BROWSER_NOT_SUPPORTED, 'Browser ' + platform.getName() + ' (version ' + platform.getVersion() + ') for ' + platform.getFamily() + ' is not supported in OpenVidu'));\n            }\n        });\n    }\n\n    /**\n     * Leaves the session, destroying all streams and deleting the user as a participant.\n     *\n     * #### Events dispatched\n     *\n     * The [[Session]] object of the local participant will dispatch a `sessionDisconnected` event.\n     * This event will automatically unsubscribe the leaving participant from every Subscriber object of the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)\n     * and also deletes any HTML video element associated to each Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n     * For every video removed, each Subscriber object will dispatch a `videoElementDestroyed` event.\n     * Call `event.preventDefault()` upon event `sessionDisconnected` to avoid this behavior and take care of disposing and cleaning all the Subscriber objects yourself.\n     * See [[SessionDisconnectedEvent]] and [[VideoElementEvent]] to learn more to learn more.\n     *\n     * The [[Publisher]] object of the local participant will dispatch a `streamDestroyed` event if there is a [[Publisher]] object publishing to the session.\n     * This event will automatically stop all media tracks and delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n     * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.\n     * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session (to do so it is a mandatory requirement to call `Session.unpublish()`\n     * or/and `Session.disconnect()` in the previous session). See [[StreamEvent]] and [[VideoElementEvent]] to learn more.\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `streamDestroyed` event if the disconnected participant was publishing.\n     * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)\n     * and also deletes any HTML video element associated to that Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n     * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.\n     * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object yourself.\n     * See [[StreamEvent]] and [[VideoElementEvent]] to learn more.\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `connectionDestroyed` event in any case. See [[ConnectionEvent]] to learn more.\n     */\n    disconnect(): void {\n        this.leave(false, 'disconnect');\n    }\n\n    subscribe(stream: Stream, targetElement: string | HTMLElement): Subscriber;\n    subscribe(stream: Stream, targetElement: string | HTMLElement, properties: SubscriberProperties): Subscriber;\n    subscribe(stream: Stream, targetElement: string | HTMLElement, completionHandler: (error: Error | undefined) => void): Subscriber;\n    subscribe(stream: Stream, targetElement: string | HTMLElement, properties: SubscriberProperties, completionHandler: (error: Error | undefined) => void): Subscriber;\n\n    /**\n     * Subscribes to a `stream`, adding a new HTML video element to DOM with `subscriberProperties` settings. This method is usually called in the callback of `streamCreated` event.\n     *\n     * #### Events dispatched\n     *\n     * The [[Subscriber]] object will dispatch a `videoElementCreated` event once the HTML video element has been added to DOM (only if you\n     * [let OpenVidu take care of the video players](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)). See [[VideoElementEvent]] to learn more.\n     *\n     * The [[Subscriber]] object will dispatch a `streamPlaying` event once the remote stream starts playing. See [[StreamManagerEvent]] to learn more.\n     *\n     * @param stream Stream object to subscribe to\n     * @param targetElement HTML DOM element (or its `id` attribute) in which the video element of the Subscriber will be inserted (see [[SubscriberProperties.insertMode]]). If *null* or *undefined* no default video will be created for this Subscriber.\n     * You can always call method [[Subscriber.addVideoElement]] or [[Subscriber.createVideoElement]] to manage the video elements on your own (see [Manage video players](/en/stable/cheatsheet/manage-videos) section)\n     * @param completionHandler `error` parameter is null if `subscribe` succeeds, and is defined if it fails.\n     */\n    subscribe(stream: Stream, targetElement: string | HTMLElement, param3?: ((error: Error | undefined) => void) | SubscriberProperties, param4?: ((error: Error | undefined) => void)): Subscriber {\n        let properties: SubscriberProperties = {};\n        if (!!param3 && typeof param3 !== 'function') {\n            properties = {\n                insertMode: (typeof param3.insertMode !== 'undefined') ? ((typeof param3.insertMode === 'string') ? VideoInsertMode[param3.insertMode] : properties.insertMode) : VideoInsertMode.APPEND,\n                subscribeToAudio: (typeof param3.subscribeToAudio !== 'undefined') ? param3.subscribeToAudio : true,\n                subscribeToVideo: (typeof param3.subscribeToVideo !== 'undefined') ? param3.subscribeToVideo : true\n            };\n        } else {\n            properties = {\n                insertMode: VideoInsertMode.APPEND,\n                subscribeToAudio: true,\n                subscribeToVideo: true\n            };\n        }\n\n        let completionHandler: ((error: Error | undefined) => void) | undefined = undefined;\n        if (!!param3 && (typeof param3 === 'function')) {\n            completionHandler = param3;\n        } else if (!!param4) {\n            completionHandler = param4;\n        }\n\n        if (!this.sessionConnected()) {\n            if (completionHandler !== undefined) {\n                completionHandler(this.notConnectedError());\n            }\n            throw this.notConnectedError();\n        }\n\n        logger.info('Subscribing to ' + stream.connection.connectionId);\n\n        stream.subscribe()\n            .then(() => {\n                logger.info('Subscribed correctly to ' + stream.connection.connectionId);\n                if (completionHandler !== undefined) {\n                    completionHandler(undefined);\n                }\n            })\n            .catch(error => {\n                if (completionHandler !== undefined) {\n                    completionHandler(error);\n                }\n            });\n        const subscriber = new Subscriber(stream, targetElement, properties);\n        if (!!subscriber.targetElement) {\n            stream.streamManager.createVideoElement(subscriber.targetElement, <VideoInsertMode>properties.insertMode);\n        }\n        return subscriber;\n    }\n\n\n    /**\n     * Promisified version of [[Session.subscribe]]\n     */\n    subscribeAsync(stream: Stream, targetElement: string | HTMLElement): Promise<Subscriber>;\n    subscribeAsync(stream: Stream, targetElement: string | HTMLElement, properties: SubscriberProperties): Promise<Subscriber>;\n\n    subscribeAsync(stream: Stream, targetElement: string | HTMLElement, properties?: SubscriberProperties): Promise<Subscriber> {\n        return new Promise<Subscriber>((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                return reject(this.notConnectedError());\n            }\n\n            let subscriber: Subscriber;\n\n            const callback = (error: Error) => {\n                if (!!error) {\n                    return reject(error);\n                } else {\n                    return resolve(subscriber);\n                }\n            };\n\n            if (!!properties) {\n                subscriber = this.subscribe(stream, targetElement, properties, callback);\n            } else {\n                subscriber = this.subscribe(stream, targetElement, callback);\n            }\n\n        });\n    }\n\n\n    /**\n     * Unsubscribes from `subscriber`, automatically removing its associated HTML video elements.\n     *\n     * #### Events dispatched\n     *\n     * The [[Subscriber]] object will dispatch a `videoElementDestroyed` event for each video associated to it that was removed from DOM.\n     * Only videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)) will be automatically removed\n     *\n     * See [[VideoElementEvent]] to learn more\n     */\n    unsubscribe(subscriber: Subscriber): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                return reject(this.notConnectedError());\n            } else {\n                const connectionId = subscriber.stream.connection.connectionId;\n\n                logger.info('Unsubscribing from ' + connectionId);\n\n                this.openvidu.sendRequest(\n                    'unsubscribeFromVideo',\n                    { sender: subscriber.stream.connection.connectionId },\n                    (error, response) => {\n                        if (error) {\n                            logger.error('Error unsubscribing from ' + connectionId);\n                            return reject(error);\n                        } else {\n                            logger.info('Unsubscribed correctly from ' + connectionId);\n                            subscriber.stream.streamManager.removeAllVideos();\n                            subscriber.stream.disposeWebRtcPeer();\n                            subscriber.stream.disposeMediaStream();\n                            return resolve();\n                        }\n                    }\n                );\n            }\n        });\n    }\n\n\n    /**\n     * Publishes to the Session the Publisher object\n     *\n     * #### Events dispatched\n     *\n     * The local [[Publisher]] object will dispatch a `streamCreated` event upon successful termination of this method. See [[StreamEvent]] to learn more.\n     *\n     * The local [[Publisher]] object will dispatch a `streamPlaying` once the media stream starts playing. See [[StreamManagerEvent]] to learn more.\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `streamCreated` event so they can subscribe to it. See [[StreamEvent]] to learn more.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the publisher was successfully published and rejected with an Error object if not\n     */\n    publish(publisher: Publisher): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                return reject(this.notConnectedError());\n            }\n\n            publisher.session = this;\n            publisher.stream.session = this;\n\n            if (!publisher.stream.publishedOnce) {\n                // 'Session.unpublish(Publisher)' has NOT been called\n                this.connection.addStream(publisher.stream);\n                publisher.stream.publish()\n                    .then(() => {\n                        this.sendVideoData(publisher, 8, true, 5);\n                        return resolve();\n                    })\n                    .catch(error => reject(error));\n            } else {\n                // 'Session.unpublish(Publisher)' has been called. Must initialize again Publisher\n                publisher.initialize()\n                    .then(() => {\n                        this.connection.addStream(publisher.stream);\n                        publisher.reestablishStreamPlayingEvent();\n                        publisher.stream.publish()\n                            .then(() => {\n                                this.sendVideoData(publisher, 8, true, 5);\n                                return resolve();\n                            })\n                            .catch(error => reject(error));\n                    }).catch(error => reject(error));\n            }\n        });\n    }\n\n\n    /**\n     * Unpublishes from the Session the Publisher object.\n     *\n     * #### Events dispatched\n     *\n     * The [[Publisher]] object of the local participant will dispatch a `streamDestroyed` event.\n     * This event will automatically stop all media tracks and delete any HTML video element associated to this Publisher\n     * (only those videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n     * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.\n     * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session.\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `streamDestroyed` event.\n     * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks) and\n     * delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).\n     * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.\n     * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object on your own.\n     *\n     * See [[StreamEvent]] and [[VideoElementEvent]] to learn more.\n     */\n    unpublish(publisher: Publisher): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                throw this.notConnectedError()\n            }\n\n            const stream = publisher.stream;\n\n            if (!stream.connection) {\n                return reject(new Error('The associated Connection object of this Publisher is null'));\n            } else if (stream.connection !== this.connection) {\n                return reject(new Error('The associated Connection object of this Publisher is not your local Connection.' +\n                    \"Only moderators can force unpublish on remote Streams via 'forceUnpublish' method\"));\n            } else {\n\n                logger.info('Unpublishing local media (' + stream.connection.connectionId + ')');\n\n                this.openvidu.sendRequest('unpublishVideo', (error, response) => {\n                    if (error) {\n                        return reject(error);\n                    } else {\n                        logger.info('Media unpublished correctly');\n\n                        stream.disposeWebRtcPeer();\n\n                        if (stream.connection.stream == stream) {\n                            // The Connection.stream may have changed if Session.publish was called with other Publisher\n                            delete stream.connection.stream;\n                        }\n\n                        const streamEvent = new StreamEvent(true, publisher, 'streamDestroyed', publisher.stream, 'unpublish');\n                        publisher.emitEvent('streamDestroyed', [streamEvent]);\n                        streamEvent.callDefaultBehavior();\n\n                        return resolve();\n                    }\n                });\n            }\n        });\n    }\n\n\n    /**\n     * Forces some user to leave the session\n     *\n     * #### Events dispatched\n     *\n     * The behavior is the same as when some user calls [[Session.disconnect]], but `reason` property in all events will be `\"forceDisconnectByUser\"`.\n     *\n     * The [[Session]] object of every participant will dispatch a `streamDestroyed` event if the evicted user was publishing a stream, with property `reason` set to `\"forceDisconnectByUser\"`.\n     * The [[Session]] object of every participant except the evicted one will dispatch a `connectionDestroyed` event for the evicted user, with property `reason` set to `\"forceDisconnectByUser\"`.\n     *\n     * If any, the [[Publisher]] object of the evicted participant will also dispatch a `streamDestroyed` event with property `reason` set to `\"forceDisconnectByUser\"`.\n     * The [[Session]] object of the evicted participant will dispatch a `sessionDisconnected` event with property `reason` set to `\"forceDisconnectByUser\"`.\n     *\n     * See [[StreamEvent]], [[ConnectionEvent]] and [[SessionDisconnectedEvent]] to learn more.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the participant has been successfully evicted from the session and rejected with an Error object if not\n     */\n    forceDisconnect(connection: Connection): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                return reject(this.notConnectedError());\n            }\n\n            logger.info('Forcing disconnect for connection ' + connection.connectionId);\n            this.openvidu.sendRequest(\n                'forceDisconnect',\n                { connectionId: connection.connectionId },\n                (error, response) => {\n                    if (error) {\n                        logger.error('Error forcing disconnect for Connection ' + connection.connectionId, error);\n                        if (error.code === 401) {\n                            return reject(new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to force a disconnection\"));\n                        } else {\n                            return reject(error);\n                        }\n                    } else {\n                        logger.info('Forcing disconnect correctly for Connection ' + connection.connectionId);\n                        return resolve();\n                    }\n                }\n            );\n        });\n    }\n\n\n    /**\n     * Forces some user to unpublish a Stream\n     *\n     * #### Events dispatched\n     *\n     * The behavior is the same as when some user calls [[Session.unpublish]], but `reason` property in all events will be `\"forceUnpublishByUser\"`\n     *\n     * The [[Session]] object of every participant will dispatch a `streamDestroyed` event with property `reason` set to `\"forceDisconnectByUser\"`\n     *\n     * The [[Publisher]] object of the affected participant will also dispatch a `streamDestroyed` event with property `reason` set to `\"forceDisconnectByUser\"`\n     *\n     * See [[StreamEvent]] to learn more.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the remote Stream has been successfully unpublished from the session and rejected with an Error object if not\n     */\n    forceUnpublish(stream: Stream): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                return reject(this.notConnectedError());\n            }\n\n            logger.info('Forcing unpublish for stream ' + stream.streamId);\n            this.openvidu.sendRequest(\n                'forceUnpublish',\n                { streamId: stream.streamId },\n                (error, response) => {\n                    if (error) {\n                        logger.error('Error forcing unpublish for Stream ' + stream.streamId, error);\n                        if (error.code === 401) {\n                            return reject(new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to force an unpublishing\"));\n                        } else {\n                            return reject(error);\n                        }\n                    } else {\n                        logger.info('Forcing unpublish correctly for Stream ' + stream.streamId);\n                        return resolve();\n                    }\n                }\n            );\n        });\n    }\n\n\n    /**\n     * Sends one signal. `signal` object has the following optional properties:\n     * ```json\n     * {data:string, to:Connection[], type:string}\n     * ```\n     * All users subscribed to that signal (`session.on('signal:type', ...)` or `session.on('signal', ...)` for all signals) and whose Connection objects are in `to` array will receive it. Their local\n     * Session objects will dispatch a `signal` or `signal:type` event. See [[SignalEvent]] to learn more.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the message successfully reached openvidu-server and rejected with an Error object if not. _This doesn't\n     * mean that openvidu-server could resend the message to all the listed receivers._\n     */\n    /* tslint:disable:no-string-literal */\n    signal(signal: SignalOptions): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            if (!this.sessionConnected()) {\n                return reject(this.notConnectedError());\n            }\n\n            const signalMessage = {};\n\n            if (signal.to && signal.to.length > 0) {\n                const connectionIds: string[] = [];\n                signal.to.forEach(connection => {\n                    if (!!connection.connectionId) {\n                        connectionIds.push(connection.connectionId);\n                    }\n                });\n                signalMessage['to'] = connectionIds;\n            } else {\n                signalMessage['to'] = [];\n            }\n\n            signalMessage['data'] = signal.data ? signal.data : '';\n\n            let typeAux: string = signal.type ? signal.type : 'signal';\n            if (!!typeAux) {\n                if (typeAux.substring(0, 7) !== 'signal:') {\n                    typeAux = 'signal:' + typeAux;\n                }\n            }\n            signalMessage['type'] = typeAux;\n\n            this.openvidu.sendRequest('sendMessage', {\n                message: JSON.stringify(signalMessage)\n            }, (error, response) => {\n                if (!!error) {\n                    return reject(error);\n                } else {\n                    return resolve();\n                }\n            });\n        });\n    }\n    /* tslint:enable:no-string-literal */\n\n\n    /**\n     * See [[EventDispatcher.on]]\n     */\n    on<K extends keyof SessionEventMap>(type: K, handler: (event: SessionEventMap[K]) => void): this {\n\n        super.onAux(type, \"Event '\" + type + \"' triggered by 'Session'\", handler);\n\n        if (type === 'publisherStartSpeaking') {\n            // If there are already available remote streams with audio, enable hark 'speaking' event in all of them\n            this.remoteConnections.forEach(remoteConnection => {\n                if (!!remoteConnection.stream?.hasAudio) {\n                    remoteConnection.stream.enableHarkSpeakingEvent();\n                }\n            });\n            if (!!this.connection?.stream?.hasAudio) {\n                // If connected to the Session and publishing with audio, also enable hark 'speaking' event for the Publisher\n                this.connection.stream.enableHarkSpeakingEvent();\n            }\n        }\n        if (type === 'publisherStopSpeaking') {\n            // If there are already available remote streams with audio, enable hark 'stopped_speaking' event in all of them\n            this.remoteConnections.forEach(remoteConnection => {\n                if (!!remoteConnection.stream?.hasAudio) {\n                    remoteConnection.stream.enableHarkStoppedSpeakingEvent();\n                }\n            });\n            if (!!this.connection?.stream?.hasAudio) {\n                // If connected to the Session and publishing with audio, also enable hark 'stopped_speaking' event for the Publisher\n                this.connection.stream.enableHarkStoppedSpeakingEvent();\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     * See [[EventDispatcher.once]]\n     */\n    once<K extends keyof SessionEventMap>(type: K, handler: (event: SessionEventMap[K]) => void): this {\n\n        super.onceAux(type, \"Event '\" + type + \"' triggered once by 'Session'\", handler);\n\n        if (type === 'publisherStartSpeaking') {\n            // If there are already available remote streams with audio, enable hark 'speaking' event (once) in all of them once\n            this.remoteConnections.forEach(remoteConnection => {\n                if (!!remoteConnection.stream?.hasAudio) {\n                    remoteConnection.stream.enableOnceHarkSpeakingEvent();\n                }\n            });\n            if (!!this.connection?.stream?.hasAudio) {\n                // If connected to the Session and publishing with audio, also enable hark 'speaking' event (once) for the Publisher\n                this.connection.stream.enableOnceHarkSpeakingEvent();\n            }\n        }\n        if (type === 'publisherStopSpeaking') {\n            // If there are already available remote streams with audio, enable hark 'stopped_speaking' event (once) in all of them once\n            this.remoteConnections.forEach(remoteConnection => {\n                if (!!remoteConnection.stream?.hasAudio) {\n                    remoteConnection.stream.enableOnceHarkStoppedSpeakingEvent();\n                }\n            });\n            if (!!this.connection?.stream?.hasAudio) {\n                // If connected to the Session and publishing with audio, also enable hark 'stopped_speaking' event (once) for the Publisher\n                this.connection.stream.enableOnceHarkStoppedSpeakingEvent();\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     * See [[EventDispatcher.off]]\n     */\n    off<K extends keyof SessionEventMap>(type: K, handler?: (event: SessionEventMap[K]) => void): this {\n\n        super.offAux(type, handler);\n\n        if (type === 'publisherStartSpeaking') {\n            // Check if Session object still has some listener for the event\n            if (!this.anySpeechEventListenerEnabled('publisherStartSpeaking', false)) {\n                this.remoteConnections.forEach(remoteConnection => {\n                    if (!!remoteConnection.stream?.streamManager) {\n                        // Check if Subscriber object still has some listener for the event\n                        if (!this.anySpeechEventListenerEnabled('publisherStartSpeaking', false, remoteConnection.stream.streamManager)) {\n                            remoteConnection.stream.disableHarkSpeakingEvent(false);\n                        }\n                    }\n                });\n                if (!!this.connection?.stream?.streamManager) {\n                    // Check if Publisher object still has some listener for the event\n                    if (!this.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.connection.stream.streamManager)) {\n                        this.connection.stream.disableHarkSpeakingEvent(false);\n                    }\n                }\n            }\n        }\n        if (type === 'publisherStopSpeaking') {\n            // Check if Session object still has some listener for the event\n            if (!this.anySpeechEventListenerEnabled('publisherStopSpeaking', false)) {\n                this.remoteConnections.forEach(remoteConnection => {\n                    if (!!remoteConnection.stream?.streamManager) {\n                        // Check if Subscriber object still has some listener for the event\n                        if (!this.anySpeechEventListenerEnabled('publisherStopSpeaking', false, remoteConnection.stream.streamManager)) {\n                            remoteConnection.stream.disableHarkStoppedSpeakingEvent(false);\n                        }\n                    }\n                });\n                if (!!this.connection?.stream?.streamManager) {\n                    // Check if Publisher object still has some listener for the event\n                    if (!this.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.connection.stream.streamManager)) {\n                        this.connection.stream.disableHarkStoppedSpeakingEvent(false);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    onParticipantJoined(event: RemoteConnectionOptions): void {\n        // Connection shouldn't exist\n        this.getConnection(event.id, '')\n            .then(connection => {\n                logger.warn('Connection ' + connection.connectionId + ' already exists in connections list');\n            })\n            .catch(openViduError => {\n                const connection = new Connection(this, event);\n                this.remoteConnections.set(event.id, connection);\n                this.ee.emitEvent('connectionCreated', [new ConnectionEvent(false, this, 'connectionCreated', connection, '')]);\n            });\n    }\n\n    /**\n     * @hidden\n     */\n    onParticipantLeft(event: { connectionId: string, reason: string }): void {\n        this.getRemoteConnection(event.connectionId, 'onParticipantLeft').then(connection => {\n            if (!!connection.stream) {\n                const stream = connection.stream;\n\n                const streamEvent = new StreamEvent(true, this, 'streamDestroyed', stream, event.reason);\n                this.ee.emitEvent('streamDestroyed', [streamEvent]);\n                streamEvent.callDefaultBehavior();\n\n                this.remoteStreamsCreated.delete(stream.streamId);\n            }\n            this.remoteConnections.delete(connection.connectionId);\n            this.ee.emitEvent('connectionDestroyed', [new ConnectionEvent(false, this, 'connectionDestroyed', connection, event.reason)]);\n        })\n            .catch(openViduError => {\n                logger.error(openViduError);\n            });\n    }\n\n    /**\n     * @hidden\n     */\n    onParticipantPublished(event: RemoteConnectionOptions): void {\n\n        const afterConnectionFound = (connection) => {\n\n            this.remoteConnections.set(connection.connectionId, connection);\n\n            if (!this.remoteStreamsCreated.get(connection.stream.streamId)) {\n                // Avoid race condition between stream.subscribe() in \"onParticipantPublished\" and in \"joinRoom\" rpc callback\n                // This condition is false if openvidu-server sends \"participantPublished\" event to a subscriber participant that has\n                // already subscribed to certain stream in the callback of \"joinRoom\" method\n\n                this.ee.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', connection.stream, '')]);\n            }\n\n            this.remoteStreamsCreated.set(connection.stream.streamId, true);\n        };\n\n        // Get the existing Connection created on 'onParticipantJoined' for\n        // existing participants or create a new one for new participants\n        let connection: Connection;\n        this.getRemoteConnection(event.id, 'onParticipantPublished')\n\n            .then(con => {\n                // Update existing Connection\n                connection = con;\n                event.metadata = con.data;\n                connection.remoteOptions = event;\n                connection.initRemoteStreams(event.streams);\n                afterConnectionFound(connection);\n            })\n            .catch(openViduError => {\n                // Create new Connection\n                connection = new Connection(this, event);\n                afterConnectionFound(connection);\n            });\n    }\n\n    /**\n     * @hidden\n     */\n    onParticipantUnpublished(event: { connectionId: string, reason: string }): void {\n        if (event.connectionId === this.connection.connectionId) {\n            // Your stream has been forcedly unpublished from the session\n            this.stopPublisherStream(event.reason);\n        } else {\n            this.getRemoteConnection(event.connectionId, 'onParticipantUnpublished')\n\n                .then(connection => {\n\n                    const streamEvent = new StreamEvent(true, this, 'streamDestroyed', connection.stream!, event.reason);\n                    this.ee.emitEvent('streamDestroyed', [streamEvent]);\n                    streamEvent.callDefaultBehavior();\n\n                    // Deleting the remote stream\n                    const streamId: string = connection.stream!.streamId;\n                    this.remoteStreamsCreated.delete(streamId);\n\n                    connection.removeStream(streamId);\n                })\n                .catch(openViduError => {\n                    logger.error(openViduError);\n                });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onParticipantEvicted(event: { connectionId: string, reason: string }): void {\n        if (event.connectionId === this.connection.connectionId) {\n            // You have been evicted from the session\n            if (!!this.sessionId && !this.connection.disposed) {\n                this.leave(true, event.reason);\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onNewMessage(event: { type?: string, data?: string, from?: string }): void {\n\n        logger.info('New signal: ' + JSON.stringify(event));\n\n        const strippedType = !!event.type ? event.type.replace(/^(signal:)/, '') : undefined;\n\n        if (!!event.from) {\n            // Signal sent by other client\n            this.getConnection(event.from, \"Connection '\" + event.from + \"' unknown when 'onNewMessage'. Existing remote connections: \"\n                + JSON.stringify(this.remoteConnections.keys()) + '. Existing local connection: ' + this.connection.connectionId)\n\n                .then(connection => {\n                    this.ee.emitEvent('signal', [new SignalEvent(this, strippedType, event.data, connection)]);\n                    if (!!event.type && event.type !== 'signal') {\n                        this.ee.emitEvent(event.type, [new SignalEvent(this, strippedType, event.data, connection)]);\n                    }\n                })\n                .catch(openViduError => {\n                    logger.error(openViduError);\n                });\n        } else {\n            // Signal sent by server\n            this.ee.emitEvent('signal', [new SignalEvent(this, strippedType, event.data, undefined)]);\n            if (!!event.type && event.type !== 'signal') {\n                this.ee.emitEvent(event.type, [new SignalEvent(this, strippedType, event.data, undefined)]);\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onStreamPropertyChanged(event: { connectionId: string, streamId: string, property: string, newValue: any, reason: string }): void {\n\n        const callback = (connection: Connection) => {\n            if (!!connection.stream && connection.stream.streamId === event.streamId) {\n                const stream = connection.stream;\n                let oldValue;\n                switch (event.property) {\n                    case 'audioActive':\n                        oldValue = stream.audioActive;\n                        event.newValue = event.newValue === 'true';\n                        stream.audioActive = event.newValue;\n                        break;\n                    case 'videoActive':\n                        oldValue = stream.videoActive;\n                        event.newValue = event.newValue === 'true';\n                        stream.videoActive = event.newValue;\n                        break;\n                    case 'videoDimensions':\n                        oldValue = stream.videoDimensions;\n                        event.newValue = JSON.parse(JSON.parse(event.newValue));\n                        stream.videoDimensions = event.newValue;\n                        break;\n                    case 'filter':\n                        oldValue = stream.filter;\n                        event.newValue = (Object.keys(event.newValue).length > 0) ? event.newValue : undefined;\n                        if (event.newValue !== undefined) {\n                            stream.filter = new Filter(event.newValue.type, event.newValue.options);\n                            stream.filter.stream = stream;\n                            if (event.newValue.lastExecMethod) {\n                                stream.filter.lastExecMethod = event.newValue.lastExecMethod;\n                            }\n                        } else {\n                            delete stream.filter;\n                        }\n                        event.newValue = stream.filter;\n                        break;\n                }\n                this.ee.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this, stream, event.property, event.newValue, oldValue, event.reason)]);\n                if (!!stream.streamManager) {\n                    stream.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(stream.streamManager, stream, event.property, event.newValue, oldValue, event.reason)]);\n                }\n            } else {\n                logger.error(\"No stream with streamId '\" + event.streamId + \"' found for connection '\" + event.connectionId + \"' on 'streamPropertyChanged' event\");\n            }\n        };\n\n        if (event.connectionId === this.connection.connectionId) {\n            // Your stream has been forcedly changed (filter feature)\n            callback(this.connection);\n        } else {\n            this.getRemoteConnection(event.connectionId, 'onStreamPropertyChanged')\n                .then(connection => {\n                    callback(connection);\n                })\n                .catch(openViduError => {\n                    logger.error(openViduError);\n                });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onConnectionPropertyChanged(event: { property: string, newValue: any }): void {\n        let oldValue;\n        switch (event.property) {\n            case 'role':\n                oldValue = this.connection.role.slice();\n                this.connection.role = event.newValue;\n                this.connection.localOptions!.role = event.newValue;\n                break;\n            case 'record':\n                oldValue = this.connection.record;\n                event.newValue = event.newValue === 'true';\n                this.connection.record = event.newValue;\n                this.connection.localOptions!.record = event.newValue;\n                break;\n        }\n        this.ee.emitEvent('connectionPropertyChanged', [new ConnectionPropertyChangedEvent(this, this.connection, event.property, event.newValue, oldValue)]);\n    }\n\n    /**\n     * @hidden\n     */\n    onNetworkQualityLevelChangedChanged(event: { connectionId: string, newValue: number, oldValue: number }): void {\n        if (event.connectionId === this.connection.connectionId) {\n            this.ee.emitEvent('networkQualityLevelChanged', [new NetworkQualityLevelChangedEvent(this, event.newValue, event.oldValue, this.connection)]);\n        } else {\n            this.getConnection(event.connectionId, 'Connection not found for connectionId ' + event.connectionId)\n                .then((connection: Connection) => {\n                    this.ee.emitEvent('networkQualityLevelChanged', [new NetworkQualityLevelChangedEvent(this, event.newValue, event.oldValue, connection)]);\n                })\n                .catch(openViduError => {\n                    logger.error(openViduError);\n                });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    recvIceCandidate(event: { senderConnectionId: string, endpointName: string, sdpMLineIndex: number, sdpMid: string, candidate: string }): void {\n        // The event contains fields that can be used to obtain a proper candidate,\n        // using the RTCIceCandidate constructor:\n        // https://w3c.github.io/webrtc-pc/#dom-rtcicecandidate-constructor\n        const candidateInit: RTCIceCandidateInit = {\n            candidate: event.candidate,\n            sdpMLineIndex: event.sdpMLineIndex,\n            sdpMid: event.sdpMid,\n        };\n        const iceCandidate = new RTCIceCandidate(candidateInit);\n\n        this.getConnection(event.senderConnectionId, 'Connection not found for connectionId ' + event.senderConnectionId + ' owning endpoint ' + event.endpointName + '. Ice candidate will be ignored: ' + iceCandidate)\n            .then(connection => {\n                const stream: Stream = connection.stream!;\n                stream.getWebRtcPeer().addIceCandidate(iceCandidate).catch(error => {\n                    logger.error('Error adding candidate for ' + stream!.streamId\n                        + ' stream of endpoint ' + event.endpointName + ': ' + error);\n                });\n            })\n            .catch(openViduError => {\n                logger.error(openViduError);\n            });\n    }\n\n    /**\n     * @hidden\n     */\n    onSessionClosed(msg): void {\n        logger.info('Session closed: ' + JSON.stringify(msg));\n        const s = msg.sessionId;\n        if (s !== undefined) {\n            this.ee.emitEvent('session-closed', [{\n                session: s\n            }]);\n        } else {\n            logger.warn('Session undefined on session closed', msg);\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onLostConnection(reason: string): void {\n        logger.warn('Lost connection in Session ' + this.sessionId);\n        if (!!this.sessionId && !!this.connection && !this.connection.disposed) {\n            this.leave(true, reason);\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onRecoveredConnection(): void {\n        logger.info('Recovered connection in Session ' + this.sessionId);\n        this.reconnectBrokenStreams();\n        this.ee.emitEvent('reconnected', []);\n    }\n\n    /**\n     * @hidden\n     */\n    onMediaError(event: { error: string }): void {\n        logger.error('Media error: ' + JSON.stringify(event));\n        const err = event.error;\n        if (err) {\n            this.ee.emitEvent('error-media', [{\n                error: err\n            }]);\n        } else {\n            logger.warn('Received undefined media error:', event);\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    onRecordingStarted(event: { id: string, name: string }): void {\n        this.ee.emitEvent('recordingStarted', [new RecordingEvent(this, 'recordingStarted', event.id, event.name)]);\n    }\n\n    /**\n     * @hidden\n     */\n    onRecordingStopped(event: { id: string, name: string, reason: string }): void {\n        this.ee.emitEvent('recordingStopped', [new RecordingEvent(this, 'recordingStopped', event.id, event.name, event.reason)]);\n    }\n\n    /**\n     * @hidden\n     */\n    onFilterEventDispatched(event: { connectionId: string, streamId: string, filterType: string, eventType: string, data: string }): void {\n        const connectionId: string = event.connectionId;\n        this.getConnection(connectionId, 'No connection found for connectionId ' + connectionId)\n            .then(connection => {\n                logger.info(`Filter event of type \"${event.eventType}\" dispatched`);\n                const stream: Stream = connection.stream!;\n                if (!stream || !stream.filter) {\n                    return logger.error(`Filter event of type \"${event.eventType}\" dispatched for stream ${stream.streamId} but there is no ${!stream ? 'stream' : 'filter'} defined`);\n                }\n                const eventHandler = stream.filter.handlers.get(event.eventType);\n                if (!eventHandler || typeof eventHandler !== 'function') {\n                    const actualHandlers: string[] = Array.from(stream.filter.handlers.keys());\n                    return logger.error(`Filter event of type \"${event.eventType}\" not handled or not a function! Active filter events: ${actualHandlers.join(',')}`);\n                } else {\n                    eventHandler.call(this, new FilterEvent(stream.filter, event.eventType, event.data));\n                }\n            });\n    }\n\n    /**\n     * @hidden\n     */\n    onForciblyReconnectSubscriber(event: { connectionId: string, streamId: string, sdpOffer: string }): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.getRemoteConnection(event.connectionId, 'onForciblyReconnectSubscriber')\n                .then(connection => {\n                    if (!!connection.stream && connection.stream.streamId === event.streamId) {\n                        const stream = connection.stream;\n\n                        if (stream.setupReconnectionEventEmitter(resolve, reject)) {\n                            // Ongoing reconnection\n                            // Wait for the event emitter to be free (with success or error) and call the method again\n                            if (stream.reconnectionEventEmitter!['onForciblyReconnectSubscriberLastEvent'] != null) {\n                                // Two or more onForciblyReconnectSubscriber events were received while a reconnection process\n                                // of the subscriber was already taking place. Always use the last one to retry the re-subscription\n                                // process, as that SDP offer will be the only one available at the server side. Ignore previous ones\n                                stream.reconnectionEventEmitter!['onForciblyReconnectSubscriberLastEvent'] = event;\n                                return reject('Ongoing forced subscriber reconnection');\n                            } else {\n                                // One onForciblyReconnectSubscriber even has been received while a reconnection process\n                                // of the subscriber was already taking place. Set up a listener to wait for it to retry the\n                                // forced reconnection process\n                                stream.reconnectionEventEmitter!['onForciblyReconnectSubscriberLastEvent'] = event;\n                                const callback = () => {\n                                    const eventAux = stream.reconnectionEventEmitter!['onForciblyReconnectSubscriberLastEvent'];\n                                    delete stream.reconnectionEventEmitter!['onForciblyReconnectSubscriberLastEvent'];\n                                    this.onForciblyReconnectSubscriber(eventAux);\n                                }\n                                stream.reconnectionEventEmitter!.once('success', () => {\n                                    callback();\n                                });\n                                stream.reconnectionEventEmitter!.once('error', () => {\n                                    callback();\n                                });\n                            }\n                            return;\n                        }\n\n                        stream.completeWebRtcPeerReceive(true, true, event.sdpOffer)\n                            .then(() => stream.finalResolveForSubscription(true, resolve))\n                            .catch(error => stream.finalRejectForSubscription(true, `Error while forcibly reconnecting remote stream ${event.streamId}: ${error.toString()}`, reject));\n                    } else {\n                        const errMsg = \"No stream with streamId '\" + event.streamId + \"' found for connection '\" + event.connectionId + \"' on 'streamPropertyChanged' event\";\n                        logger.error(errMsg);\n                        return reject(errMsg);\n                    }\n                })\n                .catch(openViduError => {\n                    logger.error(openViduError);\n                    return reject(openViduError);\n                });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    reconnectBrokenStreams(): void {\n        logger.info('Re-establishing media connections...');\n        let someReconnection = false;\n        // Re-establish Publisher stream\n        if (!!this.connection.stream && this.connection.stream.streamIceConnectionStateBroken()) {\n            logger.warn('Re-establishing Publisher ' + this.connection.stream.streamId);\n            this.connection.stream.initWebRtcPeerSend(true);\n            someReconnection = true;\n        }\n        // Re-establish Subscriber streams\n        this.remoteConnections.forEach(remoteConnection => {\n            if (!!remoteConnection.stream && remoteConnection.stream.streamIceConnectionStateBroken()) {\n                logger.warn('Re-establishing Subscriber ' + remoteConnection.stream.streamId);\n                remoteConnection.stream.initWebRtcPeerReceive(true);\n                someReconnection = true;\n            }\n        });\n        if (!someReconnection) {\n            logger.info('There were no media streams in need of a reconnection');\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    emitEvent(type: string, eventArray: any[]): void {\n        this.ee.emitEvent(type, eventArray);\n    }\n\n    /**\n     * @hidden\n     */\n    leave(forced: boolean, reason: string): void {\n\n        forced = !!forced;\n        logger.info('Leaving Session (forced=' + forced + ')');\n        this.stopVideoDataIntervals();\n\n        if (!!this.connection) {\n            if (!this.connection.disposed && !forced) {\n                this.openvidu.sendRequest('leaveRoom', (error, response) => {\n                    if (error) {\n                        logger.error(`leaveRoom error: ${JSON.stringify(error)}`);\n                    }\n                    this.openvidu.closeWs();\n                });\n            } else {\n                this.openvidu.closeWs();\n            }\n\n            this.stopPublisherStream(reason);\n\n            if (!this.connection.disposed) {\n                // Make Session object dispatch 'sessionDisconnected' event (if it is not already disposed)\n                const sessionDisconnectEvent = new SessionDisconnectedEvent(this, reason);\n                this.ee.emitEvent('sessionDisconnected', [sessionDisconnectEvent]);\n                sessionDisconnectEvent.callDefaultBehavior();\n            }\n        } else {\n            logger.warn('You were not connected to the session ' + this.sessionId);\n        }\n        logger.flush();\n    }\n\n    /**\n     * @hidden\n     */\n    initializeParams(token: string) {\n        const joinParams = {\n            token: (!!token) ? token : '',\n            session: this.sessionId,\n            platform: !!platform.getDescription() ? platform.getDescription() : 'unknown',\n            sdkVersion: this.openvidu.libraryVersion,\n            metadata: !!this.options.metadata ? this.options.metadata : '',\n            secret: this.openvidu.getSecret(),\n            recorder: this.openvidu.getRecorder()\n        };\n        return joinParams;\n    }\n\n    /**\n     * @hidden\n     */\n    sendVideoData(streamManager: StreamManager, intervalSeconds: number = 1, doInterval: boolean = false, maxLoops: number = 1) {\n        if (\n            platform.isChromeBrowser() || platform.isChromeMobileBrowser() || platform.isOperaBrowser() ||\n            platform.isOperaMobileBrowser() || platform.isEdgeBrowser() || platform.isEdgeMobileBrowser() || platform.isElectron() ||\n            (platform.isSafariBrowser() && !platform.isIonicIos()) || platform.isAndroidBrowser() ||\n            platform.isSamsungBrowser() || platform.isIonicAndroid() || platform.isIOSWithSafari()\n        ) {\n            const obtainAndSendVideo = async () => {\n                const pc = streamManager.stream.getRTCPeerConnection();\n                if (pc.connectionState === 'connected') {\n                    const statsMap = await pc.getStats();\n                    const arr: any[] = [];\n                    statsMap.forEach(stats => {\n                        if ((\"frameWidth\" in stats) && (\"frameHeight\" in stats) && (arr.length === 0)) {\n                            arr.push(stats);\n                        }\n                    });\n                    if (arr.length > 0) {\n                        this.openvidu.sendRequest('videoData', {\n                            height: arr[0].frameHeight,\n                            width: arr[0].frameWidth,\n                            videoActive: streamManager.stream.videoActive != null ? streamManager.stream.videoActive : false,\n                            audioActive: streamManager.stream.audioActive != null ? streamManager.stream.audioActive : false\n                        }, (error, response) => {\n                            if (error) {\n                                logger.error(\"Error sending 'videoData' event\", error);\n                            }\n                        });\n                    }\n                }\n            }\n            if (doInterval) {\n                let loops = 1;\n                this.videoDataInterval = setInterval(() => {\n                    if (loops < maxLoops) {\n                        loops++;\n                        obtainAndSendVideo();\n                    } else {\n                        clearInterval(this.videoDataInterval);\n                    }\n                }, intervalSeconds * 1000);\n            } else {\n                this.videoDataTimeout = setTimeout(obtainAndSendVideo, intervalSeconds * 1000);\n            }\n        } else if (platform.isFirefoxBrowser() || platform.isFirefoxMobileBrowser() || platform.isIonicIos() || platform.isReactNative()) {\n            // Basic version for Firefox and Ionic iOS. They do not support stats\n            this.openvidu.sendRequest('videoData', {\n                height: streamManager.stream.videoDimensions?.height || 0,\n                width: streamManager.stream.videoDimensions?.width || 0,\n                videoActive: streamManager.stream.videoActive != null ? streamManager.stream.videoActive : false,\n                audioActive: streamManager.stream.audioActive != null ? streamManager.stream.audioActive : false\n            }, (error, response) => {\n                if (error) {\n                    logger.error(\"Error sending 'videoData' event\", error);\n                }\n            });\n        } else {\n            logger.error('Browser ' + platform.getName() + ' (version ' + platform.getVersion() + ') for ' + platform.getFamily() + ' is not supported in OpenVidu for Network Quality');\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    sessionConnected() {\n        return this.connection != null;\n    }\n\n    /**\n     * @hidden\n     */\n    notConnectedError(): OpenViduError {\n        return new OpenViduError(OpenViduErrorName.OPENVIDU_NOT_CONNECTED, \"There is no connection to the session. Method 'Session.connect' must be successfully completed first\");\n    }\n\n    /**\n     * @hidden\n     */\n    anySpeechEventListenerEnabled(event: string, onlyOnce: boolean, streamManager?: StreamManager): boolean {\n        let handlersInSession = this.ee.getListeners(event);\n        if (onlyOnce) {\n            handlersInSession = handlersInSession.filter(h => (h as any).once);\n        }\n        let listenersInSession = handlersInSession.length;\n        if (listenersInSession > 0) return true;\n        let listenersInStreamManager = 0;\n        if (!!streamManager) {\n            let handlersInStreamManager = streamManager.ee.getListeners(event);\n            if (onlyOnce) {\n                handlersInStreamManager = handlersInStreamManager.filter(h => (h as any).once);\n            }\n            listenersInStreamManager = handlersInStreamManager.length;\n        }\n        return listenersInStreamManager > 0;\n    }\n\n    /**\n     * @hidden\n     */\n    getTokenParams(token: string) {\n        const match = token.match(/^(wss?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)([\\/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/);\n        if (!!match) {\n            const url = {\n                protocol: match[1],\n                host: match[2],\n                hostname: match[3],\n                port: match[4],\n                pathname: match[5],\n                search: match[6],\n                hash: match[7]\n            };\n\n            const params = token.split('?');\n            const queryParams = decodeURI(params[1])\n                .split('&')\n                .map(param => param.split('='))\n                .reduce((values, [key, value]) => {\n                    values[key] = value\n                    return values\n                }, {});\n\n            return {\n                sessionId: queryParams['sessionId'],\n                secret: queryParams['secret'],\n                recorder: queryParams['recorder'],\n                webrtcStatsInterval: queryParams['webrtcStatsInterval'],\n                sendBrowserLogs: queryParams['sendBrowserLogs'],\n                edition: queryParams['edition'],\n                wsUri: 'wss://' + url.host + '/openvidu',\n                httpUri: 'https://' + url.host\n            };\n\n        } else {\n            throw new Error(`Token not valid: \"${token}\"`);\n        }\n    }\n\n    /* Private methods */\n\n    private connectAux(token: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.openvidu.startWs((error) => {\n                if (!!error) {\n                    return reject(error);\n                } else {\n\n                    const joinParams = this.initializeParams(token);\n\n                    this.openvidu.sendRequest('joinRoom', joinParams, (error, response: LocalConnectionOptions) => {\n                        if (!!error) {\n                            return reject(error);\n                        } else {\n\n                            // Process join room response\n                            this.processJoinRoomResponse(response, token);\n\n                            // Initialize local Connection object with values returned by openvidu-server\n                            this.connection = new Connection(this, response);\n\n                            // Initialize remote Connections with value returned by openvidu-server\n                            const events = {\n                                connections: new Array<Connection>(),\n                                streams: new Array<Stream>()\n                            };\n                            const existingParticipants: RemoteConnectionOptions[] = response.value;\n                            existingParticipants.forEach((remoteConnectionOptions: RemoteConnectionOptions) => {\n                                const connection = new Connection(this, remoteConnectionOptions);\n                                this.remoteConnections.set(connection.connectionId, connection);\n                                events.connections.push(connection);\n                                if (!!connection.stream) {\n                                    this.remoteStreamsCreated.set(connection.stream.streamId, true);\n                                    events.streams.push(connection.stream);\n                                }\n                            });\n\n                            // Own 'connectionCreated' event\n                            this.ee.emitEvent('connectionCreated', [new ConnectionEvent(false, this, 'connectionCreated', this.connection, '')]);\n\n                            // One 'connectionCreated' event for each existing connection in the session\n                            events.connections.forEach(connection => {\n                                this.ee.emitEvent('connectionCreated', [new ConnectionEvent(false, this, 'connectionCreated', connection, '')]);\n                            });\n\n                            // One 'streamCreated' event for each active stream in the session\n                            events.streams.forEach(stream => {\n                                this.ee.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', stream, '')]);\n                            });\n\n                            return resolve();\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    private stopPublisherStream(reason: string) {\n        if (!!this.connection.stream) {\n            // Dispose Publisher's  local stream\n            this.connection.stream.disposeWebRtcPeer();\n            if (this.connection.stream.isLocalStreamPublished) {\n                // Make Publisher object dispatch 'streamDestroyed' event if the Stream was published\n                this.connection.stream.ee.emitEvent('local-stream-destroyed', [reason]);\n            }\n        }\n    }\n\n    private stopVideoDataIntervals(): void {\n        clearInterval(this.videoDataInterval);\n        clearTimeout(this.videoDataTimeout);\n    }\n\n    private stringClientMetadata(metadata: any): string {\n        if (typeof metadata !== 'string') {\n            return JSON.stringify(metadata);\n        } else {\n            return metadata;\n        }\n    }\n\n    protected getConnection(connectionId: string, errorMessage: string): Promise<Connection> {\n        return new Promise<Connection>((resolve, reject) => {\n            const connection = this.remoteConnections.get(connectionId);\n            if (!!connection) {\n                // Resolve remote connection\n                return resolve(connection);\n            } else {\n                if (this.connection.connectionId === connectionId) {\n                    // Resolve local connection\n                    return resolve(this.connection);\n                } else {\n                    // Connection not found. Reject with OpenViduError\n                    return reject(new OpenViduError(OpenViduErrorName.GENERIC_ERROR, errorMessage));\n                }\n            }\n        });\n    }\n\n    private getRemoteConnection(connectionId: string, operation: string): Promise<Connection> {\n        return new Promise<Connection>((resolve, reject) => {\n            const connection = this.remoteConnections.get(connectionId);\n            if (!!connection) {\n                // Resolve remote connection\n                return resolve(connection);\n            } else {\n                // Remote connection not found. Reject with OpenViduError\n                const errorMessage = 'Remote connection ' + connectionId + \" unknown when '\" + operation + \"'. \" +\n                    'Existing remote connections: ' + JSON.stringify(this.remoteConnections.keys());\n                return reject(new OpenViduError(OpenViduErrorName.GENERIC_ERROR, errorMessage));\n            }\n        });\n    }\n\n    private processToken(token: string): void {\n        const tokenParams = this.getTokenParams(token);\n        this.sessionId = tokenParams.sessionId;\n\n        if (!!tokenParams.secret) {\n            this.openvidu.secret = tokenParams.secret;\n        }\n        if (!!tokenParams.recorder) {\n            this.openvidu.recorder = true;\n        }\n        if (!!tokenParams.webrtcStatsInterval) {\n            this.openvidu.webrtcStatsInterval = tokenParams.webrtcStatsInterval;\n        }\n        if (!!tokenParams.sendBrowserLogs) {\n            this.openvidu.sendBrowserLogs = tokenParams.sendBrowserLogs;\n        }\n        this.openvidu.isAtLeastPro = tokenParams.edition === 'pro' || tokenParams.edition === 'enterprise';\n        this.openvidu.isEnterprise = tokenParams.edition === 'enterprise';\n\n        this.openvidu.wsUri = tokenParams.wsUri;\n        this.openvidu.httpUri = tokenParams.httpUri;\n    }\n\n    private processJoinRoomResponse(opts: LocalConnectionOptions, token: string) {\n        this.sessionId = opts.session;\n        if (opts.customIceServers != null && opts.customIceServers.length > 0) {\n            this.openvidu.iceServers = [];\n            for (const iceServer of opts.customIceServers) {\n                let rtcIceServer: RTCIceServer = {\n                    urls: [iceServer.url]\n                }\n                logger.log(\"STUN/TURN server IP: \" + iceServer.url);\n                if (iceServer.username != null && iceServer.credential != null) {\n                    rtcIceServer.username = iceServer.username;\n                    rtcIceServer.credential = iceServer.credential;\n                    logger.log('TURN credentials [' + iceServer.username + ':' + iceServer.credential + ']');\n                }\n                this.openvidu.iceServers.push(rtcIceServer);\n            }\n        } else if (opts.coturnIp != null && opts.coturnPort != null && opts.turnUsername != null && opts.turnCredential != null) {\n            const turnUrl1 = 'turn:' + opts.coturnIp + ':' + opts.coturnPort;\n            this.openvidu.iceServers = [\n                { urls: [turnUrl1], username: opts.turnUsername, credential: opts.turnCredential }\n            ];\n            logger.log(\"STUN/TURN server IP: \" + opts.coturnIp);\n            logger.log('TURN temp credentials [' + opts.turnUsername + ':' + opts.turnCredential + ']');\n        }\n        this.openvidu.role = opts.role;\n        this.openvidu.finalUserId = opts.finalUserId;\n        this.openvidu.mediaServer = opts.mediaServer;\n        this.openvidu.videoSimulcast = opts.videoSimulcast;\n        this.capabilities = {\n            subscribe: true,\n            publish: this.openvidu.role !== 'SUBSCRIBER',\n            forceUnpublish: this.openvidu.role === 'MODERATOR',\n            forceDisconnect: this.openvidu.role === 'MODERATOR'\n        };\n        logger.info(\"openvidu-server version: \" + opts.version);\n        if (opts.life != null) {\n            this.openvidu.life = opts.life;\n        }\n        const minorDifference: number = semverMinor(opts.version) - semverMinor(this.openvidu.libraryVersion);\n        if ((semverMajor(opts.version) !== semverMajor(this.openvidu.libraryVersion)) || !(minorDifference == 0 || minorDifference == 1)) {\n            logger.error(`openvidu-browser (${this.openvidu.libraryVersion}) and openvidu-server (${opts.version}) versions are incompatible. `\n                + 'Errors are likely to occur. openvidu-browser SDK is only compatible with the same version or the immediately following minor version of an OpenVidu deployment');\n        } else if (minorDifference == 1) {\n            logger.warn(`openvidu-browser version ${this.openvidu.libraryVersion} does not match openvidu-server version ${opts.version}. `\n                + `These versions are still compatible with each other, but openvidu-browser version must be updated as soon as possible to ${semverMajor(opts.version)}.${semverMinor(opts.version)}.x. `\n                + `This client using openvidu-browser ${this.openvidu.libraryVersion} will become incompatible with the next release of openvidu-server`);\n        }\n\n        // Configure JSNLogs\n        OpenViduLogger.configureJSNLog(this.openvidu, token);\n\n        // Store token\n        this.token = token;\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}
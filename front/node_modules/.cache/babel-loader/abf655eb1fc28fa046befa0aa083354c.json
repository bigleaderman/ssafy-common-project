{"ast":null,"code":"var RpcBuilder = require('../');\n\nvar WebSocketWithReconnection = require('./transports/webSocketWithReconnection');\n\nvar OpenViduLogger = require('../../../Logger/OpenViduLogger').OpenViduLogger;\n\nDate.now = Date.now || function () {\n  return +new Date();\n};\n\nvar PING_INTERVAL = 5000;\nvar RECONNECTING = 'RECONNECTING';\nvar CONNECTED = 'CONNECTED';\nvar DISCONNECTED = 'DISCONNECTED';\nvar Logger = OpenViduLogger.getInstance();\n\nfunction JsonRpcClient(configuration) {\n  var self = this;\n  var wsConfig = configuration.ws;\n  var notReconnectIfNumLessThan = -1;\n  var pingNextNum = 0;\n  var enabledPings = true;\n  var pingPongStarted = false;\n  var pingInterval;\n  var status = DISCONNECTED;\n  var onreconnecting = wsConfig.onreconnecting;\n  var onreconnected = wsConfig.onreconnected;\n  var onconnected = wsConfig.onconnected;\n  var onerror = wsConfig.onerror;\n\n  configuration.rpc.pull = function (params, request) {\n    request.reply(null, \"push\");\n  };\n\n  wsConfig.onreconnecting = function () {\n    Logger.debug(\"--------- ONRECONNECTING -----------\");\n\n    if (status === RECONNECTING) {\n      Logger.error(\"Websocket already in RECONNECTING state when receiving a new ONRECONNECTING message. Ignoring it\");\n      return;\n    }\n\n    stopPing();\n    status = RECONNECTING;\n\n    if (onreconnecting) {\n      onreconnecting();\n    }\n  };\n\n  wsConfig.onreconnected = function () {\n    Logger.debug(\"--------- ONRECONNECTED -----------\");\n\n    if (status === CONNECTED) {\n      Logger.error(\"Websocket already in CONNECTED state when receiving a new ONRECONNECTED message. Ignoring it\");\n      return;\n    }\n\n    status = CONNECTED;\n    updateNotReconnectIfLessThan();\n\n    if (onreconnected) {\n      onreconnected();\n    }\n  };\n\n  wsConfig.onconnected = function () {\n    Logger.debug(\"--------- ONCONNECTED -----------\");\n\n    if (status === CONNECTED) {\n      Logger.error(\"Websocket already in CONNECTED state when receiving a new ONCONNECTED message. Ignoring it\");\n      return;\n    }\n\n    status = CONNECTED;\n    enabledPings = true;\n    usePing();\n\n    if (onconnected) {\n      onconnected();\n    }\n  };\n\n  wsConfig.onerror = function (error) {\n    Logger.debug(\"--------- ONERROR -----------\");\n    status = DISCONNECTED;\n    stopPing();\n\n    if (onerror) {\n      onerror(error);\n    }\n  };\n\n  var ws = new WebSocketWithReconnection(wsConfig);\n  Logger.debug('Connecting websocket to URI: ' + wsConfig.uri);\n  var rpcBuilderOptions = {\n    request_timeout: configuration.rpc.requestTimeout,\n    ping_request_timeout: configuration.rpc.heartbeatRequestTimeout\n  };\n  var rpc = new RpcBuilder(RpcBuilder.packers.JsonRPC, rpcBuilderOptions, ws, function (request) {\n    Logger.debug('Received request: ' + JSON.stringify(request));\n\n    try {\n      var func = configuration.rpc[request.method];\n\n      if (func === undefined) {\n        Logger.error(\"Method \" + request.method + \" not registered in client\");\n      } else {\n        func(request.params, request);\n      }\n    } catch (err) {\n      Logger.error('Exception processing request: ' + JSON.stringify(request));\n      Logger.error(err);\n    }\n  });\n\n  this.send = function (method, params, callback) {\n    var requestTime = Date.now();\n    rpc.encode(method, params, function (error, result) {\n      if (error) {\n        try {\n          Logger.error(\"ERROR:\" + error.message + \" in Request: method:\" + method + \" params:\" + JSON.stringify(params) + \" request:\" + error.request);\n\n          if (error.data) {\n            Logger.error(\"ERROR DATA:\" + JSON.stringify(error.data));\n          }\n        } catch (e) {}\n\n        error.requestTime = requestTime;\n      }\n\n      if (callback) {\n        if (result != undefined && result.value !== 'pong') {\n          Logger.debug('Response: ' + JSON.stringify(result));\n        }\n\n        callback(error, result);\n      }\n    });\n  };\n\n  function updateNotReconnectIfLessThan() {\n    Logger.debug(\"notReconnectIfNumLessThan = \" + pingNextNum + ' (old=' + notReconnectIfNumLessThan + ')');\n    notReconnectIfNumLessThan = pingNextNum;\n  }\n\n  function sendPing() {\n    if (enabledPings) {\n      var params = null;\n\n      if (pingNextNum == 0 || pingNextNum == notReconnectIfNumLessThan) {\n        params = {\n          interval: configuration.heartbeat || PING_INTERVAL\n        };\n      }\n\n      pingNextNum++;\n      self.send('ping', params, function (pingNum) {\n        return function (error, result) {\n          if (error) {\n            Logger.debug(\"Error in ping request #\" + pingNum + \" (\" + error.message + \")\");\n\n            if (pingNum > notReconnectIfNumLessThan) {\n              enabledPings = false;\n              updateNotReconnectIfLessThan();\n              Logger.debug(\"Server did not respond to ping message #\" + pingNum + \". Reconnecting... \");\n              ws.reconnectWs();\n            }\n          }\n        };\n      }(pingNextNum));\n    } else {\n      Logger.debug(\"Trying to send ping, but ping is not enabled\");\n    }\n  }\n\n  function usePing() {\n    if (!pingPongStarted) {\n      Logger.debug(\"Starting ping (if configured)\");\n      pingPongStarted = true;\n\n      if (configuration.heartbeat != undefined) {\n        pingInterval = setInterval(sendPing, configuration.heartbeat);\n        sendPing();\n      }\n    }\n  }\n\n  function stopPing() {\n    clearInterval(pingInterval);\n    pingPongStarted = false;\n    enabledPings = false;\n    pingNextNum = -1;\n    rpc.cancel();\n  }\n\n  this.close = function (code, reason) {\n    Logger.debug(\"Closing  with code: \" + code + \" because: \" + reason);\n\n    if (pingInterval != undefined) {\n      Logger.debug(\"Clearing ping interval\");\n      clearInterval(pingInterval);\n    }\n\n    pingPongStarted = false;\n    enabledPings = false;\n    ws.close(code, reason);\n  };\n\n  this.reconnect = function () {\n    ws.reconnectWs();\n  };\n\n  this.resetPing = function () {\n    enabledPings = true;\n    pingNextNum = 0;\n    usePing();\n  };\n\n  this.getReadyState = function () {\n    return ws.getReadyState();\n  };\n}\n\nmodule.exports = JsonRpcClient;","map":{"version":3,"mappings":"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","names":["RpcBuilder","require","WebSocketWithReconnection","OpenViduLogger","Date","now","PING_INTERVAL","RECONNECTING","CONNECTED","DISCONNECTED","Logger","getInstance","JsonRpcClient","configuration","self","wsConfig","ws","notReconnectIfNumLessThan","pingNextNum","enabledPings","pingPongStarted","pingInterval","status","onreconnecting","onreconnected","onconnected","onerror","rpc","pull","params","request","reply","debug","error","stopPing","updateNotReconnectIfLessThan","usePing","uri","rpcBuilderOptions","request_timeout","requestTimeout","ping_request_timeout","heartbeatRequestTimeout","packers","JsonRPC","JSON","stringify","func","method","undefined","err","send","callback","requestTime","encode","result","message","data","e","value","sendPing","interval","heartbeat","pingNum","reconnectWs","setInterval","clearInterval","cancel","close","code","reason","reconnect","resetPing","getReadyState","module","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenViduInternal\\KurentoUtils\\kurento-jsonrpc\\clients\\jsonrpcclient.js"],"sourcesContent":["/*\n * (C) Copyright 2014 Kurento (http://kurento.org/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar RpcBuilder = require('../');\nvar WebSocketWithReconnection = require('./transports/webSocketWithReconnection');\nvar OpenViduLogger = require('../../../Logger/OpenViduLogger').OpenViduLogger;\n\nDate.now = Date.now || function () {\n    return +new Date;\n};\n\nvar PING_INTERVAL = 5000;\n\nvar RECONNECTING = 'RECONNECTING';\nvar CONNECTED = 'CONNECTED';\nvar DISCONNECTED = 'DISCONNECTED';\n\nvar Logger = OpenViduLogger.getInstance();\n\n/**\n *\n * heartbeat: interval in ms for each heartbeat message,\n * <pre>\n * ws : {\n * \turi : URI to conntect to,\n * \tonconnected : callback method to invoke when connection is successful,\n * \tondisconnect : callback method to invoke when the connection is lost (max retries for reconnecting reached),\n * \tonreconnecting : callback method to invoke when the client is reconnecting,\n * \tonreconnected : callback method to invoke when the client successfully reconnects,\n * \tonerror : callback method to invoke when there is an error\n * },\n * rpc : {\n * \trequestTimeout : timeout for a request,\n * \tsessionStatusChanged: callback method for changes in session status,\n * \tmediaRenegotiation: mediaRenegotiation\n * }\n * </pre>\n */\nfunction JsonRpcClient(configuration) {\n\n    var self = this;\n\n    var wsConfig = configuration.ws;\n\n    var notReconnectIfNumLessThan = -1;\n\n    var pingNextNum = 0;\n    var enabledPings = true;\n    var pingPongStarted = false;\n    var pingInterval;\n\n    var status = DISCONNECTED;\n\n    var onreconnecting = wsConfig.onreconnecting;\n    var onreconnected = wsConfig.onreconnected;\n    var onconnected = wsConfig.onconnected;\n    var onerror = wsConfig.onerror;\n\n    configuration.rpc.pull = function (params, request) {\n        request.reply(null, \"push\");\n    }\n\n    wsConfig.onreconnecting = function () {\n        Logger.debug(\"--------- ONRECONNECTING -----------\");\n        if (status === RECONNECTING) {\n            Logger.error(\"Websocket already in RECONNECTING state when receiving a new ONRECONNECTING message. Ignoring it\");\n            return;\n        }\n\n        stopPing();\n\n        status = RECONNECTING;\n        if (onreconnecting) {\n            onreconnecting();\n        }\n    }\n\n    wsConfig.onreconnected = function () {\n        Logger.debug(\"--------- ONRECONNECTED -----------\");\n        if (status === CONNECTED) {\n            Logger.error(\"Websocket already in CONNECTED state when receiving a new ONRECONNECTED message. Ignoring it\");\n            return;\n        }\n        status = CONNECTED;\n\n        updateNotReconnectIfLessThan();\n\n        if (onreconnected) {\n            onreconnected();\n        }\n    }\n\n    wsConfig.onconnected = function () {\n        Logger.debug(\"--------- ONCONNECTED -----------\");\n        if (status === CONNECTED) {\n            Logger.error(\"Websocket already in CONNECTED state when receiving a new ONCONNECTED message. Ignoring it\");\n            return;\n        }\n        status = CONNECTED;\n\n        enabledPings = true;\n        usePing();\n\n        if (onconnected) {\n            onconnected();\n        }\n    }\n\n    wsConfig.onerror = function (error) {\n        Logger.debug(\"--------- ONERROR -----------\");\n\n        status = DISCONNECTED;\n\n        stopPing();\n\n        if (onerror) {\n            onerror(error);\n        }\n    }\n\n    var ws = new WebSocketWithReconnection(wsConfig);\n\n    Logger.debug('Connecting websocket to URI: ' + wsConfig.uri);\n\n    var rpcBuilderOptions = {\n        request_timeout: configuration.rpc.requestTimeout,\n        ping_request_timeout: configuration.rpc.heartbeatRequestTimeout\n    };\n\n    var rpc = new RpcBuilder(RpcBuilder.packers.JsonRPC, rpcBuilderOptions, ws,\n        function (request) {\n\n            Logger.debug('Received request: ' + JSON.stringify(request));\n\n            try {\n                var func = configuration.rpc[request.method];\n\n                if (func === undefined) {\n                    Logger.error(\"Method \" + request.method + \" not registered in client\");\n                } else {\n                    func(request.params, request);\n                }\n            } catch (err) {\n                Logger.error('Exception processing request: ' + JSON.stringify(request));\n                Logger.error(err);\n            }\n        });\n\n    this.send = function (method, params, callback) {\n\n        var requestTime = Date.now();\n\n        rpc.encode(method, params, function (error, result) {\n            if (error) {\n                try {\n                    Logger.error(\"ERROR:\" + error.message + \" in Request: method:\" +\n                        method + \" params:\" + JSON.stringify(params) + \" request:\" +\n                        error.request);\n                    if (error.data) {\n                        Logger.error(\"ERROR DATA:\" + JSON.stringify(error.data));\n                    }\n                } catch (e) {}\n                error.requestTime = requestTime;\n            }\n            if (callback) {\n                if (result != undefined && result.value !== 'pong') {\n                    Logger.debug('Response: ' + JSON.stringify(result));\n                }\n                callback(error, result);\n            }\n        });\n    }\n\n    function updateNotReconnectIfLessThan() {\n        Logger.debug(\"notReconnectIfNumLessThan = \" + pingNextNum + ' (old=' +\n            notReconnectIfNumLessThan + ')');\n        notReconnectIfNumLessThan = pingNextNum;\n    }\n\n    function sendPing() {\n        if (enabledPings) {\n            var params = null;\n            if (pingNextNum == 0 || pingNextNum == notReconnectIfNumLessThan) {\n                params = {\n                    interval: configuration.heartbeat || PING_INTERVAL\n                };\n            }\n            pingNextNum++;\n\n            self.send('ping', params, (function (pingNum) {\n                return function (error, result) {\n                    if (error) {\n                        Logger.debug(\"Error in ping request #\" + pingNum + \" (\" +\n                            error.message + \")\");\n                        if (pingNum > notReconnectIfNumLessThan) {\n                            enabledPings = false;\n                            updateNotReconnectIfLessThan();\n                            Logger.debug(\"Server did not respond to ping message #\" +\n                                pingNum + \". Reconnecting... \");\n                            ws.reconnectWs();\n                        }\n                    }\n                }\n            })(pingNextNum));\n        } else {\n            Logger.debug(\"Trying to send ping, but ping is not enabled\");\n        }\n    }\n\n    /*\n     * If configuration.hearbeat has any value, the ping-pong will work with the interval\n     * of configuration.hearbeat\n     */\n    function usePing() {\n        if (!pingPongStarted) {\n            Logger.debug(\"Starting ping (if configured)\")\n            pingPongStarted = true;\n\n            if (configuration.heartbeat != undefined) {\n                pingInterval = setInterval(sendPing, configuration.heartbeat);\n                sendPing();\n            }\n        }\n    }\n\n    function stopPing() {\n        clearInterval(pingInterval);\n        pingPongStarted = false;\n        enabledPings = false;\n        pingNextNum = -1;\n        rpc.cancel();\n    }\n\n    this.close = function (code, reason) {\n        Logger.debug(\"Closing  with code: \" + code + \" because: \" + reason);\n        if (pingInterval != undefined) {\n            Logger.debug(\"Clearing ping interval\");\n            clearInterval(pingInterval);\n        }\n        pingPongStarted = false;\n        enabledPings = false;\n        ws.close(code, reason);\n    }\n\n    this.reconnect = function () {\n        ws.reconnectWs();\n    }\n\n    this.resetPing = function () {\n        enabledPings = true;\n        pingNextNum = 0;\n        usePing();\n    }\n\n    this.getReadyState = function () {\n        return ws.getReadyState();\n    }\n}\n\n\nmodule.exports = JsonRpcClient;"]},"metadata":{},"sourceType":"script"}
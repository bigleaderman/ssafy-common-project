{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = void 0;\n\nvar Filter_1 = require(\"./Filter\");\n\nvar Subscriber_1 = require(\"./Subscriber\");\n\nvar WebRtcPeer_1 = require(\"../OpenViduInternal/WebRtcPeer/WebRtcPeer\");\n\nvar WebRtcStats_1 = require(\"../OpenViduInternal/WebRtcStats/WebRtcStats\");\n\nvar ExceptionEvent_1 = require(\"../OpenViduInternal/Events/ExceptionEvent\");\n\nvar PublisherSpeakingEvent_1 = require(\"../OpenViduInternal/Events/PublisherSpeakingEvent\");\n\nvar StreamManagerEvent_1 = require(\"../OpenViduInternal/Events/StreamManagerEvent\");\n\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\n\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\n\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar uuid_1 = require(\"uuid\");\n/**\n * @hidden\n */\n\n\nvar hark = require(\"hark\");\n/**\n * @hidden\n */\n\n\nvar EventEmitter = require(\"wolfy87-eventemitter\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each [[Publisher]] and [[Subscriber]] has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\n\nvar Stream =\n/** @class */\nfunction () {\n  /**\n   * @hidden\n   */\n  function Stream(session, options) {\n    var _this = this;\n\n    this.isSubscribeToRemote = false;\n    /**\n     * @hidden\n     */\n\n    this.isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n\n    this.isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n\n    this.publishedOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n\n    this.harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n\n    this.harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n\n    this.harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.ee = new EventEmitter();\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.session = session;\n\n    if (options.hasOwnProperty('id')) {\n      // InboundStreamOptions: stream belongs to a Subscriber\n      this.inboundStreamOpts = options;\n      this.streamId = this.inboundStreamOpts.id;\n      this.creationTime = this.inboundStreamOpts.createdAt;\n      this.hasAudio = this.inboundStreamOpts.hasAudio;\n      this.hasVideo = this.inboundStreamOpts.hasVideo;\n\n      if (this.hasAudio) {\n        this.audioActive = this.inboundStreamOpts.audioActive;\n      }\n\n      if (this.hasVideo) {\n        this.videoActive = this.inboundStreamOpts.videoActive;\n        this.typeOfVideo = !this.inboundStreamOpts.typeOfVideo ? undefined : this.inboundStreamOpts.typeOfVideo;\n        this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;\n        this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n      }\n\n      if (!!this.inboundStreamOpts.filter && Object.keys(this.inboundStreamOpts.filter).length > 0) {\n        if (!!this.inboundStreamOpts.filter.lastExecMethod && Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0) {\n          delete this.inboundStreamOpts.filter.lastExecMethod;\n        }\n\n        this.filter = this.inboundStreamOpts.filter;\n      }\n    } else {\n      // OutboundStreamOptions: stream belongs to a Publisher\n      this.outboundStreamOpts = options;\n      this.hasAudio = this.isSendAudio();\n      this.hasVideo = this.isSendVideo();\n\n      if (this.hasAudio) {\n        this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n      }\n\n      if (this.hasVideo) {\n        this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n        this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n\n        if (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n          this.typeOfVideo = TypeOfVideo_1.TypeOfVideo.CUSTOM;\n        } else {\n          this.typeOfVideo = this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n        }\n      }\n\n      if (!!this.outboundStreamOpts.publisherProperties.filter) {\n        this.filter = this.outboundStreamOpts.publisherProperties.filter;\n      }\n    }\n\n    this.ee.on('mediastream-updated', function () {\n      var _a;\n\n      _this.streamManager.updateMediaStream(_this.mediaStream);\n\n      logger.debug('Video srcObject [' + ((_a = _this.mediaStream) === null || _a === void 0 ? void 0 : _a.id) + '] updated in stream [' + _this.streamId + ']');\n    });\n  }\n  /**\n   * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n   * of a new one, that will apply the same properties.\n   *\n   * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n   * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n   */\n\n\n  Stream.prototype.reconnect = function () {\n    return this.reconnectStream('API');\n  };\n  /**\n   * Applies an audio/video filter to the stream.\n   *\n   * @param type Type of filter applied. See [[Filter.type]]\n   * @param options Parameters used to initialize the filter. See [[Filter.options]]\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n   */\n\n\n  Stream.prototype.applyFilter = function (type, options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveApplyFilter, openviduToken_1, tokenParams_1, afterScriptLoaded_1, script, optionsString;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          if (!!this.filter) {\n            return [2\n            /*return*/\n            , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId))];\n          }\n\n          resolveApplyFilter = function (error, triggerEvent) {\n            if (error) {\n              logger.error('Error applying filter for Stream ' + _this.streamId, error);\n\n              if (error.code === 401) {\n                return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\"));\n              } else {\n                return reject(error);\n              }\n            } else {\n              logger.info('Filter successfully applied on Stream ' + _this.streamId);\n              var oldValue = _this.filter;\n              _this.filter = new Filter_1.Filter(type, options);\n              _this.filter.stream = _this;\n\n              if (triggerEvent) {\n                _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n\n                _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n              }\n\n              return resolve(_this.filter);\n            }\n          };\n\n          if (type.startsWith('VB:')) {\n            // Client filters\n            if (!this.hasVideo) {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The Virtual Background filter requires a video track to be applied'))];\n            }\n\n            if (!this.mediaStream || this.streamManager.videos.length === 0) {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'))];\n            }\n\n            if (!!this.session.token) {\n              openviduToken_1 = this.session.token;\n            } else {\n              openviduToken_1 = options['token'];\n            }\n\n            if (!openviduToken_1) {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'))];\n            }\n\n            tokenParams_1 = this.session.getTokenParams(openviduToken_1);\n\n            if (tokenParams_1.edition !== 'pro' && tokenParams_1.edition !== 'enterprise') {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'))];\n            }\n\n            openviduToken_1 = encodeURIComponent(btoa(openviduToken_1));\n            logger.info('Applying Virtual Background to stream ' + this.streamId);\n\n            afterScriptLoaded_1 = function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                var id, mediaStreamClone, videoClone, VB, filteredVideo, _a, error_1;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0, 8,, 9]);\n\n                      id = this.streamId + '_' + (0, uuid_1.v4)();\n                      mediaStreamClone = this.mediaStream.clone();\n                      videoClone = this.streamManager.videos[0].video.cloneNode(false); // @ts-ignore\n\n                      videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                      videoClone.srcObject = mediaStreamClone;\n                      videoClone.muted = true;\n                      this.virtualBackgroundSourceElements = {\n                        videoClone: videoClone,\n                        mediaStreamClone: mediaStreamClone\n                      }; // @ts-ignore\n\n                      VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false); // @ts-ignore\n\n                      VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n                      return [4\n                      /*yield*/\n                      , videoClone.play()];\n\n                    case 1:\n                      _b.sent();\n\n                      VB = new VirtualBackground.VirtualBackground({\n                        id: id,\n                        openviduServerUrl: new URL(tokenParams_1.httpUri),\n                        openviduToken: openviduToken_1,\n                        inputVideo: videoClone,\n                        inputResolution: '160x96',\n                        outputFramerate: 24\n                      });\n                      filteredVideo = void 0;\n                      _a = type;\n\n                      switch (_a) {\n                        case 'VB:blur':\n                          return [3\n                          /*break*/\n                          , 2];\n\n                        case 'VB:image':\n                          return [3\n                          /*break*/\n                          , 4];\n                      }\n\n                      return [3\n                      /*break*/\n                      , 6];\n\n                    case 2:\n                      return [4\n                      /*yield*/\n                      , VB.backgroundBlur(options)];\n\n                    case 3:\n                      filteredVideo = _b.sent();\n                      return [3\n                      /*break*/\n                      , 7];\n\n                    case 4:\n                      return [4\n                      /*yield*/\n                      , VB.backgroundImage(options)];\n\n                    case 5:\n                      filteredVideo = _b.sent();\n                      return [3\n                      /*break*/\n                      , 7];\n\n                    case 6:\n                      throw new Error('Unknown Virtual Background filter: ' + type);\n\n                    case 7:\n                      this.virtualBackgroundSinkElements = {\n                        VB: VB,\n                        video: filteredVideo\n                      };\n                      videoClone.style.display = 'none';\n\n                      if (this.streamManager.remote) {\n                        this.streamManager.replaceTrackInMediaStream(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      } else {\n                        this.streamManager.replaceTrackAux(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      }\n\n                      resolveApplyFilter(undefined, false);\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 8:\n                      error_1 = _b.sent();\n\n                      if (error_1.name === OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                        resolveApplyFilter(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error_1.message), false);\n                      } else {\n                        resolveApplyFilter(error_1, false);\n                      }\n\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 9:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }; // @ts-ignore\n\n\n            if (typeof VirtualBackground === \"undefined\") {\n              script = document.createElement(\"script\");\n              script.type = \"text/javascript\";\n              script.src = tokenParams_1.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken_1;\n\n              script.onload = function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var error_2;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        _a.trys.push([0, 2,, 3]);\n\n                        return [4\n                        /*yield*/\n                        , afterScriptLoaded_1()];\n\n                      case 1:\n                        _a.sent();\n\n                        resolve(new Filter_1.Filter(type, options));\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 2:\n                        error_2 = _a.sent();\n                        reject(error_2);\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 3:\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n\n              document.body.appendChild(script);\n            } else {\n              afterScriptLoaded_1().then(function () {\n                return resolve(new Filter_1.Filter(type, options));\n              }).catch(function (error) {\n                return reject(error);\n              });\n            }\n          } else {\n            // Server filters\n            if (!this.session.sessionConnected()) {\n              return [2\n              /*return*/\n              , reject(this.session.notConnectedError())];\n            }\n\n            logger.info('Applying server filter to stream ' + this.streamId);\n            options = options != null ? options : {};\n            optionsString = options;\n\n            if (typeof optionsString !== 'string') {\n              optionsString = JSON.stringify(optionsString);\n            }\n\n            this.session.openvidu.sendRequest('applyFilter', {\n              streamId: this.streamId,\n              type: type,\n              options: optionsString\n            }, function (error, response) {\n              resolveApplyFilter(error, true);\n            });\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    });\n  };\n  /**\n   * Removes an audio/video filter previously applied.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n   */\n\n\n  Stream.prototype.removeFilter = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.removeFilterAux(false)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n   *\n   * @returns Native RTCPeerConnection Web API object\n   */\n\n\n  Stream.prototype.getRTCPeerConnection = function () {\n    return this.webRtcPeer.pc;\n  };\n  /**\n   * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n   *\n   * @returns Native MediaStream Web API object\n   */\n\n\n  Stream.prototype.getMediaStream = function () {\n    return this.mediaStream;\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.removeFilterAux = function (isDisposing) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveRemoveFilter, mediaStreamClone, error_3;\n\n        var _this = this;\n\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              resolveRemoveFilter = function (error, triggerEvent) {\n                if (error) {\n                  delete _this.filter;\n                  logger.error('Error removing filter for Stream ' + _this.streamId, error);\n\n                  if (error.code === 401) {\n                    return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\"));\n                  } else {\n                    return reject(error);\n                  }\n                } else {\n                  logger.info('Filter successfully removed from Stream ' + _this.streamId);\n                  var oldValue = _this.filter;\n                  delete _this.filter;\n\n                  if (triggerEvent) {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n\n                    _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                  }\n\n                  return resolve();\n                }\n              };\n\n              if (!!!this.filter) return [3\n              /*break*/\n              , 12];\n              if (!((_a = this.filter) === null || _a === void 0 ? void 0 : _a.type.startsWith('VB:'))) return [3\n              /*break*/\n              , 10];\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 8,, 9]);\n\n              mediaStreamClone = this.virtualBackgroundSourceElements.mediaStreamClone;\n              if (!!isDisposing) return [3\n              /*break*/\n              , 6];\n              if (!this.streamManager.remote) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false)];\n\n            case 2:\n              _b.sent();\n\n              return [3\n              /*break*/\n              , 5];\n\n            case 3:\n              return [4\n              /*yield*/\n              , this.streamManager.replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false)];\n\n            case 4:\n              _b.sent();\n\n              _b.label = 5;\n\n            case 5:\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              mediaStreamClone.getTracks().forEach(function (track) {\n                return track.stop();\n              });\n              _b.label = 7;\n\n            case 7:\n              this.virtualBackgroundSinkElements.VB.cleanUp();\n              delete this.virtualBackgroundSinkElements;\n              delete this.virtualBackgroundSourceElements;\n              return [2\n              /*return*/\n              , resolveRemoveFilter(undefined, false)];\n\n            case 8:\n              error_3 = _b.sent();\n              return [2\n              /*return*/\n              , resolveRemoveFilter(error_3, false)];\n\n            case 9:\n              return [3\n              /*break*/\n              , 11];\n\n            case 10:\n              // Server filters\n              if (!this.session.sessionConnected()) {\n                return [2\n                /*return*/\n                , reject(this.session.notConnectedError())];\n              }\n\n              logger.info('Removing filter of stream ' + this.streamId);\n              this.session.openvidu.sendRequest('removeFilter', {\n                streamId: this.streamId\n              }, function (error, response) {\n                return resolveRemoveFilter(error, true);\n              });\n              _b.label = 11;\n\n            case 11:\n              return [3\n              /*break*/\n              , 13];\n\n            case 12:\n              // There is no filter applied\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, \"Stream \" + this.streamId + \" has no filter applied\"))];\n\n            case 13:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.setMediaStream = function (mediaStream) {\n    this.mediaStream = mediaStream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.updateMediaStreamInVideos = function () {\n    this.ee.emitEvent('mediastream-updated', []);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getWebRtcPeer = function () {\n    return this.webRtcPeer;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.subscribeToMyRemote = function (value) {\n    this.isSubscribeToRemote = value;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.setOutboundStreamOptions = function (outboundStreamOpts) {\n    this.outboundStreamOpts = outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.subscribe = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.initWebRtcPeerReceive(false).then(function () {\n        return resolve();\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.publish = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocalStreamReadyToPublish) {\n        _this.initWebRtcPeerSend(false).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      } else {\n        _this.ee.once('stream-ready-to-publish', function () {\n          _this.publish().then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disposeWebRtcPeer = function () {\n    var webrtcId;\n\n    if (!!this.webRtcPeer) {\n      this.webRtcPeer.dispose();\n      webrtcId = this.webRtcPeer.getId();\n    }\n\n    this.stopWebRtcStats();\n    logger.info((!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') + \"RTCPeerConnection with id [\" + webrtcId + \"] from 'Stream' with id [\" + this.streamId + '] is now closed');\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disposeMediaStream = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(!!this.filter && this.filter.type.startsWith('VB:'))) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.removeFilterAux(true)];\n\n          case 2:\n            _a.sent();\n\n            console.debug(\"Success removing Virtual Background filter for stream \".concat(this.streamId));\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_4 = _a.sent();\n            console.error(\"Error removing Virtual Background filter for stream \".concat(this.streamId), error_4);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (this.mediaStream) {\n              this.mediaStream.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.mediaStream;\n            } // If subscribeToRemote local MediaStream must be stopped\n\n\n            if (this.localMediaStreamWhenSubscribedToRemote) {\n              this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.localMediaStreamWhenSubscribedToRemote;\n            }\n\n            if (!!this.speechEvent) {\n              if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n              }\n\n              delete this.speechEvent;\n            }\n\n            logger.info((!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed');\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.displayMyRemote = function () {\n    return this.isSubscribeToRemote;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isSendAudio = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.audioSource !== null && this.outboundStreamOpts.publisherProperties.audioSource !== false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isSendVideo = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.videoSource !== null && this.outboundStreamOpts.publisherProperties.videoSource !== false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isSendScreen = function () {\n    var screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n\n    if (platform.isElectron()) {\n      screen = typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' && this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n    }\n\n    return !!this.outboundStreamOpts && screen;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableHarkSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n      this.harkSpeakingEnabled = true;\n      this.speechEvent.on('speaking', function () {\n        _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n\n        _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n\n        _this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableOnceHarkSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = true;\n      this.speechEvent.once('speaking', function () {\n        if (_this.harkSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n\n          _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        }\n\n        _this.disableHarkSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disableHarkSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = false;\n\n      if (disabledByOnce) {\n        if (this.harkSpeakingEnabled) {\n          // The 'on' version of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkSpeakingEnabled = false;\n      } // Shutting down the hark event\n\n\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabled = true;\n      this.speechEvent.on('stopped_speaking', function () {\n        _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n\n        _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n\n        _this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableOnceHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = true;\n      this.speechEvent.once('stopped_speaking', function () {\n        if (_this.harkStoppedSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n\n          _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        }\n\n        _this.disableHarkStoppedSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n  * @hidden\n  */\n\n\n  Stream.prototype.disableHarkStoppedSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = false;\n\n      if (disabledByOnce) {\n        if (this.harkStoppedSpeakingEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkStoppedSpeakingEnabled = false;\n      } // Shutting down the hark event\n\n\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('stopped_speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabled || force) {\n        this.harkVolumeChangeEnabled = true;\n        this.speechEvent.on('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabled = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableOnceHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabledOnce || force) {\n        this.harkVolumeChangeEnabledOnce = true;\n        this.speechEvent.once('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n\n          _this.disableHarkVolumeChangeEvent(true);\n\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabledOnce = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disableHarkVolumeChangeEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkVolumeChangeEnabledOnce = false;\n\n      if (disabledByOnce) {\n        if (this.harkVolumeChangeEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkVolumeChangeEnabled = false;\n      } // Shutting down the hark event\n\n\n      if (this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('volume_change');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isLocal = function () {\n    // inbound options undefined and outbound options defined\n    return !this.inboundStreamOpts && !!this.outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getSelectedIceCandidate = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.webRtcStats.getSelectedIceCandidateInfo().then(function (report) {\n        return resolve(report);\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getRemoteIceCandidateList = function () {\n    return this.webRtcPeer.remoteCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getLocalIceCandidateList = function () {\n    return this.webRtcPeer.localCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.streamIceConnectionStateBroken = function () {\n    if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n      return false;\n    }\n\n    if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n      logger.warn(\"OpenVidu Browser advanced configuration option \\\"forceMediaReconnectionAfterNetworkDrop\\\" is enabled. Stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") will force a reconnection\"));\n      return true;\n    }\n\n    var iceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n    return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n  };\n  /* Private methods */\n\n\n  Stream.prototype.setHarkListenerIfNotExists = function () {\n    if (!!this.mediaStream) {\n      if (!this.speechEvent) {\n        var harkOptions = !!this.harkOptions ? this.harkOptions : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n        harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;\n        harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;\n        this.speechEvent = hark(this.mediaStream, harkOptions);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.setupReconnectionEventEmitter = function (resolve, reject) {\n    if (this.reconnectionEventEmitter == undefined) {\n      // There is no ongoing reconnection\n      this.reconnectionEventEmitter = new EventEmitter();\n      return false;\n    } else {\n      // Ongoing reconnection\n      console.warn(\"Trying to reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but an ongoing reconnection process is active. Waiting for response...\"));\n      this.reconnectionEventEmitter.once('success', function () {\n        return resolve();\n      });\n      this.reconnectionEventEmitter.once('error', function (error) {\n        return reject(error);\n      });\n      return true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerSend = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var _a;\n\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      } else {\n        // MediaStream will already have hark events for reconnected streams\n        _this.initHarkEvents(); // Init hark events for the local stream\n\n      }\n\n      var finalResolve = function () {\n        var _a;\n\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n          delete _this.reconnectionEventEmitter;\n        }\n\n        return resolve();\n      };\n\n      var finalReject = function (error) {\n        var _a;\n\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n          delete _this.reconnectionEventEmitter;\n        }\n\n        return reject(error);\n      };\n\n      var successOfferCallback = function (sdpOfferParam) {\n        logger.debug('Sending SDP offer to publish as ' + _this.streamId, sdpOfferParam);\n        var method = reconnect ? 'reconnectStream' : 'publishVideo';\n        var params;\n\n        if (reconnect) {\n          params = {\n            stream: _this.streamId,\n            sdpString: sdpOfferParam\n          };\n        } else {\n          var typeOfVideo = void 0;\n\n          if (_this.isSendVideo()) {\n            typeOfVideo = typeof MediaStreamTrack !== 'undefined' && _this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack ? TypeOfVideo_1.TypeOfVideo.CUSTOM : _this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n          }\n\n          params = {\n            doLoopback: _this.displayMyRemote() || false,\n            hasAudio: _this.isSendAudio(),\n            hasVideo: _this.isSendVideo(),\n            audioActive: _this.audioActive,\n            videoActive: _this.videoActive,\n            typeOfVideo: typeOfVideo,\n            frameRate: !!_this.frameRate ? _this.frameRate : -1,\n            videoDimensions: JSON.stringify(_this.videoDimensions),\n            filter: _this.outboundStreamOpts.publisherProperties.filter,\n            sdpOffer: sdpOfferParam\n          };\n        }\n\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            if (error.code === 401) {\n              finalReject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\"));\n            } else {\n              finalReject('Error on publishVideo: ' + JSON.stringify(error));\n            }\n          } else {\n            _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n              _this.streamId = response.id;\n              _this.creationTime = response.createdAt;\n              _this.isLocalStreamPublished = true;\n              _this.publishedOnce = true;\n\n              if (_this.displayMyRemote()) {\n                _this.localMediaStreamWhenSubscribedToRemote = _this.mediaStream;\n\n                _this.remotePeerSuccessfullyEstablished(reconnect);\n              }\n\n              if (reconnect) {\n                _this.ee.emitEvent('stream-reconnected-by-publisher', []);\n              } else {\n                _this.ee.emitEvent('stream-created-by-publisher', []);\n              }\n\n              _this.initWebRtcStats();\n\n              logger.info(\"'Publisher' (\" + _this.streamId + \") successfully \" + (reconnect ? \"reconnected\" : \"published\") + \" to session\");\n              finalResolve();\n            }).catch(function (error) {\n              finalReject(error);\n            });\n          }\n        });\n      };\n\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: (_a = _this.outboundStreamOpts.publisherProperties.videoSimulcast) !== null && _a !== void 0 ? _a : _this.session.openvidu.videoSimulcast,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: function (exceptionName, message, data) {\n          _this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(_this.session, exceptionName, _this, message, data)]);\n        },\n        iceServers: _this.getIceServersConf(),\n        mediaStream: _this.mediaStream,\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n\n      if (_this.session.openvidu.mediaServer !== 'mediasoup') {\n        // Simulcast is only supported by mediasoup\n        config.simulcast = false;\n      }\n\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n\n      if (_this.displayMyRemote()) {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendrecv(config);\n      } else {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendonly(config);\n      }\n\n      _this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + _this.connection.connectionId);\n\n      _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n        _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n          successOfferCallback(sdpOffer.sdp);\n        }).catch(function (error) {\n          finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n        });\n      }).catch(function (error) {\n        finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.finalResolveForSubscription = function (reconnect, resolve) {\n    var _a;\n\n    logger.info(\"'Subscriber' (\" + this.streamId + \") successfully \" + (reconnect ? \"reconnected\" : \"subscribed\"));\n    this.remotePeerSuccessfullyEstablished(reconnect);\n    this.initWebRtcStats();\n\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n      delete this.reconnectionEventEmitter;\n    }\n\n    return resolve();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.finalRejectForSubscription = function (reconnect, error, reject) {\n    var _a;\n\n    logger.error(\"Error for 'Subscriber' (\" + this.streamId + \") while trying to \" + (reconnect ? \"reconnect\" : \"subscribe\") + \": \" + error.toString());\n\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n      delete this.reconnectionEventEmitter;\n    }\n\n    return reject(error);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerReceive = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      }\n\n      if (_this.session.openvidu.mediaServer === 'mediasoup') {\n        // Server initiates negotiation\n        _this.initWebRtcPeerReceiveFromServer(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      } else {\n        // Client initiates negotiation\n        _this.initWebRtcPeerReceiveFromClient(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerReceiveFromClient = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.completeWebRtcPeerReceive(reconnect, false).then(function (response) {\n        _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerReceiveFromServer = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      // Server initiates negotiation\n      _this.session.openvidu.sendRequest('prepareReceiveVideoFrom', {\n        sender: _this.streamId,\n        reconnect: reconnect\n      }, function (error, response) {\n        if (error) {\n          return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n        } else {\n          _this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer).then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.completeWebRtcPeerReceive = function (reconnect, forciblyReconnect, sdpOfferByServer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      logger.debug(\"'Session.subscribe(Stream)' called\");\n\n      var sendSdpToServer = function (sdpString) {\n        logger.debug(\"Sending local SDP \".concat(!!sdpOfferByServer ? 'answer' : 'offer', \" to subscribe to \").concat(_this.streamId), sdpString);\n        var method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n        var params = {};\n        params[reconnect ? 'stream' : 'sender'] = _this.streamId;\n\n        if (!!sdpOfferByServer) {\n          params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n        } else {\n          params['sdpOffer'] = sdpString;\n        }\n\n        if (reconnect) {\n          params['forciblyReconnect'] = forciblyReconnect;\n        }\n\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n          } else {\n            return resolve(response);\n          }\n        });\n      };\n\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: false,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: function (exceptionName, message, data) {\n          _this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(_this.session, exceptionName, _this, message, data)]);\n        },\n        iceServers: _this.getIceServersConf(),\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n\n      _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerRecvonly(config);\n\n      _this.webRtcPeer.addIceConnectionStateChangeListener(_this.streamId);\n\n      if (!!sdpOfferByServer) {\n        _this.webRtcPeer.processRemoteOffer(sdpOfferByServer).then(function () {\n          _this.webRtcPeer.createAnswer().then(function (sdpAnswer) {\n            _this.webRtcPeer.processLocalAnswer(sdpAnswer).then(function () {\n              sendSdpToServer(sdpAnswer.sdp);\n            }).catch(function (error) {\n              return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n            });\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n        });\n      } else {\n        _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n          _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n            sendSdpToServer(sdpOffer.sdp);\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.remotePeerSuccessfullyEstablished = function (reconnect) {\n    if (reconnect && this.mediaStream != null) {\n      // Now we can destroy the existing MediaStream\n      this.disposeMediaStream();\n    }\n\n    this.mediaStream = new MediaStream();\n    var receiver;\n\n    for (var _i = 0, _a = this.webRtcPeer.pc.getReceivers(); _i < _a.length; _i++) {\n      receiver = _a[_i];\n\n      if (!!receiver.track) {\n        this.mediaStream.addTrack(receiver.track);\n      }\n    }\n\n    logger.debug('Peer remote stream', this.mediaStream);\n\n    if (!!this.mediaStream) {\n      if (this.streamManager instanceof Subscriber_1.Subscriber) {\n        // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n        if (!!this.mediaStream.getAudioTracks()[0]) {\n          var enabled = reconnect ? this.audioActive : !!this.streamManager.properties.subscribeToAudio;\n          this.mediaStream.getAudioTracks()[0].enabled = enabled;\n        }\n\n        if (!!this.mediaStream.getVideoTracks()[0]) {\n          var enabled = reconnect ? this.videoActive : !!this.streamManager.properties.subscribeToVideo;\n          this.mediaStream.getVideoTracks()[0].enabled = enabled;\n        }\n      }\n\n      this.updateMediaStreamInVideos();\n      this.initHarkEvents(); // Init hark events for the remote stream\n    }\n  };\n\n  Stream.prototype.initHarkEvents = function () {\n    if (!!this.mediaStream.getAudioTracks()[0]) {\n      // Hark events can only be set if audio track is available\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkSpeakingEvent();\n      }\n\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n        this.enableHarkSpeakingEvent();\n      }\n\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkStoppedSpeakingEvent();\n      }\n\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n        this.enableHarkStoppedSpeakingEvent();\n      }\n\n      if (this.harkVolumeChangeEnabledOnce) {\n        this.enableOnceHarkVolumeChangeEvent(true);\n      }\n\n      if (this.harkVolumeChangeEnabled) {\n        this.enableHarkVolumeChangeEvent(true);\n      }\n    }\n  };\n\n  Stream.prototype.onIceConnectionStateExceptionHandler = function (exceptionName, message, data) {\n    switch (exceptionName) {\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED:\n        this.onIceConnectionFailed();\n        break;\n\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n        this.onIceConnectionDisconnected();\n        break;\n    }\n\n    this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(this.session, exceptionName, this, message, data)]);\n  };\n\n  Stream.prototype.onIceConnectionFailed = function () {\n    // Immediately reconnect, as this is a terminal error\n    logger.log(\"[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \")\"));\n    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED);\n  };\n\n  Stream.prototype.onIceConnectionDisconnected = function () {\n    var _this = this; // Wait to see if the ICE connection is able to reconnect\n\n\n    logger.log(\"[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") if not possible\"));\n    var timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n    this.awaitWebRtcPeerConnectionState(timeout).then(function (state) {\n      switch (state) {\n        case 'failed':\n          // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") is now failed after ICE_CONNECTION_DISCONNECTED\"));\n          break;\n\n        case 'connected':\n        case 'completed':\n          logger.log(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: \").concat(state));\n          break;\n\n        case 'closed':\n        case 'checking':\n        case 'new':\n        case 'disconnected':\n          // Rest of states\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after \").concat(timeout, \" ms: \").concat(state));\n\n          _this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n\n          break;\n      }\n    });\n  };\n\n  Stream.prototype.reconnectStreamAndLogResultingIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var finalIceStateAfterReconnection, error_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.reconnectStreamAndReturnIceConnectionState(event)];\n\n          case 1:\n            finalIceStateAfterReconnection = _a.sent();\n\n            switch (finalIceStateAfterReconnection) {\n              case 'connected':\n              case 'completed':\n                logger.log(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") successfully reconnected after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n\n              default:\n                logger.error(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") failed to reconnect after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n            }\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_5 = _a.sent();\n            logger.error(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after \").concat(event, \": \").concat(error_5));\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.reconnectStreamAndReturnIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var timeout, error_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.log(\"[\".concat(event, \"] Reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after event \").concat(event));\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.reconnectStream(event)];\n\n          case 2:\n            _a.sent();\n\n            timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return [2\n            /*return*/\n            , this.awaitWebRtcPeerConnectionState(timeout)];\n\n          case 3:\n            error_6 = _a.sent();\n            logger.warn(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \"). Reason: \").concat(error_6));\n            return [2\n            /*return*/\n            , this.awaitWebRtcPeerConnectionState(1)];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.reconnectStream = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isWsConnected, errorMsg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isWebsocketConnected(event, 3000)];\n\n          case 1:\n            isWsConnected = _a.sent();\n\n            if (isWsConnected) {\n              // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n              logger.log(\"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") and the websocket is opened\"));\n\n              if (this.isLocal()) {\n                return [2\n                /*return*/\n                , this.initWebRtcPeerSend(true)];\n              } else {\n                return [2\n                /*return*/\n                , this.initWebRtcPeerReceive(true)];\n              }\n            } else {\n              errorMsg = \"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but the websocket wasn't opened\");\n              logger.error(errorMsg);\n              throw Error(errorMsg);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.isWebsocketConnected = function (event, msResponseTimeout) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var wsReadyState = _this.session.openvidu.getWsReadyState();\n\n      if (wsReadyState === 1) {\n        var responseTimeout_1 = setTimeout(function () {\n          console.warn(\"[\".concat(event, \"] Websocket timeout of \").concat(msResponseTimeout, \"ms\"));\n          return resolve(false);\n        }, msResponseTimeout);\n\n        _this.session.openvidu.sendRequest('echo', {}, function (error, response) {\n          clearTimeout(responseTimeout_1);\n\n          if (!!error) {\n            console.warn(\"[\".concat(event, \"] Websocket 'echo' returned error: \").concat(error));\n            return resolve(false);\n          } else {\n            return resolve(true);\n          }\n        });\n      } else {\n        console.warn(\"[\".concat(event, \"] Websocket readyState is \").concat(wsReadyState));\n        return resolve(false);\n      }\n    });\n  };\n\n  Stream.prototype.awaitWebRtcPeerConnectionState = function (timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      var state, interval, intervals, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            state = this.getRTCPeerConnection().iceConnectionState;\n            interval = 150;\n            intervals = Math.ceil(timeout / interval);\n            i = 0;\n            _a.label = 1;\n\n          case 1:\n            if (!(i < intervals)) return [3\n            /*break*/\n            , 4];\n            state = this.getRTCPeerConnection().iceConnectionState;\n\n            if (state === 'connected' || state === 'completed') {\n              return [3\n              /*break*/\n              , 4];\n            } // Sleep\n\n\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              return setTimeout(resolve, interval);\n            })];\n\n          case 2:\n            // Sleep\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , state];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcStats = function () {\n    this.webRtcStats = new WebRtcStats_1.WebRtcStats(this);\n    this.webRtcStats.initWebRtcStats(); //TODO: send common webrtc stats from client to openvidu-server\n\n    /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n        setInterval(() => {\n            this.gatherStatsForPeer().then(jsonStats => {\n                const body = {\n                    sessionId: this.session.sessionId,\n                    participantPrivateId: this.connection.rpcSessionId,\n                    stats: jsonStats\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                xhr.setRequestHeader('Content-Type', 'application/json');\n                xhr.send(JSON.stringify(body));\n            })\n        }, this.session.openvidu.webrtcStatsInterval * 1000);\n    }*/\n  };\n\n  Stream.prototype.stopWebRtcStats = function () {\n    if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n      this.webRtcStats.stopWebRtcStats();\n    }\n  };\n\n  Stream.prototype.getIceServersConf = function () {\n    var returnValue;\n\n    if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n      returnValue = this.session.openvidu.advancedConfiguration.iceServers === 'freeice' ? undefined : this.session.openvidu.advancedConfiguration.iceServers;\n    } else if (this.session.openvidu.iceServers) {\n      returnValue = this.session.openvidu.iceServers;\n    } else {\n      returnValue = undefined;\n    }\n\n    return returnValue;\n  };\n\n  Stream.prototype.gatherStatsForPeer = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocal()) {\n        // Publisher stream stats\n        _this.getRTCPeerConnection().getSenders().forEach(function (sender) {\n          return sender.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id; // Common to Chrome, Firefox and Safari\n\n                if (report.type === 'outbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum; // Set media type\n\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesEncoded'] = report.framesEncoded;\n                  }\n\n                  finalReport['packetsSent'] = report.packetsSent;\n                  finalReport['bytesSent'] = report.bytesSent;\n                } // Only for Chrome and Safari\n\n\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                } // Only for Firefox >= 66.0\n\n\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      } else {\n        // Subscriber stream stats\n        _this.getRTCPeerConnection().getReceivers().forEach(function (receiver) {\n          return receiver.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id; // Common to Chrome, Firefox and Safari\n\n                if (report.type === 'inbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum; // Set media type\n\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesDecoded'] = report.framesDecoded;\n                  }\n\n                  finalReport['packetsReceived'] = report.packetsReceived;\n                  finalReport['packetsLost'] = report.packetsLost;\n                  finalReport['jitter'] = report.jitter;\n                  finalReport['bytesReceived'] = report.bytesReceived;\n                } // Only for Chrome and Safari\n\n\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                } // Only for Firefox >= 66.0\n\n\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      }\n    });\n  };\n\n  Stream.prototype.isReportWanted = function (report) {\n    return report.type === 'inbound-rtp' && !this.isLocal() || report.type === 'outbound-rtp' && this.isLocal() || report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0;\n  };\n\n  return Stream;\n}();\n\nexports.Stream = Stream;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","session","options","EventEmitter","Platform_1","hasOwnProperty","inboundStreamOpts","streamId","id","creationTime","createdAt","hasAudio","hasVideo","audioActive","videoActive","typeOfVideo","undefined","frameRate","videoDimensions","filter","Object","keys","length","lastExecMethod","outboundStreamOpts","isSendAudio","isSendVideo","publisherProperties","publishAudio","publishVideo","MediaStreamTrack","videoSource","TypeOfVideo_1","CUSTOM","isSendScreen","SCREEN","CAMERA","ee","on","_this","streamManager","updateMediaStream","mediaStream","debug","_a","Stream","reconnectStream","type","Promise","resolve","reject","OpenViduError_1","GENERIC_ERROR","resolveApplyFilter","error","triggerEvent","code","OPENVIDU_PERMISSION_DENIED","info","oldValue","Filter_1","stream","emitEvent","StreamPropertyChangedEvent_1","startsWith","VIRTUAL_BACKGROUND_ERROR","videos","token","openviduToken_1","tokenParams_1","getTokenParams","edition","encodeURIComponent","btoa","afterScriptLoaded_1","mediaStreamClone","clone","videoClone","video","cloneNode","VirtualBackground","SOURCE_VIDEO_PREFIX","srcObject","muted","virtualBackgroundSourceElements","hideHtmlElement","appendHtmlElementToHiddenContainer","play","_b","VB","openviduServerUrl","URL","httpUri","openviduToken","inputVideo","inputResolution","outputFramerate","filteredVideo","backgroundBlur","backgroundImage","Error","virtualBackgroundSinkElements","style","display","remote","replaceTrackInMediaStream","getVideoTracks","replaceTrackAux","error_1","name","message","script","document","createElement","src","onload","error_2","body","appendChild","then","catch","sessionConnected","notConnectedError","optionsString","JSON","stringify","openvidu","sendRequest","response","removeFilterAux","webRtcPeer","pc","isDisposing","resolveRemoveFilter","getTracks","forEach","track","stop","cleanUp","error_3","value","isSubscribeToRemote","initWebRtcPeerReceive","isLocalStreamReadyToPublish","initWebRtcPeerSend","once","publish","webrtcId","dispose","getId","stopWebRtcStats","console","error_4","getAudioTracks","localMediaStreamWhenSubscribedToRemote","speechEvent","audioSource","screen","isElectron","setHarkListenerIfNotExists","harkSpeakingEnabled","PublisherSpeakingEvent_1","connection","harkSpeakingEnabledOnce","disableHarkSpeakingEvent","disabledByOnce","harkVolumeChangeEnabled","harkVolumeChangeEnabledOnce","harkStoppedSpeakingEnabled","harkStoppedSpeakingEnabledOnce","off","disableHarkStoppedSpeakingEvent","force","oldVolumeValue","newValue","harkEvent","StreamManagerEvent_1","disableHarkVolumeChangeEvent","webRtcStats","getSelectedIceCandidateInfo","report","remoteCandidatesQueue","localCandidatesQueue","getWebRtcPeer","getRTCPeerConnection","isLocal","advancedConfiguration","forceMediaReconnectionAfterNetworkDrop","warn","concat","iceConnectionState","harkOptions","publisherSpeakingEventsOptions","interval","threshold","hark","reconnectionEventEmitter","reconnect","setupReconnectionEventEmitter","initHarkEvents","finalResolve","finalReject","successOfferCallback","sdpOfferParam","method","params","sdpString","doLoopback","displayMyRemote","sdpOffer","processRemoteAnswer","sdpAnswer","isLocalStreamPublished","publishedOnce","remotePeerSuccessfullyEstablished","initWebRtcStats","config","mediaConstraints","audio","simulcast","videoSimulcast","onIceCandidate","sendIceCandidate","bind","onIceConnectionStateException","exceptionName","data","ExceptionEvent_1","iceServers","getIceServersConf","mediaServer","disposeWebRtcPeer","WebRtcPeer_1","addIceConnectionStateChangeListener","connectionId","createOffer","processLocalOffer","sdp","toString","initWebRtcPeerReceiveFromServer","finalResolveForSubscription","finalRejectForSubscription","initWebRtcPeerReceiveFromClient","completeWebRtcPeerReceive","sender","forciblyReconnect","sdpOfferByServer","sendSdpToServer","processRemoteOffer","createAnswer","processLocalAnswer","disposeMediaStream","MediaStream","receiver","getReceivers","_i","addTrack","Subscriber_1","enabled","properties","subscribeToAudio","subscribeToVideo","updateMediaStreamInVideos","anySpeechEventListenerEnabled","enableOnceHarkSpeakingEvent","enableHarkSpeakingEvent","enableOnceHarkStoppedSpeakingEvent","enableHarkStoppedSpeakingEvent","enableOnceHarkVolumeChangeEvent","enableHarkVolumeChangeEvent","ICE_CONNECTION_FAILED","onIceConnectionFailed","ICE_CONNECTION_DISCONNECTED","onIceConnectionDisconnected","log","reconnectStreamAndLogResultingIceConnectionState","timeout","iceConnectionDisconnectedExceptionTimeout","awaitWebRtcPeerConnectionState","state","event","reconnectStreamAndReturnIceConnectionState","finalIceStateAfterReconnection","error_5","error_6","isWebsocketConnected","isWsConnected","errorMsg","msResponseTimeout","wsReadyState","getWsReadyState","responseTimeout_1","setTimeout","clearTimeout","intervals","Math","ceil","i","WebRtcStats_1","isEnabled","returnValue","getSenders","getStats","isReportWanted","finalReport","timestamp","ssrc","firCount","pliCount","nackCount","qpSum","kind","mediaType","indexOf","framesEncoded","packetsSent","bytesSent","totalRoundTripTime","availableOutgoingBitrate","currentRoundTripTime","responsesReceived","framesDecoded","packetsReceived","packetsLost","jitter","bytesReceived","availableIncomingBitrate","nominated","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenVidu\\Stream.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Connection } from './Connection';\nimport { Filter } from './Filter';\nimport { Publisher } from './Publisher';\nimport { Session } from './Session';\nimport { StreamManager } from './StreamManager';\nimport { Subscriber } from './Subscriber';\nimport { InboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/InboundStreamOptions';\nimport { OutboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/OutboundStreamOptions';\nimport { WebRtcPeer, WebRtcPeerSendonly, WebRtcPeerRecvonly, WebRtcPeerSendrecv, WebRtcPeerConfiguration } from '../OpenViduInternal/WebRtcPeer/WebRtcPeer';\nimport { WebRtcStats } from '../OpenViduInternal/WebRtcStats/WebRtcStats';\nimport { ExceptionEvent, ExceptionEventName } from '../OpenViduInternal/Events/ExceptionEvent';\nimport { PublisherSpeakingEvent } from '../OpenViduInternal/Events/PublisherSpeakingEvent';\nimport { StreamManagerEvent } from '../OpenViduInternal/Events/StreamManagerEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\n\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * @hidden\n */\nimport hark = require('hark');\n/**\n * @hidden\n */\nimport EventEmitter = require('wolfy87-eventemitter');\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each [[Publisher]] and [[Subscriber]] has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\nexport class Stream {\n\n    /**\n     * The Connection object that is publishing the stream\n     */\n    connection: Connection;\n\n    /**\n     * Frame rate of the video in frames per second. This property is only defined if the [[Publisher]] of\n     * the stream was initialized passing a _frameRate_ property on [[OpenVidu.initPublisher]] method\n     */\n    frameRate?: number;\n\n    /**\n     * Whether the stream has a video track or not\n     */\n    hasVideo: boolean;\n\n    /**\n     * Whether the stream has an audio track or not\n     */\n    hasAudio: boolean;\n\n    /**\n     * Whether the stream has the video track muted or unmuted. If [[hasVideo]] is false, this property is undefined.\n     *\n     * This property may change if the Publisher publishing the stream calls [[Publisher.publishVideo]]. Whenever this happens a [[StreamPropertyChangedEvent]] will be dispatched\n     * by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    videoActive: boolean;\n\n    /**\n     * Whether the stream has the audio track muted or unmuted. If [[hasAudio]] is false, this property is undefined\n     *\n     * This property may change if the Publisher publishing the stream calls [[Publisher.publishAudio]]. Whenever this happens a [[StreamPropertyChangedEvent]] will be dispatched\n     * by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    audioActive: boolean;\n\n    /**\n     * Unique identifier of the stream. If the stream belongs to a...\n     * - Subscriber object: property `streamId` is always defined\n     * - Publisher object: property `streamId` is only defined after successful execution of [[Session.publish]]\n     */\n    streamId: string;\n\n    /**\n     * Time when this stream was created in OpenVidu Server (UTC milliseconds). Depending on the owner of this stream:\n     * - Subscriber object: property `creationTime` is always defined\n     * - Publisher object: property `creationTime` is only defined after successful execution of [[Session.publish]]\n     */\n    creationTime: number;\n\n    /**\n     * Can be:\n     * - `\"CAMERA\"`: when the video source comes from a webcam.\n     * - `\"SCREEN\"`: when the video source comes from screen-sharing.\n     * - `\"CUSTOM\"`: when [[PublisherProperties.videoSource]] has been initialized in the Publisher side with a custom MediaStreamTrack when calling [[OpenVidu.initPublisher]]).\n     * - `\"IPCAM\"`: when the video source comes from an IP camera participant instead of a regular participant (see [IP cameras](/en/stable/advanced-features/ip-cameras/)).\n     *\n     * If [[hasVideo]] is false, this property is undefined\n     */\n    typeOfVideo?: keyof typeof TypeOfVideo; // TODO: Change this type to enum TypeOfVideo on the next breaking-change release\n\n    /**\n     * StreamManager object ([[Publisher]] or [[Subscriber]]) in charge of displaying this stream in the DOM\n     */\n    streamManager: StreamManager;\n\n    /**\n     * Width and height in pixels of the encoded video stream. If [[hasVideo]] is false, this property is undefined\n     *\n     * This property may change if the Publisher that is publishing:\n     * - If it is a mobile device, whenever the user rotates the device.\n     * - If it is screen-sharing, whenever the user changes the size of the captured window.\n     *\n     * Whenever this happens a [[StreamPropertyChangedEvent]] will be dispatched by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    videoDimensions: { width: number, height: number };\n\n    /**\n     * **WARNING**: experimental option. This interface may change in the near future\n     *\n     * Filter applied to the Stream. You can apply filters by calling [[Stream.applyFilter]], execute methods of the applied filter with\n     * [[Filter.execMethod]] and remove it with [[Stream.removeFilter]]. Be aware that the client calling this methods must have the\n     * necessary permissions: the token owned by the client must have been initialized with the appropriated `allowedFilters` array.\n     */\n    filter?: Filter;\n\n    protected webRtcPeer: WebRtcPeer;\n    protected mediaStream?: MediaStream;\n    private webRtcStats: WebRtcStats;\n\n    private isSubscribeToRemote = false;\n\n    private virtualBackgroundSourceElements?: { videoClone: HTMLVideoElement, mediaStreamClone: MediaStream };\n    /**\n     * @hidden\n     */\n    virtualBackgroundSinkElements?: { VB: any, video: HTMLVideoElement };\n\n    /**\n     * @hidden\n     */\n    isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n    isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n    publishedOnce = false;\n    /**\n     * @hidden\n     */\n    session: Session;\n    /**\n     * @hidden\n     */\n    inboundStreamOpts: InboundStreamOptions;\n    /**\n     * @hidden\n     */\n    outboundStreamOpts: OutboundStreamOptions;\n    /**\n     * @hidden\n     */\n    speechEvent: any;\n    /**\n     * @hidden\n     */\n    harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n    harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkOptions;\n    /**\n     * @hidden\n     */\n    localMediaStreamWhenSubscribedToRemote?: MediaStream;\n    /**\n     * @hidden\n     */\n    ee = new EventEmitter();\n    /**\n     * @hidden\n     */\n    reconnectionEventEmitter: EventEmitter | undefined;\n    /**\n     * @hidden\n     */\n    lastVideoTrackConstraints: MediaTrackConstraints | boolean | undefined;\n    /**\n     * @hidden\n     */\n    lastVBFilter?: Filter;\n\n\n    /**\n     * @hidden\n     */\n    constructor(session: Session, options: InboundStreamOptions | OutboundStreamOptions | {}) {\n\n        platform = PlatformUtils.getInstance();\n        this.session = session;\n\n        if (options.hasOwnProperty('id')) {\n            // InboundStreamOptions: stream belongs to a Subscriber\n            this.inboundStreamOpts = <InboundStreamOptions>options;\n            this.streamId = this.inboundStreamOpts.id;\n            this.creationTime = this.inboundStreamOpts.createdAt;\n            this.hasAudio = this.inboundStreamOpts.hasAudio;\n            this.hasVideo = this.inboundStreamOpts.hasVideo;\n            if (this.hasAudio) {\n                this.audioActive = this.inboundStreamOpts.audioActive;\n            }\n            if (this.hasVideo) {\n                this.videoActive = this.inboundStreamOpts.videoActive;\n                this.typeOfVideo = (!this.inboundStreamOpts.typeOfVideo) ? undefined : this.inboundStreamOpts.typeOfVideo;\n                this.frameRate = (this.inboundStreamOpts.frameRate === -1) ? undefined : this.inboundStreamOpts.frameRate;\n                this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n            }\n            if (!!this.inboundStreamOpts.filter && (Object.keys(this.inboundStreamOpts.filter).length > 0)) {\n                if (!!this.inboundStreamOpts.filter.lastExecMethod && Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0) {\n                    delete this.inboundStreamOpts.filter.lastExecMethod;\n                }\n                this.filter = this.inboundStreamOpts.filter;\n            }\n        } else {\n            // OutboundStreamOptions: stream belongs to a Publisher\n            this.outboundStreamOpts = <OutboundStreamOptions>options;\n\n            this.hasAudio = this.isSendAudio();\n            this.hasVideo = this.isSendVideo();\n\n            if (this.hasAudio) {\n                this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n            }\n            if (this.hasVideo) {\n                this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n                this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n                if (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n                    this.typeOfVideo = TypeOfVideo.CUSTOM;\n                } else {\n                    this.typeOfVideo = this.isSendScreen() ? TypeOfVideo.SCREEN : TypeOfVideo.CAMERA;\n                }\n            }\n            if (!!this.outboundStreamOpts.publisherProperties.filter) {\n                this.filter = this.outboundStreamOpts.publisherProperties.filter;\n            }\n        }\n\n        this.ee.on('mediastream-updated', () => {\n            this.streamManager.updateMediaStream(this.mediaStream!);\n            logger.debug('Video srcObject [' + this.mediaStream?.id + '] updated in stream [' + this.streamId + ']');\n        });\n    }\n\n\n    /**\n     * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n     * of a new one, that will apply the same properties.\n     *\n     * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n     * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n     */\n    public reconnect(): Promise<void> {\n        return this.reconnectStream('API');\n    }\n\n    /**\n     * Applies an audio/video filter to the stream.\n     *\n     * @param type Type of filter applied. See [[Filter.type]]\n     * @param options Parameters used to initialize the filter. See [[Filter.options]]\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n     */\n    applyFilter(type: string, options: Object): Promise<Filter> {\n        return new Promise(async (resolve, reject) => {\n\n            if (!!this.filter) {\n                return reject(new OpenViduError(OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId));\n            }\n\n            const resolveApplyFilter = (error, triggerEvent) => {\n                if (error) {\n                    logger.error('Error applying filter for Stream ' + this.streamId, error);\n                    if (error.code === 401) {\n                        return reject(new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\"));\n                    } else {\n                        return reject(error);\n                    }\n                } else {\n                    logger.info('Filter successfully applied on Stream ' + this.streamId);\n                    const oldValue: Filter = this.filter!;\n                    this.filter = new Filter(type, options);\n                    this.filter.stream = this;\n                    if (triggerEvent) {\n                        this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this.session, this, 'filter', this.filter, oldValue, 'applyFilter')]);\n                        this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this.streamManager, this, 'filter', this.filter, oldValue, 'applyFilter')]);\n                    }\n                    return resolve(this.filter);\n                }\n            }\n\n            if (type.startsWith('VB:')) {\n\n                // Client filters\n\n                if (!this.hasVideo) {\n                    return reject(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The Virtual Background filter requires a video track to be applied'));\n                }\n                if (!this.mediaStream || this.streamManager.videos.length === 0) {\n                    return reject(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'));\n                }\n\n                let openviduToken: string;\n                if (!!this.session.token) {\n                    openviduToken = this.session.token;\n                } else {\n                    openviduToken = options['token'];\n                }\n                if (!openviduToken) {\n                    return reject(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'));\n                }\n\n                const tokenParams = this.session.getTokenParams(openviduToken);\n                if (tokenParams.edition !== 'pro' && tokenParams.edition !== 'enterprise') {\n                    return reject(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'));\n                }\n\n                openviduToken = encodeURIComponent(btoa(openviduToken));\n\n                logger.info('Applying Virtual Background to stream ' + this.streamId);\n\n                const afterScriptLoaded = async () => {\n                    try {\n                        const id = this.streamId + '_' + uuidv4();\n                        const mediaStreamClone = this.mediaStream!.clone();\n                        const videoClone = this.streamManager.videos[0].video.cloneNode(false) as HTMLVideoElement;\n                        // @ts-ignore\n                        videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                        videoClone.srcObject = mediaStreamClone;\n                        videoClone.muted = true;\n                        this.virtualBackgroundSourceElements = { videoClone, mediaStreamClone };\n\n                        // @ts-ignore\n                        VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false);\n                        // @ts-ignore\n                        VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n\n                        await videoClone.play();\n\n                        // @ts-ignore\n                        const VB = new VirtualBackground.VirtualBackground({\n                            id,\n                            openviduServerUrl: new URL(tokenParams.httpUri),\n                            openviduToken,\n                            inputVideo: videoClone,\n                            inputResolution: '160x96',\n                            outputFramerate: 24\n                        });\n\n                        let filteredVideo: HTMLVideoElement;\n                        switch (type) {\n                            case 'VB:blur': {\n                                filteredVideo = await VB.backgroundBlur(options);\n                                break;\n                            }\n                            case 'VB:image': {\n                                filteredVideo = await VB.backgroundImage(options);\n                                break;\n                            }\n                            default:\n                                throw new Error('Unknown Virtual Background filter: ' + type);\n                        }\n\n                        this.virtualBackgroundSinkElements = { VB, video: filteredVideo };\n\n                        videoClone.style.display = 'none';\n\n                        if (this.streamManager.remote) {\n                            this.streamManager.replaceTrackInMediaStream((this.virtualBackgroundSinkElements.video.srcObject as MediaStream).getVideoTracks()[0], false);\n                        } else {\n                            (this.streamManager as Publisher).replaceTrackAux((this.virtualBackgroundSinkElements.video.srcObject as MediaStream).getVideoTracks()[0], false);\n                        }\n\n                        resolveApplyFilter(undefined, false);\n\n                    } catch (error) {\n                        if (error.name === OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                            resolveApplyFilter(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error.message), false);\n                        } else {\n                            resolveApplyFilter(error, false);\n                        }\n                    }\n                }\n\n                // @ts-ignore\n                if (typeof VirtualBackground === \"undefined\") {\n                    let script: HTMLScriptElement = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = tokenParams.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken;\n                    script.onload = async () => {\n                        try {\n                            await afterScriptLoaded();\n                            resolve(new Filter(type, options));\n                        } catch (error) {\n                            reject(error);\n                        }\n                    };\n                    document.body.appendChild(script);\n                } else {\n                    afterScriptLoaded()\n                        .then(() => resolve(new Filter(type, options)))\n                        .catch(error => reject(error));\n                }\n\n            } else {\n\n                // Server filters\n\n                if (!this.session.sessionConnected()) {\n                    return reject(this.session.notConnectedError());\n                }\n\n                logger.info('Applying server filter to stream ' + this.streamId);\n                options = options != null ? options : {};\n                let optionsString = options;\n                if (typeof optionsString !== 'string') {\n                    optionsString = JSON.stringify(optionsString);\n                }\n                this.session.openvidu.sendRequest(\n                    'applyFilter',\n                    { streamId: this.streamId, type, options: optionsString },\n                    (error, response) => {\n                        resolveApplyFilter(error, true);\n                    }\n                );\n\n            }\n\n        });\n    }\n\n    /**\n     * Removes an audio/video filter previously applied.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n     */\n    async removeFilter(): Promise<void> {\n        return await this.removeFilterAux(false);\n    }\n\n    /**\n     * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n     *\n     * @returns Native RTCPeerConnection Web API object\n     */\n    getRTCPeerConnection(): RTCPeerConnection {\n        return this.webRtcPeer.pc;\n    }\n\n    /**\n     * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n     *\n     * @returns Native MediaStream Web API object\n     */\n    getMediaStream(): MediaStream {\n        return this.mediaStream!;\n    }\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    removeFilterAux(isDisposing: boolean): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n\n            const resolveRemoveFilter = (error, triggerEvent) => {\n                if (error) {\n                    delete this.filter;\n                    logger.error('Error removing filter for Stream ' + this.streamId, error);\n                    if (error.code === 401) {\n                        return reject(new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\"));\n                    } else {\n                        return reject(error);\n                    }\n                } else {\n                    logger.info('Filter successfully removed from Stream ' + this.streamId);\n                    const oldValue = this.filter!;\n                    delete this.filter;\n                    if (triggerEvent) {\n                        this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this.session, this, 'filter', this.filter!, oldValue, 'applyFilter')]);\n                        this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this.streamManager, this, 'filter', this.filter!, oldValue, 'applyFilter')]);\n                    }\n                    return resolve();\n                }\n            }\n\n            if (!!this.filter) {\n\n                // There is a filter applied\n\n                if (this.filter?.type.startsWith('VB:')) {\n\n                    // Client filters\n\n                    try {\n\n                        const mediaStreamClone = this.virtualBackgroundSourceElements!.mediaStreamClone;\n                        if (!isDisposing) {\n                            if (this.streamManager.remote) {\n                                await this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false);\n                            } else {\n                                await (this.streamManager as Publisher).replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false);\n                            }\n                        } else {\n                            mediaStreamClone.getTracks().forEach((track) => track.stop());\n                        }\n\n                        this.virtualBackgroundSinkElements!.VB.cleanUp();\n\n                        delete this.virtualBackgroundSinkElements;\n                        delete this.virtualBackgroundSourceElements;\n\n                        return resolveRemoveFilter(undefined, false);\n\n                    } catch (error) {\n                        return resolveRemoveFilter(error, false);\n                    }\n\n                } else {\n\n                    // Server filters\n\n                    if (!this.session.sessionConnected()) {\n                        return reject(this.session.notConnectedError());\n                    }\n\n                    logger.info('Removing filter of stream ' + this.streamId);\n                    this.session.openvidu.sendRequest(\n                        'removeFilter',\n                        { streamId: this.streamId },\n                        (error, response) => {\n                            return resolveRemoveFilter(error, true);\n                        }\n                    );\n\n                }\n            } else {\n\n                // There is no filter applied\n                return reject(new OpenViduError(OpenViduErrorName.GENERIC_ERROR, \"Stream \" + this.streamId + \" has no filter applied\"));\n\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    setMediaStream(mediaStream: MediaStream): void {\n        this.mediaStream = mediaStream;\n    }\n\n    /**\n     * @hidden\n     */\n    updateMediaStreamInVideos() {\n        this.ee.emitEvent('mediastream-updated', []);\n    }\n\n    /**\n     * @hidden\n     */\n    getWebRtcPeer(): WebRtcPeer {\n        return this.webRtcPeer;\n    }\n\n    /**\n     * @hidden\n     */\n    subscribeToMyRemote(value: boolean): void {\n        this.isSubscribeToRemote = value;\n    }\n\n    /**\n     * @hidden\n     */\n    setOutboundStreamOptions(outboundStreamOpts: OutboundStreamOptions): void {\n        this.outboundStreamOpts = outboundStreamOpts;\n    }\n\n    /**\n     * @hidden\n     */\n    subscribe(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.initWebRtcPeerReceive(false)\n                .then(() => resolve())\n                .catch(error => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    publish(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (this.isLocalStreamReadyToPublish) {\n                this.initWebRtcPeerSend(false)\n                    .then(() => resolve())\n                    .catch(error => reject(error));\n            } else {\n                this.ee.once('stream-ready-to-publish', () => {\n                    this.publish()\n                        .then(() => resolve())\n                        .catch(error => reject(error));\n                });\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    disposeWebRtcPeer(): void {\n        let webrtcId;\n        if (!!this.webRtcPeer) {\n            this.webRtcPeer.dispose();\n            webrtcId = this.webRtcPeer.getId();\n        }\n        this.stopWebRtcStats();\n        logger.info((!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') + \"RTCPeerConnection with id [\" + webrtcId + \"] from 'Stream' with id [\" + this.streamId + '] is now closed');\n    }\n\n    /**\n     * @hidden\n     */\n    async disposeMediaStream(): Promise<void> {\n        if (!!this.filter && this.filter.type.startsWith('VB:')) {\n            try {\n                await this.removeFilterAux(true);\n                console.debug(`Success removing Virtual Background filter for stream ${this.streamId}`);\n            } catch (error) {\n                console.error(`Error removing Virtual Background filter for stream ${this.streamId}`, error);\n            }\n        }\n        if (this.mediaStream) {\n            this.mediaStream.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this.mediaStream.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n            delete this.mediaStream;\n        }\n        // If subscribeToRemote local MediaStream must be stopped\n        if (this.localMediaStreamWhenSubscribedToRemote) {\n            this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n            delete this.localMediaStreamWhenSubscribedToRemote;\n        }\n        if (!!this.speechEvent) {\n            if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n            }\n            delete this.speechEvent;\n        }\n        logger.info((!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed');\n    }\n\n    /**\n     * @hidden\n     */\n    displayMyRemote(): boolean {\n        return this.isSubscribeToRemote;\n    }\n\n    /**\n     * @hidden\n     */\n    isSendAudio(): boolean {\n        return (!!this.outboundStreamOpts &&\n            this.outboundStreamOpts.publisherProperties.audioSource !== null &&\n            this.outboundStreamOpts.publisherProperties.audioSource !== false);\n    }\n\n    /**\n     * @hidden\n     */\n    isSendVideo(): boolean {\n        return (!!this.outboundStreamOpts &&\n            this.outboundStreamOpts.publisherProperties.videoSource !== null &&\n            this.outboundStreamOpts.publisherProperties.videoSource !== false);\n    }\n\n    /**\n     * @hidden\n     */\n    isSendScreen(): boolean {\n        let screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n        if (platform.isElectron()) {\n            screen = typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' &&\n                this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n        }\n        return !!this.outboundStreamOpts && screen;\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n            this.harkSpeakingEnabled = true;\n            this.speechEvent.on('speaking', () => {\n                this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)]);\n                this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)]);\n                this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n            this.harkSpeakingEnabledOnce = true;\n            this.speechEvent.once('speaking', () => {\n                if (this.harkSpeakingEnabledOnce) {\n                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n                    this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)]);\n                    this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)]);\n                }\n                this.disableHarkSpeakingEvent(true);\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkSpeakingEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkSpeakingEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkSpeakingEnabled) {\n                    // The 'on' version of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkSpeakingEnabled = false;\n            }\n            // Shutting down the hark event\n            if (this.harkVolumeChangeEnabled ||\n                this.harkVolumeChangeEnabledOnce ||\n                this.harkStoppedSpeakingEnabled ||\n                this.harkStoppedSpeakingEnabledOnce) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('speaking');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkStoppedSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n            this.harkStoppedSpeakingEnabled = true;\n            this.speechEvent.on('stopped_speaking', () => {\n                this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)]);\n                this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)]);\n                this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkStoppedSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n            this.harkStoppedSpeakingEnabledOnce = true;\n            this.speechEvent.once('stopped_speaking', () => {\n                if (this.harkStoppedSpeakingEnabledOnce) {\n                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n                    this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)]);\n                    this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)]);\n                }\n                this.disableHarkStoppedSpeakingEvent(true);\n            });\n        }\n    }\n\n    /**\n    * @hidden\n    */\n    disableHarkStoppedSpeakingEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkStoppedSpeakingEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkStoppedSpeakingEnabled) {\n                    // We are cancelling the 'once' listener for this event, but the 'on' version\n                    // of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkStoppedSpeakingEnabled = false;\n            }\n            // Shutting down the hark event\n            if (this.harkVolumeChangeEnabled ||\n                this.harkVolumeChangeEnabledOnce ||\n                this.harkSpeakingEnabled ||\n                this.harkSpeakingEnabledOnce) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('stopped_speaking');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkVolumeChangeEvent(force: boolean): void {\n        if (this.setHarkListenerIfNotExists()) {\n            if (!this.harkVolumeChangeEnabled || force) {\n                this.harkVolumeChangeEnabled = true;\n                this.speechEvent.on('volume_change', harkEvent => {\n                    const oldValue = this.speechEvent.oldVolumeValue;\n                    const value = { newValue: harkEvent, oldValue };\n                    this.speechEvent.oldVolumeValue = harkEvent;\n                    this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)]);\n                });\n            }\n        } else {\n            // This way whenever the MediaStream object is available, the event listener will be automatically added\n            this.harkVolumeChangeEnabled = true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkVolumeChangeEvent(force: boolean): void {\n        if (this.setHarkListenerIfNotExists()) {\n            if (!this.harkVolumeChangeEnabledOnce || force) {\n                this.harkVolumeChangeEnabledOnce = true;\n                this.speechEvent.once('volume_change', harkEvent => {\n                    const oldValue = this.speechEvent.oldVolumeValue;\n                    const value = { newValue: harkEvent, oldValue };\n                    this.speechEvent.oldVolumeValue = harkEvent;\n                    this.disableHarkVolumeChangeEvent(true);\n                    this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)]);\n                });\n            }\n        } else {\n            // This way whenever the MediaStream object is available, the event listener will be automatically added\n            this.harkVolumeChangeEnabledOnce = true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkVolumeChangeEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkVolumeChangeEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkVolumeChangeEnabled) {\n                    // We are cancelling the 'once' listener for this event, but the 'on' version\n                    // of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkVolumeChangeEnabled = false;\n            }\n            // Shutting down the hark event\n            if (this.harkSpeakingEnabled ||\n                this.harkSpeakingEnabledOnce ||\n                this.harkStoppedSpeakingEnabled ||\n                this.harkStoppedSpeakingEnabledOnce) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('volume_change');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    isLocal(): boolean {\n        // inbound options undefined and outbound options defined\n        return (!this.inboundStreamOpts && !!this.outboundStreamOpts);\n    }\n\n    /**\n     * @hidden\n     */\n    getSelectedIceCandidate(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.webRtcStats.getSelectedIceCandidateInfo()\n                .then(report => resolve(report))\n                .catch(error => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    getRemoteIceCandidateList(): RTCIceCandidate[] {\n        return this.webRtcPeer.remoteCandidatesQueue;\n    }\n\n    /**\n     * @hidden\n     */\n    getLocalIceCandidateList(): RTCIceCandidate[] {\n        return this.webRtcPeer.localCandidatesQueue;\n    }\n\n    /**\n     * @hidden\n     */\n    streamIceConnectionStateBroken() {\n        if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n            return false;\n        }\n        if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n            logger.warn(`OpenVidu Browser advanced configuration option \"forceMediaReconnectionAfterNetworkDrop\" is enabled. Stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) will force a reconnection`);\n            return true;\n        }\n        const iceConnectionState: RTCIceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n        return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n    }\n\n    /* Private methods */\n\n    private setHarkListenerIfNotExists(): boolean {\n        if (!!this.mediaStream) {\n            if (!this.speechEvent) {\n                const harkOptions = !!this.harkOptions ? this.harkOptions : (this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {});\n                harkOptions.interval = (typeof harkOptions.interval === 'number') ? harkOptions.interval : 100;\n                harkOptions.threshold = (typeof harkOptions.threshold === 'number') ? harkOptions.threshold : -50;\n                this.speechEvent = hark(this.mediaStream, harkOptions);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @hidden\n     */\n    setupReconnectionEventEmitter(resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void): boolean {\n        if (this.reconnectionEventEmitter == undefined) {\n            // There is no ongoing reconnection\n            this.reconnectionEventEmitter = new EventEmitter();\n            return false;\n        } else {\n            // Ongoing reconnection\n            console.warn(`Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'}) but an ongoing reconnection process is active. Waiting for response...`);\n            this.reconnectionEventEmitter.once('success', () => resolve());\n            this.reconnectionEventEmitter.once('error', error => reject(error));\n            return true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerSend(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            if (reconnect) {\n                if (this.setupReconnectionEventEmitter(resolve, reject)) {\n                    // Ongoing reconnection\n                    return;\n                }\n            } else {\n                // MediaStream will already have hark events for reconnected streams\n                this.initHarkEvents(); // Init hark events for the local stream\n            }\n\n            const finalResolve = () => {\n                if (reconnect) {\n                    this.reconnectionEventEmitter?.emitEvent('success');\n                    delete this.reconnectionEventEmitter;\n                }\n                return resolve();\n            }\n\n            const finalReject = error => {\n                if (reconnect) {\n                    this.reconnectionEventEmitter?.emitEvent('error', [error]);\n                    delete this.reconnectionEventEmitter;\n                }\n                return reject(error);\n            }\n\n            const successOfferCallback = (sdpOfferParam) => {\n                logger.debug('Sending SDP offer to publish as '\n                    + this.streamId, sdpOfferParam);\n\n                const method = reconnect ? 'reconnectStream' : 'publishVideo';\n                let params;\n                if (reconnect) {\n                    params = {\n                        stream: this.streamId,\n                        sdpString: sdpOfferParam\n                    }\n                } else {\n                    let typeOfVideo;\n                    if (this.isSendVideo()) {\n                        typeOfVideo = (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) ? TypeOfVideo.CUSTOM : (this.isSendScreen() ? TypeOfVideo.SCREEN : TypeOfVideo.CAMERA);\n                    }\n                    params = {\n                        doLoopback: this.displayMyRemote() || false,\n                        hasAudio: this.isSendAudio(),\n                        hasVideo: this.isSendVideo(),\n                        audioActive: this.audioActive,\n                        videoActive: this.videoActive,\n                        typeOfVideo,\n                        frameRate: !!this.frameRate ? this.frameRate : -1,\n                        videoDimensions: JSON.stringify(this.videoDimensions),\n                        filter: this.outboundStreamOpts.publisherProperties.filter,\n                        sdpOffer: sdpOfferParam\n                    }\n                }\n\n                this.session.openvidu.sendRequest(method, params, (error, response) => {\n                    if (error) {\n                        if (error.code === 401) {\n                            finalReject(new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\"));\n                        } else {\n                            finalReject('Error on publishVideo: ' + JSON.stringify(error));\n                        }\n                    } else {\n                        this.webRtcPeer.processRemoteAnswer(response.sdpAnswer)\n                            .then(() => {\n                                this.streamId = response.id;\n                                this.creationTime = response.createdAt;\n                                this.isLocalStreamPublished = true;\n                                this.publishedOnce = true;\n                                if (this.displayMyRemote()) {\n                                    this.localMediaStreamWhenSubscribedToRemote = this.mediaStream;\n                                    this.remotePeerSuccessfullyEstablished(reconnect);\n                                }\n                                if (reconnect) {\n                                    this.ee.emitEvent('stream-reconnected-by-publisher', []);\n                                } else {\n                                    this.ee.emitEvent('stream-created-by-publisher', []);\n                                }\n                                this.initWebRtcStats();\n                                logger.info(\"'Publisher' (\" + this.streamId + \") successfully \" + (reconnect ? \"reconnected\" : \"published\") + \" to session\");\n\n                                finalResolve();\n                            })\n                            .catch(error => {\n                                finalReject(error);\n                            });\n                    }\n                });\n            };\n\n            const config: WebRtcPeerConfiguration = {\n                mediaConstraints: {\n                    audio: this.hasAudio,\n                    video: this.hasVideo,\n                },\n                simulcast:\n                    this.outboundStreamOpts.publisherProperties.videoSimulcast ?? this.session.openvidu.videoSimulcast,\n                onIceCandidate: this.connection.sendIceCandidate.bind(this.connection),\n                onIceConnectionStateException: (exceptionName: ExceptionEventName, message: string, data?: any) => { this.session.emitEvent('exception', [new ExceptionEvent(this.session, exceptionName, this, message, data)]) },\n                iceServers: this.getIceServersConf(),\n                mediaStream: this.mediaStream,\n                mediaServer: this.session.openvidu.mediaServer,\n                typeOfVideo: this.typeOfVideo ? TypeOfVideo[this.typeOfVideo] : undefined,\n            };\n\n            if (this.session.openvidu.mediaServer !== 'mediasoup') {\n                // Simulcast is only supported by mediasoup\n                config.simulcast = false;\n            }\n\n            if (reconnect) {\n                this.disposeWebRtcPeer();\n            }\n            if (this.displayMyRemote()) {\n                this.webRtcPeer = new WebRtcPeerSendrecv(config);\n            } else {\n                this.webRtcPeer = new WebRtcPeerSendonly(config);\n            }\n            this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + this.connection.connectionId);\n            this.webRtcPeer.createOffer().then(sdpOffer => {\n                this.webRtcPeer.processLocalOffer(sdpOffer)\n                    .then(() => {\n                        successOfferCallback(sdpOffer.sdp);\n                    }).catch(error => {\n                        finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n                    });\n            }).catch(error => {\n                finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n            });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    finalResolveForSubscription(reconnect: boolean, resolve: (value: void | PromiseLike<void>) => void) {\n        logger.info(\"'Subscriber' (\" + this.streamId + \") successfully \" + (reconnect ? \"reconnected\" : \"subscribed\"));\n        this.remotePeerSuccessfullyEstablished(reconnect);\n        this.initWebRtcStats();\n        if (reconnect) {\n            this.reconnectionEventEmitter?.emitEvent('success');\n            delete this.reconnectionEventEmitter;\n        }\n        return resolve();\n    }\n\n    /**\n     * @hidden\n     */\n    finalRejectForSubscription(reconnect: boolean, error: any, reject: (reason?: any) => void) {\n        logger.error(\"Error for 'Subscriber' (\" + this.streamId + \") while trying to \" + (reconnect ? \"reconnect\" : \"subscribe\") + \": \" + error.toString());\n        if (reconnect) {\n            this.reconnectionEventEmitter?.emitEvent('error', [error]);\n            delete this.reconnectionEventEmitter;\n        }\n        return reject(error);\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceive(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            if (reconnect) {\n                if (this.setupReconnectionEventEmitter(resolve, reject)) {\n                    // Ongoing reconnection\n                    return;\n                }\n            }\n\n            if (this.session.openvidu.mediaServer === 'mediasoup') {\n\n                // Server initiates negotiation\n\n                this.initWebRtcPeerReceiveFromServer(reconnect)\n                    .then(() => this.finalResolveForSubscription(reconnect, resolve))\n                    .catch(error => this.finalRejectForSubscription(reconnect, error, reject));\n\n            } else {\n\n                // Client initiates negotiation\n\n                this.initWebRtcPeerReceiveFromClient(reconnect)\n                    .then(() => this.finalResolveForSubscription(reconnect, resolve))\n                    .catch(error => this.finalRejectForSubscription(reconnect, error, reject));\n\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceiveFromClient(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.completeWebRtcPeerReceive(reconnect, false)\n                .then(response => {\n                    this.webRtcPeer.processRemoteAnswer(response.sdpAnswer)\n                        .then(() => resolve())\n                        .catch(error => reject(error));\n                })\n                .catch(error => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceiveFromServer(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            // Server initiates negotiation\n            this.session.openvidu.sendRequest('prepareReceiveVideoFrom', { sender: this.streamId, reconnect }, (error, response) => {\n                if (error) {\n                    return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n                } else {\n                    this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer)\n                        .then(() => resolve())\n                        .catch(error => reject(error));\n                }\n            });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    completeWebRtcPeerReceive(reconnect: boolean, forciblyReconnect: boolean, sdpOfferByServer?: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n\n            logger.debug(\"'Session.subscribe(Stream)' called\");\n\n            const sendSdpToServer = (sdpString: string) => {\n\n                logger.debug(`Sending local SDP ${(!!sdpOfferByServer ? 'answer' : 'offer')} to subscribe to ${this.streamId}`, sdpString);\n\n                const method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n                const params = {};\n                params[reconnect ? 'stream' : 'sender'] = this.streamId;\n                if (!!sdpOfferByServer) {\n                    params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n                } else {\n                    params['sdpOffer'] = sdpString;\n                }\n                if (reconnect) {\n                    params['forciblyReconnect'] = forciblyReconnect;\n                }\n\n                this.session.openvidu.sendRequest(method, params, (error, response) => {\n                    if (error) {\n                        return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n                    } else {\n                        return resolve(response);\n                    }\n                });\n            };\n\n            const config: WebRtcPeerConfiguration = {\n                mediaConstraints: {\n                    audio: this.hasAudio,\n                    video: this.hasVideo,\n                },\n                simulcast: false,\n                onIceCandidate: this.connection.sendIceCandidate.bind(this.connection),\n                onIceConnectionStateException: (exceptionName: ExceptionEventName, message: string, data?: any) => { this.session.emitEvent('exception', [new ExceptionEvent(this.session, exceptionName, this, message, data)]) },\n                iceServers: this.getIceServersConf(),\n                mediaServer: this.session.openvidu.mediaServer,\n                typeOfVideo: this.typeOfVideo ? TypeOfVideo[this.typeOfVideo] : undefined,\n            };\n\n            if (reconnect) {\n                this.disposeWebRtcPeer();\n            }\n\n            this.webRtcPeer = new WebRtcPeerRecvonly(config);\n            this.webRtcPeer.addIceConnectionStateChangeListener(this.streamId);\n\n            if (!!sdpOfferByServer) {\n\n                this.webRtcPeer.processRemoteOffer(sdpOfferByServer).then(() => {\n                    this.webRtcPeer.createAnswer().then(sdpAnswer => {\n                        this.webRtcPeer.processLocalAnswer(sdpAnswer).then(() => {\n                            sendSdpToServer(sdpAnswer.sdp!);\n                        }).catch(error => {\n                            return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n                        });\n                    }).catch(error => {\n                        return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n                    });\n                }).catch(error => {\n                    return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n                });\n\n            } else {\n\n                this.webRtcPeer.createOffer().then(sdpOffer => {\n                    this.webRtcPeer.processLocalOffer(sdpOffer).then(() => {\n                        sendSdpToServer(sdpOffer.sdp!);\n                    }).catch(error => {\n                        return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n                    });\n                }).catch(error => {\n                    return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n                });\n\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    remotePeerSuccessfullyEstablished(reconnect: boolean): void {\n\n        if (reconnect && this.mediaStream != null) {\n            // Now we can destroy the existing MediaStream\n            this.disposeMediaStream();\n        }\n\n        this.mediaStream = new MediaStream();\n        let receiver: RTCRtpReceiver;\n        for (receiver of this.webRtcPeer.pc.getReceivers()) {\n            if (!!receiver.track) {\n                this.mediaStream.addTrack(receiver.track);\n            }\n        }\n        logger.debug('Peer remote stream', this.mediaStream);\n\n        if (!!this.mediaStream) {\n\n            if (this.streamManager instanceof Subscriber) {\n                // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n                if (!!this.mediaStream.getAudioTracks()[0]) {\n                    const enabled = reconnect ? this.audioActive : !!((this.streamManager as Subscriber).properties.subscribeToAudio);\n                    this.mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!this.mediaStream.getVideoTracks()[0]) {\n                    const enabled = reconnect ? this.videoActive : !!((this.streamManager as Subscriber).properties.subscribeToVideo);\n                    this.mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n            }\n\n            this.updateMediaStreamInVideos();\n            this.initHarkEvents(); // Init hark events for the remote stream\n        }\n    }\n\n    private initHarkEvents(): void {\n        if (!!this.mediaStream!.getAudioTracks()[0]) {\n            // Hark events can only be set if audio track is available\n            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n                this.enableOnceHarkSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n                this.enableHarkSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n                this.enableOnceHarkStoppedSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n                this.enableHarkStoppedSpeakingEvent();\n            }\n            if (this.harkVolumeChangeEnabledOnce) {\n                this.enableOnceHarkVolumeChangeEvent(true);\n            }\n            if (this.harkVolumeChangeEnabled) {\n                this.enableHarkVolumeChangeEvent(true);\n            }\n        }\n    }\n\n    private onIceConnectionStateExceptionHandler(exceptionName: ExceptionEventName, message: string, data?: any): void {\n        switch (exceptionName) {\n            case ExceptionEventName.ICE_CONNECTION_FAILED:\n                this.onIceConnectionFailed();\n                break;\n            case ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n                this.onIceConnectionDisconnected();\n                break;\n        }\n        this.session.emitEvent('exception', [new ExceptionEvent(this.session, exceptionName, this, message, data)]);\n    }\n\n    private onIceConnectionFailed() {\n        // Immediately reconnect, as this is a terminal error\n        logger.log(`[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')})`);\n        this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEventName.ICE_CONNECTION_FAILED);\n    }\n\n    private onIceConnectionDisconnected() {\n        // Wait to see if the ICE connection is able to reconnect\n        logger.log(`[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) if not possible`);\n        const timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n        this.awaitWebRtcPeerConnectionState(timeout).then(state => {\n            switch (state) {\n                case 'failed':\n                    // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n                    logger.warn(`[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) is now failed after ICE_CONNECTION_DISCONNECTED`);\n                    break;\n                case 'connected':\n                case 'completed':\n                    logger.log(`[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: ${state}`);\n                    break;\n                case 'closed':\n                case 'checking':\n                case 'new':\n                case 'disconnected':\n                    // Rest of states\n                    logger.warn(`[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after ${timeout} ms: ${state}`);\n                    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n                    break;\n            }\n        });\n    }\n\n    private async reconnectStreamAndLogResultingIceConnectionState(event: string) {\n        try {\n            const finalIceStateAfterReconnection = await this.reconnectStreamAndReturnIceConnectionState(event);\n            switch (finalIceStateAfterReconnection) {\n                case 'connected':\n                case 'completed':\n                    logger.log(`[${event}] Stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) successfully reconnected after ${event}. Current ICE connection state: ${finalIceStateAfterReconnection}`);\n                    break;\n                default:\n                    logger.error(`[${event}] Stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) failed to reconnect after ${event}. Current ICE connection state: ${finalIceStateAfterReconnection}`);\n                    break;\n            }\n        } catch (error) {\n            logger.error(`[${event}] Error reconnecting stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) after ${event}: ${error}`);\n        }\n    }\n\n    private async reconnectStreamAndReturnIceConnectionState(event: string): Promise<RTCIceConnectionState> {\n        logger.log(`[${event}] Reconnecting stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) after event ${event}`);\n        try {\n            await this.reconnectStream(event);\n            const timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return this.awaitWebRtcPeerConnectionState(timeout);\n        } catch (error) {\n            logger.warn(`[${event}] Error reconnecting stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}). Reason: ${error}`);\n            return this.awaitWebRtcPeerConnectionState(1);\n        }\n    }\n\n    private async reconnectStream(event: string) {\n        const isWsConnected = await this.isWebsocketConnected(event, 3000);\n        if (isWsConnected) {\n            // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n            logger.log(`[${event}] Trying to reconnect stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) and the websocket is opened`);\n            if (this.isLocal()) {\n                return this.initWebRtcPeerSend(true);\n            } else {\n                return this.initWebRtcPeerReceive(true);\n            }\n        } else {\n            // There is no connection to openvidu-server. Nothing can be done. The automatic reconnection\n            // feature should handle a possible reconnection of RTCPeerConnection in case network comes back\n            const errorMsg = `[${event}] Trying to reconnect stream ${this.streamId} (${(this.isLocal() ? 'Publisher' : 'Subscriber')}) but the websocket wasn't opened`;\n            logger.error(errorMsg);\n            throw Error(errorMsg);\n        }\n    }\n\n    private isWebsocketConnected(event: string, msResponseTimeout: number): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            const wsReadyState = this.session.openvidu.getWsReadyState();\n            if (wsReadyState === 1) {\n                const responseTimeout = setTimeout(() => {\n                    console.warn(`[${event}] Websocket timeout of ${msResponseTimeout}ms`);\n                    return resolve(false);\n                }, msResponseTimeout);\n                this.session.openvidu.sendRequest('echo', {}, (error, response) => {\n                    clearTimeout(responseTimeout);\n                    if (!!error) {\n                        console.warn(`[${event}] Websocket 'echo' returned error: ${error}`);\n                        return resolve(false);\n                    } else {\n                        return resolve(true);\n                    }\n                });\n            } else {\n                console.warn(`[${event}] Websocket readyState is ${wsReadyState}`);\n                return resolve(false);\n            }\n        });\n    }\n\n    private async awaitWebRtcPeerConnectionState(timeout: number): Promise<RTCIceConnectionState> {\n        let state = this.getRTCPeerConnection().iceConnectionState;\n        const interval = 150;\n        const intervals = Math.ceil(timeout / interval);\n        for (let i = 0; i < intervals; i++) {\n            state = this.getRTCPeerConnection().iceConnectionState;\n            if (state === 'connected' || state === 'completed') {\n                break;\n            }\n            // Sleep\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n        return state;\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcStats(): void {\n        this.webRtcStats = new WebRtcStats(this);\n        this.webRtcStats.initWebRtcStats();\n\n        //TODO: send common webrtc stats from client to openvidu-server\n        /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n            setInterval(() => {\n                this.gatherStatsForPeer().then(jsonStats => {\n                    const body = {\n                        sessionId: this.session.sessionId,\n                        participantPrivateId: this.connection.rpcSessionId,\n                        stats: jsonStats\n                    }\n                    var xhr = new XMLHttpRequest();\n                    xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                    xhr.setRequestHeader('Content-Type', 'application/json');\n                    xhr.send(JSON.stringify(body));\n                })\n            }, this.session.openvidu.webrtcStatsInterval * 1000);\n        }*/\n    }\n\n    private stopWebRtcStats(): void {\n        if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n            this.webRtcStats.stopWebRtcStats();\n        }\n    }\n\n    private getIceServersConf(): RTCIceServer[] | undefined {\n        let returnValue;\n        if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n            returnValue = this.session.openvidu.advancedConfiguration.iceServers === 'freeice' ?\n                undefined :\n                this.session.openvidu.advancedConfiguration.iceServers;\n        } else if (this.session.openvidu.iceServers) {\n            returnValue = this.session.openvidu.iceServers;\n        } else {\n            returnValue = undefined;\n        }\n        return returnValue;\n    }\n\n    private gatherStatsForPeer(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.isLocal()) {\n\n                // Publisher stream stats\n\n                this.getRTCPeerConnection().getSenders().forEach(sender => sender.getStats()\n                    .then(\n                        response => {\n                            response.forEach(report => {\n\n                                if (this.isReportWanted(report)) {\n\n                                    const finalReport = {};\n\n                                    finalReport['type'] = report.type;\n                                    finalReport['timestamp'] = report.timestamp;\n                                    finalReport['id'] = report.id;\n\n                                    // Common to Chrome, Firefox and Safari\n                                    if (report.type === 'outbound-rtp') {\n                                        finalReport['ssrc'] = report.ssrc;\n                                        finalReport['firCount'] = report.firCount;\n                                        finalReport['pliCount'] = report.pliCount;\n                                        finalReport['nackCount'] = report.nackCount;\n                                        finalReport['qpSum'] = report.qpSum;\n\n                                        // Set media type\n                                        if (!!report.kind) {\n                                            finalReport['mediaType'] = report.kind;\n                                        } else if (!!report.mediaType) {\n                                            finalReport['mediaType'] = report.mediaType;\n                                        } else {\n                                            // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                                            finalReport['mediaType'] = (report.id.indexOf('VideoStream') !== -1) ? 'video' : 'audio';\n                                        }\n\n                                        if (finalReport['mediaType'] === 'video') {\n                                            finalReport['framesEncoded'] = report.framesEncoded;\n                                        }\n\n                                        finalReport['packetsSent'] = report.packetsSent;\n                                        finalReport['bytesSent'] = report.bytesSent;\n                                    }\n\n                                    // Only for Chrome and Safari\n                                    if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                                        // This is the final selected candidate pair\n                                        finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                                        finalReport['rtt'] = report.currentRoundTripTime;\n                                        finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                                    }\n\n                                    // Only for Firefox >= 66.0\n                                    if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {\n\n                                    }\n\n                                    logger.log(finalReport);\n                                }\n                            });\n                        }));\n            } else {\n\n                // Subscriber stream stats\n\n                this.getRTCPeerConnection().getReceivers().forEach(receiver => receiver.getStats()\n                    .then(\n                        response => {\n                            response.forEach(report => {\n\n                                if (this.isReportWanted(report)) {\n\n                                    const finalReport = {};\n\n                                    finalReport['type'] = report.type;\n                                    finalReport['timestamp'] = report.timestamp;\n                                    finalReport['id'] = report.id;\n\n                                    // Common to Chrome, Firefox and Safari\n                                    if (report.type === 'inbound-rtp') {\n                                        finalReport['ssrc'] = report.ssrc;\n                                        finalReport['firCount'] = report.firCount;\n                                        finalReport['pliCount'] = report.pliCount;\n                                        finalReport['nackCount'] = report.nackCount;\n                                        finalReport['qpSum'] = report.qpSum;\n\n                                        // Set media type\n                                        if (!!report.kind) {\n                                            finalReport['mediaType'] = report.kind;\n                                        } else if (!!report.mediaType) {\n                                            finalReport['mediaType'] = report.mediaType;\n                                        } else {\n                                            // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                                            finalReport['mediaType'] = (report.id.indexOf('VideoStream') !== -1) ? 'video' : 'audio';\n                                        }\n\n                                        if (finalReport['mediaType'] === 'video') {\n                                            finalReport['framesDecoded'] = report.framesDecoded;\n                                        }\n\n                                        finalReport['packetsReceived'] = report.packetsReceived;\n                                        finalReport['packetsLost'] = report.packetsLost;\n                                        finalReport['jitter'] = report.jitter;\n                                        finalReport['bytesReceived'] = report.bytesReceived;\n                                    }\n\n                                    // Only for Chrome and Safari\n                                    if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                                        // This is the final selected candidate pair\n                                        finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                                        finalReport['rtt'] = report.currentRoundTripTime;\n                                        finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                                    }\n\n                                    // Only for Firefox >= 66.0\n                                    if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {\n\n                                    }\n                                    logger.log(finalReport);\n                                }\n                            })\n                        })\n                )\n            }\n        });\n    }\n\n    private isReportWanted(report: any): boolean {\n        return report.type === 'inbound-rtp' && !this.isLocal() ||\n            report.type === 'outbound-rtp' && this.isLocal() ||\n            (report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0);\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}
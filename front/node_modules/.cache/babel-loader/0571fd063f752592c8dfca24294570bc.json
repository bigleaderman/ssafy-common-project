{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamManager = void 0;\n\nvar EventDispatcher_1 = require(\"./EventDispatcher\");\n\nvar StreamManagerEvent_1 = require(\"../OpenViduInternal/Events/StreamManagerEvent\");\n\nvar VideoElementEvent_1 = require(\"../OpenViduInternal/Events/VideoElementEvent\");\n\nvar ExceptionEvent_1 = require(\"../OpenViduInternal/Events/ExceptionEvent\");\n\nvar VideoInsertMode_1 = require(\"../OpenViduInternal/Enums/VideoInsertMode\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Interface in charge of displaying the media streams in the HTML DOM. This wraps any [[Publisher]] and [[Subscriber]] object.\n * You can insert as many video players fo the same Stream as you want by calling [[StreamManager.addVideoElement]] or\n * [[StreamManager.createVideoElement]].\n * The use of StreamManager wrapper is particularly useful when you don't need to differentiate between Publisher or Subscriber streams or just\n * want to directly manage your own video elements (even more than one video element per Stream). This scenario is pretty common in\n * declarative, MVC frontend frameworks such as Angular, React or Vue.js\n *\n * See available event listeners at [[StreamManagerEventMap]].\n */\n\nvar StreamManager =\n/** @class */\nfunction (_super) {\n  __extends(StreamManager, _super);\n  /**\n   * @hidden\n   */\n\n\n  function StreamManager(stream, targetElement) {\n    var _this = _super.call(this) || this;\n    /**\n     * All the videos displaying the Stream of this Publisher/Subscriber\n     */\n\n\n    _this.videos = [];\n    /**\n     * @hidden\n     */\n\n    _this.lazyLaunchVideoElementCreatedEvent = false;\n    platform = Platform_1.PlatformUtils.getInstance();\n    _this.stream = stream;\n    _this.stream.streamManager = _this;\n    _this.remote = !_this.stream.isLocal();\n\n    if (!!targetElement) {\n      var targEl = void 0;\n\n      if (typeof targetElement === 'string') {\n        targEl = document.getElementById(targetElement);\n      } else if (targetElement instanceof HTMLElement) {\n        targEl = targetElement;\n      }\n\n      if (!!targEl) {\n        _this.firstVideoElement = {\n          targetElement: targEl,\n          video: document.createElement('video'),\n          id: '',\n          canplayListenerAdded: false\n        };\n\n        if (platform.isSafariBrowser() || platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser())) {\n          _this.firstVideoElement.video.setAttribute('playsinline', 'true');\n        }\n\n        _this.targetElement = targEl;\n        _this.element = targEl;\n      }\n    }\n\n    _this.canPlayListener = function () {\n      _this.deactivateStreamPlayingEventExceptionTimeout();\n\n      _this.ee.emitEvent('streamPlaying', [new StreamManagerEvent_1.StreamManagerEvent(_this, 'streamPlaying', undefined)]);\n    };\n\n    return _this;\n  }\n  /**\n   * See [[EventDispatcher.on]]\n   */\n\n\n  StreamManager.prototype.on = function (type, handler) {\n    _super.prototype.onAux.call(this, type, \"Event '\" + type + \"' triggered by '\" + (this.remote ? 'Subscriber' : 'Publisher') + \"'\", handler);\n\n    if (type === 'videoElementCreated') {\n      if (!!this.stream && this.lazyLaunchVideoElementCreatedEvent) {\n        this.ee.emitEvent('videoElementCreated', [new VideoElementEvent_1.VideoElementEvent(this.videos[0].video, this, 'videoElementCreated')]);\n        this.lazyLaunchVideoElementCreatedEvent = false;\n      }\n    }\n\n    if (type === 'streamPlaying') {\n      if (this.videos[0] && this.videos[0].video && this.videos[0].video.currentTime > 0 && this.videos[0].video.paused === false && this.videos[0].video.ended === false && this.videos[0].video.readyState === 4) {\n        this.ee.emitEvent('streamPlaying', [new StreamManagerEvent_1.StreamManagerEvent(this, 'streamPlaying', undefined)]);\n      }\n    }\n\n    if (this.stream.hasAudio) {\n      if (type === 'publisherStartSpeaking') {\n        this.stream.enableHarkSpeakingEvent();\n      }\n\n      if (type === 'publisherStopSpeaking') {\n        this.stream.enableHarkStoppedSpeakingEvent();\n      }\n\n      if (type === 'streamAudioVolumeChange') {\n        this.stream.enableHarkVolumeChangeEvent(false);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.once]]\n   */\n\n\n  StreamManager.prototype.once = function (type, handler) {\n    _super.prototype.onceAux.call(this, type, \"Event '\" + type + \"' triggered once by '\" + (this.remote ? 'Subscriber' : 'Publisher') + \"'\", handler);\n\n    if (type === 'videoElementCreated') {\n      if (!!this.stream && this.lazyLaunchVideoElementCreatedEvent) {\n        this.ee.emitEvent('videoElementCreated', [new VideoElementEvent_1.VideoElementEvent(this.videos[0].video, this, 'videoElementCreated')]);\n      }\n    }\n\n    if (type === 'streamPlaying') {\n      if (this.videos[0] && this.videos[0].video && this.videos[0].video.currentTime > 0 && this.videos[0].video.paused === false && this.videos[0].video.ended === false && this.videos[0].video.readyState === 4) {\n        this.ee.emitEvent('streamPlaying', [new StreamManagerEvent_1.StreamManagerEvent(this, 'streamPlaying', undefined)]);\n      }\n    }\n\n    if (this.stream.hasAudio) {\n      if (type === 'publisherStartSpeaking') {\n        this.stream.enableOnceHarkSpeakingEvent();\n      }\n\n      if (type === 'publisherStopSpeaking') {\n        this.stream.enableOnceHarkStoppedSpeakingEvent();\n      }\n\n      if (type === 'streamAudioVolumeChange') {\n        this.stream.enableOnceHarkVolumeChangeEvent(false);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.off]]\n   */\n\n\n  StreamManager.prototype.off = function (type, handler) {\n    _super.prototype.offAux.call(this, type, handler);\n\n    if (type === 'publisherStartSpeaking') {\n      // Both StreamManager and Session can have \"publisherStartSpeaking\" event listeners\n      var remainingStartSpeakingEventListeners = this.ee.getListeners(type).length + this.stream.session.ee.getListeners(type).length;\n\n      if (remainingStartSpeakingEventListeners === 0) {\n        this.stream.disableHarkSpeakingEvent(false);\n      }\n    }\n\n    if (type === 'publisherStopSpeaking') {\n      // Both StreamManager and Session can have \"publisherStopSpeaking\" event listeners\n      var remainingStopSpeakingEventListeners = this.ee.getListeners(type).length + this.stream.session.ee.getListeners(type).length;\n\n      if (remainingStopSpeakingEventListeners === 0) {\n        this.stream.disableHarkStoppedSpeakingEvent(false);\n      }\n    }\n\n    if (type === 'streamAudioVolumeChange') {\n      // Only StreamManager can have \"streamAudioVolumeChange\" event listeners\n      var remainingVolumeEventListeners = this.ee.getListeners(type).length;\n\n      if (remainingVolumeEventListeners === 0) {\n        this.stream.disableHarkVolumeChangeEvent(false);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Makes `video` element parameter display this [[stream]]. This is useful when you are\n   * [managing the video elements on your own](/en/stable/cheatsheet/manage-videos/#you-take-care-of-the-video-players)\n   *\n   * Calling this method with a video already added to other Publisher/Subscriber will cause the video element to be\n   * disassociated from that previous Publisher/Subscriber and to be associated to this one.\n   *\n   * @returns 1 if the video wasn't associated to any other Publisher/Subscriber and has been successfully added to this one.\n   * 0 if the video was already added to this Publisher/Subscriber. -1 if the video was previously associated to any other\n   * Publisher/Subscriber and has been successfully disassociated from that one and properly added to this one.\n   */\n\n\n  StreamManager.prototype.addVideoElement = function (video) {\n    this.initializeVideoProperties(video);\n\n    if (!this.remote && this.stream.displayMyRemote()) {\n      if (video.srcObject !== this.stream.getMediaStream()) {\n        video.srcObject = this.stream.getMediaStream();\n      }\n    } // If the video element is already part of this StreamManager do nothing\n\n\n    for (var _i = 0, _a = this.videos; _i < _a.length; _i++) {\n      var v = _a[_i];\n\n      if (v.video === video) {\n        return 0;\n      }\n    }\n\n    var returnNumber = 1;\n\n    for (var _b = 0, _c = this.stream.session.streamManagers; _b < _c.length; _b++) {\n      var streamManager = _c[_b];\n\n      if (streamManager.disassociateVideo(video)) {\n        returnNumber = -1;\n        break;\n      }\n    }\n\n    this.stream.session.streamManagers.forEach(function (streamManager) {\n      streamManager.disassociateVideo(video);\n    });\n    this.pushNewStreamManagerVideo({\n      video: video,\n      id: video.id,\n      canplayListenerAdded: false\n    });\n    logger.info('New video element associated to ', this);\n    return returnNumber;\n  };\n  /**\n   * Creates a new video element displaying this [[stream]]. This allows you to have multiple video elements displaying the same media stream.\n   *\n   * #### Events dispatched\n   *\n   * The Publisher/Subscriber object will dispatch a `videoElementCreated` event once the HTML video element has been added to DOM. See [[VideoElementEvent]]\n   *\n   * @param targetElement HTML DOM element (or its `id` attribute) in which the video element of the Publisher/Subscriber will be inserted\n   * @param insertMode How the video element will be inserted accordingly to `targetElemet`\n   *\n   * @returns The created HTMLVideoElement\n   */\n\n\n  StreamManager.prototype.createVideoElement = function (targetElement, insertMode) {\n    var targEl;\n\n    if (typeof targetElement === 'string') {\n      targEl = document.getElementById(targetElement);\n\n      if (!targEl) {\n        throw new Error(\"The provided 'targetElement' couldn't be resolved to any HTML element: \" + targetElement);\n      }\n    } else if (targetElement instanceof HTMLElement) {\n      targEl = targetElement;\n    } else {\n      throw new Error(\"The provided 'targetElement' couldn't be resolved to any HTML element: \" + targetElement);\n    }\n\n    var video = this.createVideo();\n    this.initializeVideoProperties(video);\n    var insMode = !!insertMode ? insertMode : VideoInsertMode_1.VideoInsertMode.APPEND;\n\n    switch (insMode) {\n      case VideoInsertMode_1.VideoInsertMode.AFTER:\n        targEl.parentNode.insertBefore(video, targEl.nextSibling);\n        break;\n\n      case VideoInsertMode_1.VideoInsertMode.APPEND:\n        targEl.appendChild(video);\n        break;\n\n      case VideoInsertMode_1.VideoInsertMode.BEFORE:\n        targEl.parentNode.insertBefore(video, targEl);\n        break;\n\n      case VideoInsertMode_1.VideoInsertMode.PREPEND:\n        targEl.insertBefore(video, targEl.childNodes[0]);\n        break;\n\n      case VideoInsertMode_1.VideoInsertMode.REPLACE:\n        targEl.parentNode.replaceChild(video, targEl);\n        break;\n\n      default:\n        insMode = VideoInsertMode_1.VideoInsertMode.APPEND;\n        targEl.appendChild(video);\n        break;\n    }\n\n    var v = {\n      targetElement: targEl,\n      video: video,\n      insertMode: insMode,\n      id: video.id,\n      canplayListenerAdded: false\n    };\n    this.pushNewStreamManagerVideo(v);\n    this.ee.emitEvent('videoElementCreated', [new VideoElementEvent_1.VideoElementEvent(v.video, this, 'videoElementCreated')]);\n    this.lazyLaunchVideoElementCreatedEvent = !!this.firstVideoElement;\n    return video;\n  };\n  /**\n   * Updates the current configuration for the [[PublisherSpeakingEvent]] feature and the [StreamManagerEvent.streamAudioVolumeChange](/en/stable/api/openvidu-browser/classes/StreamManagerEvent.html) feature for this specific\n   * StreamManager audio stream, overriding the global options set with [[OpenVidu.setAdvancedConfiguration]]. This way you can customize the audio events options\n   * for each specific StreamManager and change them dynamically.\n   *\n   * @param publisherSpeakingEventsOptions New options to be applied to this StreamManager's audio stream. It is an object which includes the following optional properties:\n   * - `interval`: (number) how frequently the analyser polls the audio stream to check if speaking has started/stopped or audio volume has changed. Default **100** (ms)\n   * - `threshold`: (number) the volume at which _publisherStartSpeaking_, _publisherStopSpeaking_ events will be fired. Default **-50** (dB)\n   */\n\n\n  StreamManager.prototype.updatePublisherSpeakingEventsOptions = function (publisherSpeakingEventsOptions) {\n    var currentHarkOptions = !!this.stream.harkOptions ? this.stream.harkOptions : this.stream.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n    var newInterval = typeof publisherSpeakingEventsOptions.interval === 'number' ? publisherSpeakingEventsOptions.interval : typeof currentHarkOptions.interval === 'number' ? currentHarkOptions.interval : 100;\n    var newThreshold = typeof publisherSpeakingEventsOptions.threshold === 'number' ? publisherSpeakingEventsOptions.threshold : typeof currentHarkOptions.threshold === 'number' ? currentHarkOptions.threshold : -50;\n    this.stream.harkOptions = {\n      interval: newInterval,\n      threshold: newThreshold\n    };\n\n    if (!!this.stream.speechEvent) {\n      this.stream.speechEvent.setInterval(newInterval);\n      this.stream.speechEvent.setThreshold(newThreshold);\n    }\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.initializeVideoProperties = function (video) {\n    if (!(!this.remote && this.stream.displayMyRemote())) {\n      // Avoid setting the MediaStream into the srcObject if remote subscription before publishing\n      if (video.srcObject !== this.stream.getMediaStream()) {\n        // If srcObject already set don't do it again\n        video.srcObject = this.stream.getMediaStream();\n      }\n    }\n\n    video.autoplay = true;\n    video.controls = false;\n\n    if (platform.isSafariBrowser() || platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser())) {\n      video.setAttribute('playsinline', 'true');\n    }\n\n    if (!video.id) {\n      video.id = (this.remote ? 'remote-' : 'local-') + 'video-' + this.stream.streamId; // DEPRECATED property: assign once the property id if the user provided a valid targetElement\n\n      if (!this.id && !!this.targetElement) {\n        this.id = video.id;\n      }\n    }\n\n    if (this.remote && this.isMirroredVideo(video)) {\n      // Subscriber video associated to a previously mirrored video element\n      this.removeMirrorVideo(video);\n    } else if (!this.remote && !this.stream.displayMyRemote()) {\n      // Publisher video\n      video.muted = true;\n\n      if (this.isMirroredVideo(video) && !this.stream.outboundStreamOpts.publisherProperties.mirror) {\n        // If the video was already rotated and now is set to not mirror\n        this.removeMirrorVideo(video);\n      } else if (this.stream.outboundStreamOpts.publisherProperties.mirror && !this.stream.isSendScreen()) {\n        // If the video is now set to mirror and is not screen share\n        this.mirrorVideo(video);\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.removeAllVideos = function () {\n    var _this = this;\n\n    for (var i = this.stream.session.streamManagers.length - 1; i >= 0; --i) {\n      if (this.stream.session.streamManagers[i] === this) {\n        this.stream.session.streamManagers.splice(i, 1);\n      }\n    }\n\n    this.videos.forEach(function (streamManagerVideo) {\n      // Remove oncanplay event listener (only OpenVidu browser listener, not the user ones)\n      if (!!streamManagerVideo.video && !!streamManagerVideo.video.removeEventListener) {\n        streamManagerVideo.video.removeEventListener('canplay', _this.canPlayListener);\n      }\n\n      streamManagerVideo.canplayListenerAdded = false;\n\n      if (!!streamManagerVideo.targetElement) {\n        // Only remove from DOM videos created by OpenVidu Browser (those generated by passing a valid targetElement in OpenVidu.initPublisher\n        // and Session.subscribe or those created by StreamManager.createVideoElement). All this videos triggered a videoElementCreated event\n        streamManagerVideo.video.parentNode.removeChild(streamManagerVideo.video);\n\n        _this.ee.emitEvent('videoElementDestroyed', [new VideoElementEvent_1.VideoElementEvent(streamManagerVideo.video, _this, 'videoElementDestroyed')]);\n      } // Remove srcObject from the video\n\n\n      _this.removeSrcObject(streamManagerVideo); // Remove from collection of videos every video managed by OpenVidu Browser\n\n\n      _this.videos.filter(function (v) {\n        return !v.targetElement;\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.disassociateVideo = function (video) {\n    var disassociated = false;\n\n    for (var i = 0; i < this.videos.length; i++) {\n      if (this.videos[i].video === video) {\n        this.videos[i].video.removeEventListener('canplay', this.canPlayListener);\n        this.videos.splice(i, 1);\n        disassociated = true;\n        logger.info('Video element disassociated from ', this);\n        break;\n      }\n    }\n\n    return disassociated;\n  };\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.addPlayEventToFirstVideo = function () {\n    if (!!this.videos[0] && !!this.videos[0].video && !this.videos[0].canplayListenerAdded) {\n      this.activateStreamPlayingEventExceptionTimeout();\n      this.videos[0].video.addEventListener('canplay', this.canPlayListener);\n      this.videos[0].canplayListenerAdded = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.updateMediaStream = function (mediaStream) {\n    this.videos.forEach(function (streamManagerVideo) {\n      streamManagerVideo.video.srcObject = mediaStream;\n\n      if (platform.isIonicIos()) {\n        // iOS Ionic. LIMITATION: must reinsert the video in the DOM for\n        // the media stream to be updated\n        var vParent = streamManagerVideo.video.parentElement;\n        var newVideo = streamManagerVideo.video;\n        vParent.replaceChild(newVideo, streamManagerVideo.video);\n        streamManagerVideo.video = newVideo;\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.emitEvent = function (type, eventArray) {\n    this.ee.emitEvent(type, eventArray);\n  };\n  /**\n  * @hidden\n  */\n\n\n  StreamManager.prototype.createVideo = function () {\n    return document.createElement('video');\n  };\n  /**\n   * @hidden\n   */\n\n\n  StreamManager.prototype.removeSrcObject = function (streamManagerVideo) {\n    streamManagerVideo.video.srcObject = null;\n    this.deactivateStreamPlayingEventExceptionTimeout();\n  };\n  /* Private methods */\n\n\n  StreamManager.prototype.pushNewStreamManagerVideo = function (streamManagerVideo) {\n    this.videos.push(streamManagerVideo);\n    this.addPlayEventToFirstVideo();\n\n    if (this.stream.session.streamManagers.indexOf(this) === -1) {\n      this.stream.session.streamManagers.push(this);\n    }\n  };\n\n  StreamManager.prototype.mirrorVideo = function (video) {\n    if (!platform.isIonicIos()) {\n      video.style.transform = 'rotateY(180deg)';\n      video.style.webkitTransform = 'rotateY(180deg)';\n    }\n  };\n\n  StreamManager.prototype.removeMirrorVideo = function (video) {\n    video.style.transform = 'unset';\n    video.style.webkitTransform = 'unset';\n  };\n\n  StreamManager.prototype.isMirroredVideo = function (video) {\n    return video.style.transform === 'rotateY(180deg)' || video.style.webkitTransform === 'rotateY(180deg)';\n  };\n\n  StreamManager.prototype.activateStreamPlayingEventExceptionTimeout = function () {\n    var _this = this;\n\n    if (!this.remote) {\n      // ExceptionEvent NO_STREAM_PLAYING_EVENT is only for subscribers\n      return;\n    }\n\n    if (this.streamPlayingEventExceptionTimeout != null) {\n      // The timeout is already activated\n      return;\n    } // Trigger ExceptionEvent NO_STREAM_PLAYING_EVENT if after timeout there is no 'canplay' event\n\n\n    var msTimeout = this.stream.session.openvidu.advancedConfiguration.noStreamPlayingEventExceptionTimeout || 4000;\n    this.streamPlayingEventExceptionTimeout = setTimeout(function () {\n      var msg = 'StreamManager of Stream ' + _this.stream.streamId + ' (' + (_this.remote ? 'Subscriber' : 'Publisher') + ') did not trigger \"streamPlaying\" event in ' + msTimeout + ' ms';\n      logger.warn(msg);\n\n      _this.stream.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(_this.stream.session, ExceptionEvent_1.ExceptionEventName.NO_STREAM_PLAYING_EVENT, _this, msg)]);\n\n      delete _this.streamPlayingEventExceptionTimeout;\n    }, msTimeout);\n  };\n\n  StreamManager.prototype.deactivateStreamPlayingEventExceptionTimeout = function () {\n    clearTimeout(this.streamPlayingEventExceptionTimeout);\n    delete this.streamPlayingEventExceptionTimeout;\n  };\n\n  return StreamManager;\n}(EventDispatcher_1.EventDispatcher);\n\nexports.StreamManager = StreamManager;","map":null,"metadata":{},"sourceType":"script"}
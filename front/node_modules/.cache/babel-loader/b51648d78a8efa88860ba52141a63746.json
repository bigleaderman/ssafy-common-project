{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = void 0;\n\nvar Filter_1 = require(\"./Filter\");\n\nvar Subscriber_1 = require(\"./Subscriber\");\n\nvar WebRtcPeer_1 = require(\"../OpenViduInternal/WebRtcPeer/WebRtcPeer\");\n\nvar WebRtcStats_1 = require(\"../OpenViduInternal/WebRtcStats/WebRtcStats\");\n\nvar ExceptionEvent_1 = require(\"../OpenViduInternal/Events/ExceptionEvent\");\n\nvar PublisherSpeakingEvent_1 = require(\"../OpenViduInternal/Events/PublisherSpeakingEvent\");\n\nvar StreamManagerEvent_1 = require(\"../OpenViduInternal/Events/StreamManagerEvent\");\n\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\n\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\n\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar uuid_1 = require(\"uuid\");\n/**\n * @hidden\n */\n\n\nvar hark = require(\"hark\");\n/**\n * @hidden\n */\n\n\nvar EventEmitter = require(\"wolfy87-eventemitter\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each [[Publisher]] and [[Subscriber]] has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\n\nvar Stream =\n/** @class */\nfunction () {\n  /**\n   * @hidden\n   */\n  function Stream(session, options) {\n    var _this = this;\n\n    this.isSubscribeToRemote = false;\n    /**\n     * @hidden\n     */\n\n    this.isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n\n    this.isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n\n    this.publishedOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n\n    this.harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n\n    this.harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n\n    this.harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n\n    this.ee = new EventEmitter();\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.session = session;\n\n    if (options.hasOwnProperty('id')) {\n      // InboundStreamOptions: stream belongs to a Subscriber\n      this.inboundStreamOpts = options;\n      this.streamId = this.inboundStreamOpts.id;\n      this.creationTime = this.inboundStreamOpts.createdAt;\n      this.hasAudio = this.inboundStreamOpts.hasAudio;\n      this.hasVideo = this.inboundStreamOpts.hasVideo;\n\n      if (this.hasAudio) {\n        this.audioActive = this.inboundStreamOpts.audioActive;\n      }\n\n      if (this.hasVideo) {\n        this.videoActive = this.inboundStreamOpts.videoActive;\n        this.typeOfVideo = !this.inboundStreamOpts.typeOfVideo ? undefined : this.inboundStreamOpts.typeOfVideo;\n        this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;\n        this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n      }\n\n      if (!!this.inboundStreamOpts.filter && Object.keys(this.inboundStreamOpts.filter).length > 0) {\n        if (!!this.inboundStreamOpts.filter.lastExecMethod && Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0) {\n          delete this.inboundStreamOpts.filter.lastExecMethod;\n        }\n\n        this.filter = this.inboundStreamOpts.filter;\n      }\n    } else {\n      // OutboundStreamOptions: stream belongs to a Publisher\n      this.outboundStreamOpts = options;\n      this.hasAudio = this.isSendAudio();\n      this.hasVideo = this.isSendVideo();\n\n      if (this.hasAudio) {\n        this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n      }\n\n      if (this.hasVideo) {\n        this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n        this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n\n        if (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n          this.typeOfVideo = TypeOfVideo_1.TypeOfVideo.CUSTOM;\n        } else {\n          this.typeOfVideo = this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n        }\n      }\n\n      if (!!this.outboundStreamOpts.publisherProperties.filter) {\n        this.filter = this.outboundStreamOpts.publisherProperties.filter;\n      }\n    }\n\n    this.ee.on('mediastream-updated', function () {\n      var _a;\n\n      _this.streamManager.updateMediaStream(_this.mediaStream);\n\n      logger.debug('Video srcObject [' + ((_a = _this.mediaStream) === null || _a === void 0 ? void 0 : _a.id) + '] updated in stream [' + _this.streamId + ']');\n    });\n  }\n  /**\n   * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n   * of a new one, that will apply the same properties.\n   *\n   * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n   * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n   */\n\n\n  Stream.prototype.reconnect = function () {\n    return this.reconnectStream('API');\n  };\n  /**\n   * Applies an audio/video filter to the stream.\n   *\n   * @param type Type of filter applied. See [[Filter.type]]\n   * @param options Parameters used to initialize the filter. See [[Filter.options]]\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n   */\n\n\n  Stream.prototype.applyFilter = function (type, options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveApplyFilter, openviduToken_1, tokenParams_1, afterScriptLoaded_1, script, optionsString;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          if (!!this.filter) {\n            return [2\n            /*return*/\n            , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId))];\n          }\n\n          resolveApplyFilter = function resolveApplyFilter(error, triggerEvent) {\n            if (error) {\n              logger.error('Error applying filter for Stream ' + _this.streamId, error);\n\n              if (error.code === 401) {\n                return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\"));\n              } else {\n                return reject(error);\n              }\n            } else {\n              logger.info('Filter successfully applied on Stream ' + _this.streamId);\n              var oldValue = _this.filter;\n              _this.filter = new Filter_1.Filter(type, options);\n              _this.filter.stream = _this;\n\n              if (triggerEvent) {\n                _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n\n                _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n              }\n\n              return resolve(_this.filter);\n            }\n          };\n\n          if (type.startsWith('VB:')) {\n            // Client filters\n            if (!this.hasVideo) {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The Virtual Background filter requires a video track to be applied'))];\n            }\n\n            if (!this.mediaStream || this.streamManager.videos.length === 0) {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'))];\n            }\n\n            if (!!this.session.token) {\n              openviduToken_1 = this.session.token;\n            } else {\n              openviduToken_1 = options['token'];\n            }\n\n            if (!openviduToken_1) {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'))];\n            }\n\n            tokenParams_1 = this.session.getTokenParams(openviduToken_1);\n\n            if (tokenParams_1.edition !== 'pro' && tokenParams_1.edition !== 'enterprise') {\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'))];\n            }\n\n            openviduToken_1 = encodeURIComponent(btoa(openviduToken_1));\n            logger.info('Applying Virtual Background to stream ' + this.streamId);\n\n            afterScriptLoaded_1 = function afterScriptLoaded_1() {\n              return __awaiter(_this, void 0, void 0, function () {\n                var id, mediaStreamClone, videoClone, VB, filteredVideo, _a, error_1;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0, 8,, 9]);\n\n                      id = this.streamId + '_' + (0, uuid_1.v4)();\n                      mediaStreamClone = this.mediaStream.clone();\n                      videoClone = this.streamManager.videos[0].video.cloneNode(false); // @ts-ignore\n\n                      videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                      videoClone.srcObject = mediaStreamClone;\n                      videoClone.muted = true;\n                      this.virtualBackgroundSourceElements = {\n                        videoClone: videoClone,\n                        mediaStreamClone: mediaStreamClone\n                      }; // @ts-ignore\n\n                      VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false); // @ts-ignore\n\n                      VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n                      return [4\n                      /*yield*/\n                      , videoClone.play()];\n\n                    case 1:\n                      _b.sent();\n\n                      VB = new VirtualBackground.VirtualBackground({\n                        id: id,\n                        openviduServerUrl: new URL(tokenParams_1.httpUri),\n                        openviduToken: openviduToken_1,\n                        inputVideo: videoClone,\n                        inputResolution: '160x96',\n                        outputFramerate: 24\n                      });\n                      filteredVideo = void 0;\n                      _a = type;\n\n                      switch (_a) {\n                        case 'VB:blur':\n                          return [3\n                          /*break*/\n                          , 2];\n\n                        case 'VB:image':\n                          return [3\n                          /*break*/\n                          , 4];\n                      }\n\n                      return [3\n                      /*break*/\n                      , 6];\n\n                    case 2:\n                      return [4\n                      /*yield*/\n                      , VB.backgroundBlur(options)];\n\n                    case 3:\n                      filteredVideo = _b.sent();\n                      return [3\n                      /*break*/\n                      , 7];\n\n                    case 4:\n                      return [4\n                      /*yield*/\n                      , VB.backgroundImage(options)];\n\n                    case 5:\n                      filteredVideo = _b.sent();\n                      return [3\n                      /*break*/\n                      , 7];\n\n                    case 6:\n                      throw new Error('Unknown Virtual Background filter: ' + type);\n\n                    case 7:\n                      this.virtualBackgroundSinkElements = {\n                        VB: VB,\n                        video: filteredVideo\n                      };\n                      videoClone.style.display = 'none';\n\n                      if (this.streamManager.remote) {\n                        this.streamManager.replaceTrackInMediaStream(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      } else {\n                        this.streamManager.replaceTrackAux(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      }\n\n                      resolveApplyFilter(undefined, false);\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 8:\n                      error_1 = _b.sent();\n\n                      if (error_1.name === OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                        resolveApplyFilter(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error_1.message), false);\n                      } else {\n                        resolveApplyFilter(error_1, false);\n                      }\n\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 9:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }; // @ts-ignore\n\n\n            if (typeof VirtualBackground === \"undefined\") {\n              script = document.createElement(\"script\");\n              script.type = \"text/javascript\";\n              script.src = tokenParams_1.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken_1;\n\n              script.onload = function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var error_2;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        _a.trys.push([0, 2,, 3]);\n\n                        return [4\n                        /*yield*/\n                        , afterScriptLoaded_1()];\n\n                      case 1:\n                        _a.sent();\n\n                        resolve(new Filter_1.Filter(type, options));\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 2:\n                        error_2 = _a.sent();\n                        reject(error_2);\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 3:\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n\n              document.body.appendChild(script);\n            } else {\n              afterScriptLoaded_1().then(function () {\n                return resolve(new Filter_1.Filter(type, options));\n              }).catch(function (error) {\n                return reject(error);\n              });\n            }\n          } else {\n            // Server filters\n            if (!this.session.sessionConnected()) {\n              return [2\n              /*return*/\n              , reject(this.session.notConnectedError())];\n            }\n\n            logger.info('Applying server filter to stream ' + this.streamId);\n            options = options != null ? options : {};\n            optionsString = options;\n\n            if (typeof optionsString !== 'string') {\n              optionsString = JSON.stringify(optionsString);\n            }\n\n            this.session.openvidu.sendRequest('applyFilter', {\n              streamId: this.streamId,\n              type: type,\n              options: optionsString\n            }, function (error, response) {\n              resolveApplyFilter(error, true);\n            });\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    });\n  };\n  /**\n   * Removes an audio/video filter previously applied.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n   */\n\n\n  Stream.prototype.removeFilter = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.removeFilterAux(false)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n   *\n   * @returns Native RTCPeerConnection Web API object\n   */\n\n\n  Stream.prototype.getRTCPeerConnection = function () {\n    return this.webRtcPeer.pc;\n  };\n  /**\n   * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n   *\n   * @returns Native MediaStream Web API object\n   */\n\n\n  Stream.prototype.getMediaStream = function () {\n    return this.mediaStream;\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.removeFilterAux = function (isDisposing) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveRemoveFilter, mediaStreamClone, error_3;\n\n        var _this = this;\n\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              resolveRemoveFilter = function resolveRemoveFilter(error, triggerEvent) {\n                if (error) {\n                  delete _this.filter;\n                  logger.error('Error removing filter for Stream ' + _this.streamId, error);\n\n                  if (error.code === 401) {\n                    return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\"));\n                  } else {\n                    return reject(error);\n                  }\n                } else {\n                  logger.info('Filter successfully removed from Stream ' + _this.streamId);\n                  var oldValue = _this.filter;\n                  delete _this.filter;\n\n                  if (triggerEvent) {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n\n                    _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                  }\n\n                  return resolve();\n                }\n              };\n\n              if (!!!this.filter) return [3\n              /*break*/\n              , 12];\n              if (!((_a = this.filter) === null || _a === void 0 ? void 0 : _a.type.startsWith('VB:'))) return [3\n              /*break*/\n              , 10];\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 8,, 9]);\n\n              mediaStreamClone = this.virtualBackgroundSourceElements.mediaStreamClone;\n              if (!!isDisposing) return [3\n              /*break*/\n              , 6];\n              if (!this.streamManager.remote) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false)];\n\n            case 2:\n              _b.sent();\n\n              return [3\n              /*break*/\n              , 5];\n\n            case 3:\n              return [4\n              /*yield*/\n              , this.streamManager.replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false)];\n\n            case 4:\n              _b.sent();\n\n              _b.label = 5;\n\n            case 5:\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              mediaStreamClone.getTracks().forEach(function (track) {\n                return track.stop();\n              });\n              _b.label = 7;\n\n            case 7:\n              this.virtualBackgroundSinkElements.VB.cleanUp();\n              delete this.virtualBackgroundSinkElements;\n              delete this.virtualBackgroundSourceElements;\n              return [2\n              /*return*/\n              , resolveRemoveFilter(undefined, false)];\n\n            case 8:\n              error_3 = _b.sent();\n              return [2\n              /*return*/\n              , resolveRemoveFilter(error_3, false)];\n\n            case 9:\n              return [3\n              /*break*/\n              , 11];\n\n            case 10:\n              // Server filters\n              if (!this.session.sessionConnected()) {\n                return [2\n                /*return*/\n                , reject(this.session.notConnectedError())];\n              }\n\n              logger.info('Removing filter of stream ' + this.streamId);\n              this.session.openvidu.sendRequest('removeFilter', {\n                streamId: this.streamId\n              }, function (error, response) {\n                return resolveRemoveFilter(error, true);\n              });\n              _b.label = 11;\n\n            case 11:\n              return [3\n              /*break*/\n              , 13];\n\n            case 12:\n              // There is no filter applied\n              return [2\n              /*return*/\n              , reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, \"Stream \" + this.streamId + \" has no filter applied\"))];\n\n            case 13:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.setMediaStream = function (mediaStream) {\n    this.mediaStream = mediaStream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.updateMediaStreamInVideos = function () {\n    this.ee.emitEvent('mediastream-updated', []);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getWebRtcPeer = function () {\n    return this.webRtcPeer;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.subscribeToMyRemote = function (value) {\n    this.isSubscribeToRemote = value;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.setOutboundStreamOptions = function (outboundStreamOpts) {\n    this.outboundStreamOpts = outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.subscribe = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.initWebRtcPeerReceive(false).then(function () {\n        return resolve();\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.publish = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocalStreamReadyToPublish) {\n        _this.initWebRtcPeerSend(false).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      } else {\n        _this.ee.once('stream-ready-to-publish', function () {\n          _this.publish().then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disposeWebRtcPeer = function () {\n    var webrtcId;\n\n    if (!!this.webRtcPeer) {\n      this.webRtcPeer.dispose();\n      webrtcId = this.webRtcPeer.getId();\n    }\n\n    this.stopWebRtcStats();\n    logger.info((!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') + \"RTCPeerConnection with id [\" + webrtcId + \"] from 'Stream' with id [\" + this.streamId + '] is now closed');\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disposeMediaStream = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(!!this.filter && this.filter.type.startsWith('VB:'))) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.removeFilterAux(true)];\n\n          case 2:\n            _a.sent();\n\n            console.debug(\"Success removing Virtual Background filter for stream \".concat(this.streamId));\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_4 = _a.sent();\n            console.error(\"Error removing Virtual Background filter for stream \".concat(this.streamId), error_4);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (this.mediaStream) {\n              this.mediaStream.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.mediaStream;\n            } // If subscribeToRemote local MediaStream must be stopped\n\n\n            if (this.localMediaStreamWhenSubscribedToRemote) {\n              this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.localMediaStreamWhenSubscribedToRemote;\n            }\n\n            if (!!this.speechEvent) {\n              if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n              }\n\n              delete this.speechEvent;\n            }\n\n            logger.info((!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed');\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.displayMyRemote = function () {\n    return this.isSubscribeToRemote;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isSendAudio = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.audioSource !== null && this.outboundStreamOpts.publisherProperties.audioSource !== false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isSendVideo = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.videoSource !== null && this.outboundStreamOpts.publisherProperties.videoSource !== false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isSendScreen = function () {\n    var screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n\n    if (platform.isElectron()) {\n      screen = typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' && this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n    }\n\n    return !!this.outboundStreamOpts && screen;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableHarkSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n      this.harkSpeakingEnabled = true;\n      this.speechEvent.on('speaking', function () {\n        _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n\n        _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n\n        _this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableOnceHarkSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = true;\n      this.speechEvent.once('speaking', function () {\n        if (_this.harkSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n\n          _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        }\n\n        _this.disableHarkSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disableHarkSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = false;\n\n      if (disabledByOnce) {\n        if (this.harkSpeakingEnabled) {\n          // The 'on' version of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkSpeakingEnabled = false;\n      } // Shutting down the hark event\n\n\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabled = true;\n      this.speechEvent.on('stopped_speaking', function () {\n        _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n\n        _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n\n        _this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableOnceHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n\n    this.setHarkListenerIfNotExists();\n\n    if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = true;\n      this.speechEvent.once('stopped_speaking', function () {\n        if (_this.harkStoppedSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n\n          _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        }\n\n        _this.disableHarkStoppedSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n  * @hidden\n  */\n\n\n  Stream.prototype.disableHarkStoppedSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = false;\n\n      if (disabledByOnce) {\n        if (this.harkStoppedSpeakingEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkStoppedSpeakingEnabled = false;\n      } // Shutting down the hark event\n\n\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('stopped_speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabled || force) {\n        this.harkVolumeChangeEnabled = true;\n        this.speechEvent.on('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabled = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.enableOnceHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabledOnce || force) {\n        this.harkVolumeChangeEnabledOnce = true;\n        this.speechEvent.once('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n\n          _this.disableHarkVolumeChangeEvent(true);\n\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabledOnce = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.disableHarkVolumeChangeEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkVolumeChangeEnabledOnce = false;\n\n      if (disabledByOnce) {\n        if (this.harkVolumeChangeEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkVolumeChangeEnabled = false;\n      } // Shutting down the hark event\n\n\n      if (this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('volume_change');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.isLocal = function () {\n    // inbound options undefined and outbound options defined\n    return !this.inboundStreamOpts && !!this.outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getSelectedIceCandidate = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.webRtcStats.getSelectedIceCandidateInfo().then(function (report) {\n        return resolve(report);\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getRemoteIceCandidateList = function () {\n    return this.webRtcPeer.remoteCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.getLocalIceCandidateList = function () {\n    return this.webRtcPeer.localCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.streamIceConnectionStateBroken = function () {\n    if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n      return false;\n    }\n\n    if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n      logger.warn(\"OpenVidu Browser advanced configuration option \\\"forceMediaReconnectionAfterNetworkDrop\\\" is enabled. Stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") will force a reconnection\"));\n      return true;\n    }\n\n    var iceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n    return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n  };\n  /* Private methods */\n\n\n  Stream.prototype.setHarkListenerIfNotExists = function () {\n    if (!!this.mediaStream) {\n      if (!this.speechEvent) {\n        var harkOptions = !!this.harkOptions ? this.harkOptions : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n        harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;\n        harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;\n        this.speechEvent = hark(this.mediaStream, harkOptions);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.setupReconnectionEventEmitter = function (resolve, reject) {\n    if (this.reconnectionEventEmitter == undefined) {\n      // There is no ongoing reconnection\n      this.reconnectionEventEmitter = new EventEmitter();\n      return false;\n    } else {\n      // Ongoing reconnection\n      console.warn(\"Trying to reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but an ongoing reconnection process is active. Waiting for response...\"));\n      this.reconnectionEventEmitter.once('success', function () {\n        return resolve();\n      });\n      this.reconnectionEventEmitter.once('error', function (error) {\n        return reject(error);\n      });\n      return true;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerSend = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var _a;\n\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      } else {\n        // MediaStream will already have hark events for reconnected streams\n        _this.initHarkEvents(); // Init hark events for the local stream\n\n      }\n\n      var finalResolve = function finalResolve() {\n        var _a;\n\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n          delete _this.reconnectionEventEmitter;\n        }\n\n        return resolve();\n      };\n\n      var finalReject = function finalReject(error) {\n        var _a;\n\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n          delete _this.reconnectionEventEmitter;\n        }\n\n        return reject(error);\n      };\n\n      var successOfferCallback = function successOfferCallback(sdpOfferParam) {\n        logger.debug('Sending SDP offer to publish as ' + _this.streamId, sdpOfferParam);\n        var method = reconnect ? 'reconnectStream' : 'publishVideo';\n        var params;\n\n        if (reconnect) {\n          params = {\n            stream: _this.streamId,\n            sdpString: sdpOfferParam\n          };\n        } else {\n          var typeOfVideo = void 0;\n\n          if (_this.isSendVideo()) {\n            typeOfVideo = typeof MediaStreamTrack !== 'undefined' && _this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack ? TypeOfVideo_1.TypeOfVideo.CUSTOM : _this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n          }\n\n          params = {\n            doLoopback: _this.displayMyRemote() || false,\n            hasAudio: _this.isSendAudio(),\n            hasVideo: _this.isSendVideo(),\n            audioActive: _this.audioActive,\n            videoActive: _this.videoActive,\n            typeOfVideo: typeOfVideo,\n            frameRate: !!_this.frameRate ? _this.frameRate : -1,\n            videoDimensions: JSON.stringify(_this.videoDimensions),\n            filter: _this.outboundStreamOpts.publisherProperties.filter,\n            sdpOffer: sdpOfferParam\n          };\n        }\n\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            if (error.code === 401) {\n              finalReject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\"));\n            } else {\n              finalReject('Error on publishVideo: ' + JSON.stringify(error));\n            }\n          } else {\n            _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n              _this.streamId = response.id;\n              _this.creationTime = response.createdAt;\n              _this.isLocalStreamPublished = true;\n              _this.publishedOnce = true;\n\n              if (_this.displayMyRemote()) {\n                _this.localMediaStreamWhenSubscribedToRemote = _this.mediaStream;\n\n                _this.remotePeerSuccessfullyEstablished(reconnect);\n              }\n\n              if (reconnect) {\n                _this.ee.emitEvent('stream-reconnected-by-publisher', []);\n              } else {\n                _this.ee.emitEvent('stream-created-by-publisher', []);\n              }\n\n              _this.initWebRtcStats();\n\n              logger.info(\"'Publisher' (\" + _this.streamId + \") successfully \" + (reconnect ? \"reconnected\" : \"published\") + \" to session\");\n              finalResolve();\n            }).catch(function (error) {\n              finalReject(error);\n            });\n          }\n        });\n      };\n\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: (_a = _this.outboundStreamOpts.publisherProperties.videoSimulcast) !== null && _a !== void 0 ? _a : _this.session.openvidu.videoSimulcast,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: function onIceConnectionStateException(exceptionName, message, data) {\n          _this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(_this.session, exceptionName, _this, message, data)]);\n        },\n        iceServers: _this.getIceServersConf(),\n        mediaStream: _this.mediaStream,\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n\n      if (_this.session.openvidu.mediaServer !== 'mediasoup') {\n        // Simulcast is only supported by mediasoup\n        config.simulcast = false;\n      }\n\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n\n      if (_this.displayMyRemote()) {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendrecv(config);\n      } else {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendonly(config);\n      }\n\n      _this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + _this.connection.connectionId);\n\n      _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n        _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n          successOfferCallback(sdpOffer.sdp);\n        }).catch(function (error) {\n          finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n        });\n      }).catch(function (error) {\n        finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.finalResolveForSubscription = function (reconnect, resolve) {\n    var _a;\n\n    logger.info(\"'Subscriber' (\" + this.streamId + \") successfully \" + (reconnect ? \"reconnected\" : \"subscribed\"));\n    this.remotePeerSuccessfullyEstablished(reconnect);\n    this.initWebRtcStats();\n\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n      delete this.reconnectionEventEmitter;\n    }\n\n    return resolve();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.finalRejectForSubscription = function (reconnect, error, reject) {\n    var _a;\n\n    logger.error(\"Error for 'Subscriber' (\" + this.streamId + \") while trying to \" + (reconnect ? \"reconnect\" : \"subscribe\") + \": \" + error.toString());\n\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n      delete this.reconnectionEventEmitter;\n    }\n\n    return reject(error);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerReceive = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      }\n\n      if (_this.session.openvidu.mediaServer === 'mediasoup') {\n        // Server initiates negotiation\n        _this.initWebRtcPeerReceiveFromServer(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      } else {\n        // Client initiates negotiation\n        _this.initWebRtcPeerReceiveFromClient(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerReceiveFromClient = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.completeWebRtcPeerReceive(reconnect, false).then(function (response) {\n        _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcPeerReceiveFromServer = function (reconnect) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      // Server initiates negotiation\n      _this.session.openvidu.sendRequest('prepareReceiveVideoFrom', {\n        sender: _this.streamId,\n        reconnect: reconnect\n      }, function (error, response) {\n        if (error) {\n          return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n        } else {\n          _this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer).then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.completeWebRtcPeerReceive = function (reconnect, forciblyReconnect, sdpOfferByServer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      logger.debug(\"'Session.subscribe(Stream)' called\");\n\n      var sendSdpToServer = function sendSdpToServer(sdpString) {\n        logger.debug(\"Sending local SDP \".concat(!!sdpOfferByServer ? 'answer' : 'offer', \" to subscribe to \").concat(_this.streamId), sdpString);\n        var method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n        var params = {};\n        params[reconnect ? 'stream' : 'sender'] = _this.streamId;\n\n        if (!!sdpOfferByServer) {\n          params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n        } else {\n          params['sdpOffer'] = sdpString;\n        }\n\n        if (reconnect) {\n          params['forciblyReconnect'] = forciblyReconnect;\n        }\n\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n          } else {\n            return resolve(response);\n          }\n        });\n      };\n\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: false,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: function onIceConnectionStateException(exceptionName, message, data) {\n          _this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(_this.session, exceptionName, _this, message, data)]);\n        },\n        iceServers: _this.getIceServersConf(),\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n\n      _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerRecvonly(config);\n\n      _this.webRtcPeer.addIceConnectionStateChangeListener(_this.streamId);\n\n      if (!!sdpOfferByServer) {\n        _this.webRtcPeer.processRemoteOffer(sdpOfferByServer).then(function () {\n          _this.webRtcPeer.createAnswer().then(function (sdpAnswer) {\n            _this.webRtcPeer.processLocalAnswer(sdpAnswer).then(function () {\n              sendSdpToServer(sdpAnswer.sdp);\n            }).catch(function (error) {\n              return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n            });\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n        });\n      } else {\n        _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n          _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n            sendSdpToServer(sdpOffer.sdp);\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.remotePeerSuccessfullyEstablished = function (reconnect) {\n    if (reconnect && this.mediaStream != null) {\n      // Now we can destroy the existing MediaStream\n      this.disposeMediaStream();\n    }\n\n    this.mediaStream = new MediaStream();\n    var receiver;\n\n    for (var _i = 0, _a = this.webRtcPeer.pc.getReceivers(); _i < _a.length; _i++) {\n      receiver = _a[_i];\n\n      if (!!receiver.track) {\n        this.mediaStream.addTrack(receiver.track);\n      }\n    }\n\n    logger.debug('Peer remote stream', this.mediaStream);\n\n    if (!!this.mediaStream) {\n      if (this.streamManager instanceof Subscriber_1.Subscriber) {\n        // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n        if (!!this.mediaStream.getAudioTracks()[0]) {\n          var enabled = reconnect ? this.audioActive : !!this.streamManager.properties.subscribeToAudio;\n          this.mediaStream.getAudioTracks()[0].enabled = enabled;\n        }\n\n        if (!!this.mediaStream.getVideoTracks()[0]) {\n          var enabled = reconnect ? this.videoActive : !!this.streamManager.properties.subscribeToVideo;\n          this.mediaStream.getVideoTracks()[0].enabled = enabled;\n        }\n      }\n\n      this.updateMediaStreamInVideos();\n      this.initHarkEvents(); // Init hark events for the remote stream\n    }\n  };\n\n  Stream.prototype.initHarkEvents = function () {\n    if (!!this.mediaStream.getAudioTracks()[0]) {\n      // Hark events can only be set if audio track is available\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkSpeakingEvent();\n      }\n\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n        this.enableHarkSpeakingEvent();\n      }\n\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkStoppedSpeakingEvent();\n      }\n\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n        this.enableHarkStoppedSpeakingEvent();\n      }\n\n      if (this.harkVolumeChangeEnabledOnce) {\n        this.enableOnceHarkVolumeChangeEvent(true);\n      }\n\n      if (this.harkVolumeChangeEnabled) {\n        this.enableHarkVolumeChangeEvent(true);\n      }\n    }\n  };\n\n  Stream.prototype.onIceConnectionStateExceptionHandler = function (exceptionName, message, data) {\n    switch (exceptionName) {\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED:\n        this.onIceConnectionFailed();\n        break;\n\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n        this.onIceConnectionDisconnected();\n        break;\n    }\n\n    this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(this.session, exceptionName, this, message, data)]);\n  };\n\n  Stream.prototype.onIceConnectionFailed = function () {\n    // Immediately reconnect, as this is a terminal error\n    logger.log(\"[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \")\"));\n    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED);\n  };\n\n  Stream.prototype.onIceConnectionDisconnected = function () {\n    var _this = this; // Wait to see if the ICE connection is able to reconnect\n\n\n    logger.log(\"[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") if not possible\"));\n    var timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n    this.awaitWebRtcPeerConnectionState(timeout).then(function (state) {\n      switch (state) {\n        case 'failed':\n          // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") is now failed after ICE_CONNECTION_DISCONNECTED\"));\n          break;\n\n        case 'connected':\n        case 'completed':\n          logger.log(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: \").concat(state));\n          break;\n\n        case 'closed':\n        case 'checking':\n        case 'new':\n        case 'disconnected':\n          // Rest of states\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after \").concat(timeout, \" ms: \").concat(state));\n\n          _this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n\n          break;\n      }\n    });\n  };\n\n  Stream.prototype.reconnectStreamAndLogResultingIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var finalIceStateAfterReconnection, error_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.reconnectStreamAndReturnIceConnectionState(event)];\n\n          case 1:\n            finalIceStateAfterReconnection = _a.sent();\n\n            switch (finalIceStateAfterReconnection) {\n              case 'connected':\n              case 'completed':\n                logger.log(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") successfully reconnected after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n\n              default:\n                logger.error(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") failed to reconnect after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n            }\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_5 = _a.sent();\n            logger.error(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after \").concat(event, \": \").concat(error_5));\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.reconnectStreamAndReturnIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var timeout, error_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.log(\"[\".concat(event, \"] Reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after event \").concat(event));\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.reconnectStream(event)];\n\n          case 2:\n            _a.sent();\n\n            timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return [2\n            /*return*/\n            , this.awaitWebRtcPeerConnectionState(timeout)];\n\n          case 3:\n            error_6 = _a.sent();\n            logger.warn(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \"). Reason: \").concat(error_6));\n            return [2\n            /*return*/\n            , this.awaitWebRtcPeerConnectionState(1)];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.reconnectStream = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isWsConnected, errorMsg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isWebsocketConnected(event, 3000)];\n\n          case 1:\n            isWsConnected = _a.sent();\n\n            if (isWsConnected) {\n              // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n              logger.log(\"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") and the websocket is opened\"));\n\n              if (this.isLocal()) {\n                return [2\n                /*return*/\n                , this.initWebRtcPeerSend(true)];\n              } else {\n                return [2\n                /*return*/\n                , this.initWebRtcPeerReceive(true)];\n              }\n            } else {\n              errorMsg = \"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but the websocket wasn't opened\");\n              logger.error(errorMsg);\n              throw Error(errorMsg);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.isWebsocketConnected = function (event, msResponseTimeout) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var wsReadyState = _this.session.openvidu.getWsReadyState();\n\n      if (wsReadyState === 1) {\n        var responseTimeout_1 = setTimeout(function () {\n          console.warn(\"[\".concat(event, \"] Websocket timeout of \").concat(msResponseTimeout, \"ms\"));\n          return resolve(false);\n        }, msResponseTimeout);\n\n        _this.session.openvidu.sendRequest('echo', {}, function (error, response) {\n          clearTimeout(responseTimeout_1);\n\n          if (!!error) {\n            console.warn(\"[\".concat(event, \"] Websocket 'echo' returned error: \").concat(error));\n            return resolve(false);\n          } else {\n            return resolve(true);\n          }\n        });\n      } else {\n        console.warn(\"[\".concat(event, \"] Websocket readyState is \").concat(wsReadyState));\n        return resolve(false);\n      }\n    });\n  };\n\n  Stream.prototype.awaitWebRtcPeerConnectionState = function (timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      var state, interval, intervals, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            state = this.getRTCPeerConnection().iceConnectionState;\n            interval = 150;\n            intervals = Math.ceil(timeout / interval);\n            i = 0;\n            _a.label = 1;\n\n          case 1:\n            if (!(i < intervals)) return [3\n            /*break*/\n            , 4];\n            state = this.getRTCPeerConnection().iceConnectionState;\n\n            if (state === 'connected' || state === 'completed') {\n              return [3\n              /*break*/\n              , 4];\n            } // Sleep\n\n\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              return setTimeout(resolve, interval);\n            })];\n\n          case 2:\n            // Sleep\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , state];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Stream.prototype.initWebRtcStats = function () {\n    this.webRtcStats = new WebRtcStats_1.WebRtcStats(this);\n    this.webRtcStats.initWebRtcStats(); //TODO: send common webrtc stats from client to openvidu-server\n\n    /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n        setInterval(() => {\n            this.gatherStatsForPeer().then(jsonStats => {\n                const body = {\n                    sessionId: this.session.sessionId,\n                    participantPrivateId: this.connection.rpcSessionId,\n                    stats: jsonStats\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                xhr.setRequestHeader('Content-Type', 'application/json');\n                xhr.send(JSON.stringify(body));\n            })\n        }, this.session.openvidu.webrtcStatsInterval * 1000);\n    }*/\n  };\n\n  Stream.prototype.stopWebRtcStats = function () {\n    if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n      this.webRtcStats.stopWebRtcStats();\n    }\n  };\n\n  Stream.prototype.getIceServersConf = function () {\n    var returnValue;\n\n    if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n      returnValue = this.session.openvidu.advancedConfiguration.iceServers === 'freeice' ? undefined : this.session.openvidu.advancedConfiguration.iceServers;\n    } else if (this.session.openvidu.iceServers) {\n      returnValue = this.session.openvidu.iceServers;\n    } else {\n      returnValue = undefined;\n    }\n\n    return returnValue;\n  };\n\n  Stream.prototype.gatherStatsForPeer = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocal()) {\n        // Publisher stream stats\n        _this.getRTCPeerConnection().getSenders().forEach(function (sender) {\n          return sender.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id; // Common to Chrome, Firefox and Safari\n\n                if (report.type === 'outbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum; // Set media type\n\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesEncoded'] = report.framesEncoded;\n                  }\n\n                  finalReport['packetsSent'] = report.packetsSent;\n                  finalReport['bytesSent'] = report.bytesSent;\n                } // Only for Chrome and Safari\n\n\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                } // Only for Firefox >= 66.0\n\n\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      } else {\n        // Subscriber stream stats\n        _this.getRTCPeerConnection().getReceivers().forEach(function (receiver) {\n          return receiver.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id; // Common to Chrome, Firefox and Safari\n\n                if (report.type === 'inbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum; // Set media type\n\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesDecoded'] = report.framesDecoded;\n                  }\n\n                  finalReport['packetsReceived'] = report.packetsReceived;\n                  finalReport['packetsLost'] = report.packetsLost;\n                  finalReport['jitter'] = report.jitter;\n                  finalReport['bytesReceived'] = report.bytesReceived;\n                } // Only for Chrome and Safari\n\n\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                } // Only for Firefox >= 66.0\n\n\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      }\n    });\n  };\n\n  Stream.prototype.isReportWanted = function (report) {\n    return report.type === 'inbound-rtp' && !this.isLocal() || report.type === 'outbound-rtp' && this.isLocal() || report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0;\n  };\n\n  return Stream;\n}();\n\nexports.Stream = Stream;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalRecorder = void 0;\n\nvar LocalRecorderState_1 = require(\"../OpenViduInternal/Enums/LocalRecorderState\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar Mime = require(\"mime/lite\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Easy recording of [[Stream]] objects straightaway from the browser. Initialized with [[OpenVidu.initLocalRecorder]] method\n */\n\nvar LocalRecorder =\n/** @class */\nfunction () {\n  /**\n   * @hidden\n   */\n  function LocalRecorder(stream) {\n    this.stream = stream;\n    this.chunks = [];\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n    this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n    this.state = LocalRecorderState_1.LocalRecorderState.READY;\n  }\n  /**\n   * Starts the recording of the Stream. [[state]] property must be `READY`. After method succeeds is set to `RECORDING`\n   *\n   * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n   * For example:\n   *\n   * ```javascript\n   * var OV = new OpenVidu();\n   * var publisher = await OV.initPublisherAsync();\n   * var localRecorder = OV.initLocalRecorder(publisher.stream);\n   * var options = {\n   *      mimeType: 'video/webm;codecs=vp8',\n   *      audioBitsPerSecond:128000,\n   *      videoBitsPerSecond:2500000\n   * };\n   * localRecorder.record(options);\n   * ```\n   *\n   * If not specified, the default options preferred by the platform will be used.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.record = function (options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (typeof options === 'string' || options instanceof String) {\n          return reject(\"When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \\\"\".concat(options, \"\\\" }\"));\n        }\n\n        if (typeof MediaRecorder === 'undefined') {\n          logger.error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n          throw Error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n        }\n\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.READY) {\n          throw Error('\\'LocalRecord.record()\\' needs \\'LocalRecord.state\\' to be \\'READY\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.clean()\\' or init a new LocalRecorder before');\n        }\n\n        logger.log(\"Starting local recording of stream '\" + _this.stream.streamId + \"' of connection '\" + _this.connectionId + \"'\");\n\n        if (!options) {\n          options = {\n            mimeType: 'video/webm'\n          };\n        } else if (!options.mimeType) {\n          options.mimeType = 'video/webm';\n        }\n\n        _this.mediaRecorder = new MediaRecorder(_this.stream.getMediaStream(), options);\n\n        _this.mediaRecorder.start();\n      } catch (err) {\n        return reject(err);\n      }\n\n      _this.mediaRecorder.ondataavailable = function (e) {\n        if (e.data.size > 0) {\n          _this.chunks.push(e.data);\n        }\n      };\n\n      _this.mediaRecorder.onerror = function (e) {\n        logger.error('MediaRecorder error: ', e);\n      };\n\n      _this.mediaRecorder.onstart = function () {\n        logger.log('MediaRecorder started (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onstop = function () {\n        _this.onStopDefault();\n      };\n\n      _this.mediaRecorder.onpause = function () {\n        logger.log('MediaRecorder paused (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onresume = function () {\n        logger.log('MediaRecorder resumed (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n      return resolve();\n    });\n  };\n  /**\n   * Ends the recording of the Stream. [[state]] property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.stop = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state === LocalRecorderState_1.LocalRecorderState.READY || _this.state === LocalRecorderState_1.LocalRecorderState.FINISHED) {\n          throw Error('\\'LocalRecord.stop()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' or \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' before');\n        }\n\n        _this.mediaRecorder.onstop = function () {\n          _this.onStopDefault();\n\n          return resolve();\n        };\n\n        _this.mediaRecorder.stop();\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\n   * Pauses the recording of the Stream. [[state]] property must be `RECORDING`. After method succeeds is set to `PAUSED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.pause = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.RECORDING) {\n          return reject(Error('\\'LocalRecord.pause()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' or \\'LocalRecorder.resume()\\' before'));\n        }\n\n        _this.mediaRecorder.pause();\n\n        _this.state = LocalRecorderState_1.LocalRecorderState.PAUSED;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Resumes the recording of the Stream. [[state]] property must be `PAUSED`. After method succeeds is set to `RECORDING`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.resume = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.PAUSED) {\n          throw Error('\\'LocalRecord.resume()\\' needs \\'LocalRecord.state\\' to be \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.pause()\\' before');\n        }\n\n        _this.mediaRecorder.resume();\n\n        _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.preview = function (parentElement) {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('\\'LocalRecord.preview()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before');\n    }\n\n    this.videoPreview = document.createElement('video');\n    this.videoPreview.id = this.id;\n    this.videoPreview.autoplay = true;\n\n    if (platform.isSafariBrowser()) {\n      this.videoPreview.setAttribute('playsinline', 'true');\n    }\n\n    if (typeof parentElement === 'string') {\n      var parentElementDom = document.getElementById(parentElement);\n\n      if (parentElementDom) {\n        this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n      }\n    } else {\n      this.videoPreview = parentElement.appendChild(this.videoPreview);\n    }\n\n    this.videoPreview.src = this.videoPreviewSrc;\n    return this.videoPreview;\n  };\n  /**\n   * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets [[state]] to `READY` so the recording can start again\n   */\n\n\n  LocalRecorder.prototype.clean = function () {\n    var _this = this;\n\n    var f = function f() {\n      delete _this.blob;\n      _this.chunks = [];\n      _this.state = LocalRecorderState_1.LocalRecorderState.READY;\n    };\n\n    if (this.state === LocalRecorderState_1.LocalRecorderState.RECORDING || this.state === LocalRecorderState_1.LocalRecorderState.PAUSED) {\n      this.stop().then(function () {\n        return f();\n      }).catch(function () {\n        return f();\n      });\n    } else {\n      f();\n    }\n  };\n  /**\n   * Downloads the recorded video through the browser. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.download = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('\\'LocalRecord.download()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before');\n    } else {\n      var a = document.createElement('a');\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      var url = window.URL.createObjectURL(this.blob);\n      a.href = url;\n      a.download = this.id + '.' + Mime.getExtension(this.blob.type);\n      a.click();\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(a);\n    }\n  };\n  /**\n   * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.getBlob = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('Call \\'LocalRecord.stop()\\' before getting Blob file');\n    } else {\n      return this.blob;\n    }\n  };\n  /**\n   * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n   */\n\n\n  LocalRecorder.prototype.uploadAsBinary = function (endpoint, headers) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error('\\'LocalRecord.uploadAsBinary()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n      } else {\n        var http_1 = new XMLHttpRequest();\n        http_1.open('POST', endpoint, true);\n\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_1.setRequestHeader(key, headers[key]);\n          }\n        }\n\n        http_1.onreadystatechange = function () {\n          if (http_1.readyState === 4) {\n            if (http_1.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_1.responseText);\n            } else {\n              return reject(http_1.status);\n            }\n          }\n        };\n\n        http_1.send(_this.blob);\n      }\n    });\n  };\n  /**\n   * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n   */\n\n\n  LocalRecorder.prototype.uploadAsMultipartfile = function (endpoint, headers) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error('\\'LocalRecord.uploadAsMultipartfile()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n      } else {\n        var http_2 = new XMLHttpRequest();\n        http_2.open('POST', endpoint, true);\n\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_2.setRequestHeader(key, headers[key]);\n          }\n        }\n\n        var sendable = new FormData();\n        sendable.append('file', _this.blob, _this.id + '.' + Mime.getExtension(_this.blob.type));\n\n        http_2.onreadystatechange = function () {\n          if (http_2.readyState === 4) {\n            if (http_2.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_2.responseText);\n            } else {\n              return reject(http_2.status);\n            }\n          }\n        };\n\n        http_2.send(sendable);\n      }\n    });\n  };\n  /* Private methods */\n\n\n  LocalRecorder.prototype.onStopDefault = function () {\n    logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n    this.blob = new Blob(this.chunks, {\n      type: this.mediaRecorder.mimeType\n    });\n    this.chunks = [];\n    this.videoPreviewSrc = window.URL.createObjectURL(this.blob);\n    this.state = LocalRecorderState_1.LocalRecorderState.FINISHED;\n  };\n\n  return LocalRecorder;\n}();\n\nexports.LocalRecorder = LocalRecorder;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Publisher = void 0;\n\nvar Session_1 = require(\"./Session\");\n\nvar Stream_1 = require(\"./Stream\");\n\nvar StreamManager_1 = require(\"./StreamManager\");\n\nvar StreamEvent_1 = require(\"../OpenViduInternal/Events/StreamEvent\");\n\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\n\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with [[OpenVidu.initPublisher]] method.\n *\n * See available event listeners at [[PublisherEventMap]].\n */\n\nvar Publisher =\n/** @class */\nfunction (_super) {\n  __extends(Publisher, _super);\n  /**\n   * @hidden\n   */\n\n\n  function Publisher(targEl, properties, openvidu) {\n    var _this = _super.call(this, new Stream_1.Stream(!!openvidu.session ? openvidu.session : new Session_1.Session(openvidu), {\n      publisherProperties: properties,\n      mediaConstraints: {}\n    }), targEl) || this;\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n\n\n    _this.accessAllowed = false;\n    /**\n     * Whether you have called [[Publisher.subscribeToRemote]] with value `true` or `false` (*false* by default)\n     */\n\n    _this.isSubscribedToRemote = false;\n    _this.accessDenied = false;\n    platform = Platform_1.PlatformUtils.getInstance();\n    _this.properties = properties;\n    _this.openvidu = openvidu;\n\n    _this.stream.ee.on('local-stream-destroyed', function (reason) {\n      _this.stream.isLocalStreamPublished = false;\n      var streamEvent = new StreamEvent_1.StreamEvent(true, _this, 'streamDestroyed', _this.stream, reason);\n\n      _this.emitEvent('streamDestroyed', [streamEvent]);\n\n      streamEvent.callDefaultBehavior();\n    });\n\n    return _this;\n  }\n  /**\n   * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The [[Session]] object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The [[Publisher]] object of the local participant will also dispatch the exact same event\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The respective [[Subscriber]] object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See [[StreamPropertyChangedEvent]] to learn more.\n   *\n   * @param enabled `true` to publish the audio stream, `false` to unpublish it\n   */\n\n\n  Publisher.prototype.publishAudio = function (enabled) {\n    var _this = this;\n\n    if (this.stream.audioActive !== enabled) {\n      var affectedMediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n      affectedMediaStream.getAudioTracks().forEach(function (track) {\n        track.enabled = enabled;\n      });\n\n      if (!!this.session && !!this.stream.streamId) {\n        this.session.openvidu.sendRequest('streamPropertyChanged', {\n          streamId: this.stream.streamId,\n          property: 'audioActive',\n          newValue: enabled,\n          reason: 'publishAudio'\n        }, function (error, response) {\n          if (error) {\n            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n          } else {\n            _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n\n            _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n\n            _this.session.sendVideoData(_this.stream.streamManager);\n          }\n        });\n      }\n\n      this.stream.audioActive = enabled;\n      logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n    }\n  };\n  /**\n   * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The [[Session]] object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The [[Publisher]] object of the local participant will also dispatch the exact same event\n   *\n   * The [[Session]] object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The respective [[Subscriber]] object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See [[StreamPropertyChangedEvent]] to learn more.\n   *\n   * @param enabled `true` to publish the video stream, `false` to unpublish it\n   * @param resource\n   * - If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n   * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n   * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.</li>\n   * - If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n   * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n   * will be used instead.\n   */\n\n\n  Publisher.prototype.publishVideo = function (enabled, resource) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var affectedMediaStream_1, mustRestartMediaStream_1, oldVideoTrack, replaceVideoTrack, mediaStream, error_1;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.stream.videoActive !== enabled)) return [3\n              /*break*/\n              , 9];\n              affectedMediaStream_1 = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n              mustRestartMediaStream_1 = false;\n              affectedMediaStream_1.getVideoTracks().forEach(function (track) {\n                track.enabled = enabled;\n\n                if (!enabled && resource === true) {\n                  track.stop();\n                } else if (enabled && track.readyState === 'ended') {\n                  // Resource was freed\n                  mustRestartMediaStream_1 = true;\n                }\n              });\n              if (!(!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:'))) return [3\n              /*break*/\n              , 2];\n              this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n\n              return [4\n              /*yield*/\n              , this.stream.removeFilterAux(true)];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              if (!mustRestartMediaStream_1) return [3\n              /*break*/\n              , 8];\n              oldVideoTrack = affectedMediaStream_1.getVideoTracks()[0];\n              affectedMediaStream_1.removeTrack(oldVideoTrack);\n\n              replaceVideoTrack = function (tr) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var _this = this;\n\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        affectedMediaStream_1.addTrack(tr);\n                        if (!this.stream.isLocalStreamPublished) return [3\n                        /*break*/\n                        , 2];\n                        return [4\n                        /*yield*/\n                        , this.replaceTrackInRtcRtpSender(tr)];\n\n                      case 1:\n                        _a.sent();\n\n                        _a.label = 2;\n\n                      case 2:\n                        if (!!this.stream.lastVBFilter) {\n                          setTimeout(function () {\n                            return __awaiter(_this, void 0, void 0, function () {\n                              var options, lastExecMethod;\n                              return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                  case 0:\n                                    options = this.stream.lastVBFilter.options;\n                                    lastExecMethod = this.stream.lastVBFilter.lastExecMethod;\n\n                                    if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                      options = Object.assign({}, options, lastExecMethod.params);\n                                    }\n\n                                    return [4\n                                    /*yield*/\n                                    , this.stream.applyFilter(this.stream.lastVBFilter.type, options)];\n\n                                  case 1:\n                                    _a.sent();\n\n                                    delete this.stream.lastVBFilter;\n                                    return [2\n                                    /*return*/\n                                    ];\n                                }\n                              });\n                            });\n                          }, 1);\n                        }\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n\n              if (!(!!resource && resource instanceof MediaStreamTrack)) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , replaceVideoTrack(resource)];\n\n            case 3:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 4:\n              _a.trys.push([4, 7,, 8]);\n\n              return [4\n              /*yield*/\n              , navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: this.stream.lastVideoTrackConstraints\n              })];\n\n            case 5:\n              mediaStream = _a.sent();\n              return [4\n              /*yield*/\n              , replaceVideoTrack(mediaStream.getVideoTracks()[0])];\n\n            case 6:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 7:\n              error_1 = _a.sent();\n              return [2\n              /*return*/\n              , reject(error_1)];\n\n            case 8:\n              if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest('streamPropertyChanged', {\n                  streamId: this.stream.streamId,\n                  property: 'videoActive',\n                  newValue: enabled,\n                  reason: 'publishVideo'\n                }, function (error, response) {\n                  if (error) {\n                    logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                  } else {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n\n                    _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n\n                    _this.session.sendVideoData(_this.stream.streamManager);\n                  }\n                });\n              }\n\n              this.stream.videoActive = enabled;\n              logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n              return [2\n              /*return*/\n              , resolve()];\n\n            case 9:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Call this method before [[Session.publish]] if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n   */\n\n\n  Publisher.prototype.subscribeToRemote = function (value) {\n    value = value !== undefined ? value : true;\n    this.isSubscribedToRemote = value;\n    this.stream.subscribeToMyRemote(value);\n  };\n  /**\n   * See [[EventDispatcher.on]]\n   */\n\n\n  Publisher.prototype.on = function (type, handler) {\n    var _this = this;\n\n    _super.prototype.on.call(this, type, handler);\n\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.on('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.once]]\n   */\n\n\n  Publisher.prototype.once = function (type, handler) {\n    var _this = this;\n\n    _super.prototype.once.call(this, type, handler);\n\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.once('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * See [[EventDispatcher.off]]\n   */\n\n\n  Publisher.prototype.off = function (type, handler) {\n    _super.prototype.off.call(this, type, handler);\n\n    return this;\n  };\n  /**\n   * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n   * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n   * and publishing the new one).\n   *\n   * You can get this new MediaStreamTrack by using the native Web API or simply with [[OpenVidu.getUserMedia]] method.\n   *\n   * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n   * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n   * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n   *\n   * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n   * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n   */\n\n\n  Publisher.prototype.replaceTrack = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.replaceTrackAux(track, true)];\n      });\n    });\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.initialize = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var constraints = {};\n      var constraintsAux = {};\n      var timeForDialogEvent = 2000;\n      var startTime;\n\n      var errorCallback = function (openViduError) {\n        _this.accessDenied = true;\n        _this.accessAllowed = false;\n        logger.error(\"Publisher initialization failed. \".concat(openViduError.name, \": \").concat(openViduError.message));\n        return reject(openViduError);\n      };\n\n      var successCallback = function (mediaStream) {\n        var _a, _b;\n\n        _this.accessAllowed = true;\n        _this.accessDenied = false;\n\n        if (typeof MediaStreamTrack !== 'undefined' && _this.properties.audioSource instanceof MediaStreamTrack) {\n          mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n          mediaStream.addTrack(_this.properties.audioSource);\n        }\n\n        if (typeof MediaStreamTrack !== 'undefined' && _this.properties.videoSource instanceof MediaStreamTrack) {\n          mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n          mediaStream.addTrack(_this.properties.videoSource);\n        } // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n\n\n        if (!!mediaStream.getAudioTracks()[0]) {\n          var enabled = _this.stream.audioActive !== undefined && _this.stream.audioActive !== null ? _this.stream.audioActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n          mediaStream.getAudioTracks()[0].enabled = enabled;\n        }\n\n        if (!!mediaStream.getVideoTracks()[0]) {\n          var enabled = _this.stream.videoActive !== undefined && _this.stream.videoActive !== null ? _this.stream.videoActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n          mediaStream.getVideoTracks()[0].enabled = enabled;\n        } // Set Content Hint on all MediaStreamTracks\n\n\n        for (var _i = 0, _c = mediaStream.getAudioTracks(); _i < _c.length; _i++) {\n          var track = _c[_i];\n\n          if (!((_a = track.contentHint) === null || _a === void 0 ? void 0 : _a.length)) {\n            // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n            // https://w3c.github.io/mst-content-hint/#audio-content-hints\n            track.contentHint = '';\n            logger.info(\"Audio track Content Hint set: '\".concat(track.contentHint, \"'\"));\n          }\n        }\n\n        for (var _d = 0, _e = mediaStream.getVideoTracks(); _d < _e.length; _d++) {\n          var track = _e[_d];\n\n          if (!((_b = track.contentHint) === null || _b === void 0 ? void 0 : _b.length)) {\n            // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n            // https://w3c.github.io/mst-content-hint/#video-content-hints\n            switch (_this.stream.typeOfVideo) {\n              case TypeOfVideo_1.TypeOfVideo.SCREEN:\n                track.contentHint = \"detail\";\n                break;\n\n              case TypeOfVideo_1.TypeOfVideo.CUSTOM:\n                logger.warn(\"CUSTOM type video track was provided without Content Hint!\");\n                track.contentHint = \"motion\";\n                break;\n\n              case TypeOfVideo_1.TypeOfVideo.CAMERA:\n              case TypeOfVideo_1.TypeOfVideo.IPCAM:\n              default:\n                track.contentHint = \"motion\";\n                break;\n            }\n\n            logger.info(\"Video track Content Hint set: '\".concat(track.contentHint, \"'\"));\n          }\n        }\n\n        _this.initializeVideoReference(mediaStream);\n\n        if (!_this.stream.displayMyRemote()) {\n          // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n          // avoid early 'streamPlaying' event\n          _this.stream.updateMediaStreamInVideos();\n        }\n\n        delete _this.firstVideoElement;\n\n        if (_this.stream.isSendVideo()) {\n          // Has video track\n          _this.getVideoDimensions().then(function (dimensions) {\n            _this.stream.videoDimensions = {\n              width: dimensions.width,\n              height: dimensions.height\n            };\n\n            if (_this.stream.isSendScreen()) {\n              // Set interval to listen for screen resize events\n              _this.screenShareResizeInterval = setInterval(function () {\n                var settings = mediaStream.getVideoTracks()[0].getSettings();\n                var newWidth = settings.width;\n                var newHeight = settings.height;\n                var widthChanged = newWidth != null && newWidth !== _this.stream.videoDimensions.width;\n                var heightChanged = newHeight != null && newHeight !== _this.stream.videoDimensions.height;\n\n                if (_this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                  _this.openvidu.sendVideoDimensionsChangedEvent(_this, 'screenResized', _this.stream.videoDimensions.width, _this.stream.videoDimensions.height, newWidth || 0, newHeight || 0);\n                }\n              }, 650);\n            }\n\n            _this.stream.isLocalStreamReadyToPublish = true;\n\n            _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n          });\n        } else {\n          // Only audio track (no videoDimensions)\n          _this.stream.isLocalStreamReadyToPublish = true;\n\n          _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n        }\n\n        return resolve();\n      };\n\n      var getMediaSuccess = function (mediaStream, definedAudioConstraint) {\n        _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n        if (_this.stream.isSendScreen() && _this.stream.isSendAudio()) {\n          // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n          constraintsAux.audio = definedAudioConstraint;\n          constraintsAux.video = false;\n          startTime = Date.now();\n\n          _this.setPermissionDialogTimer(timeForDialogEvent);\n\n          navigator.mediaDevices.getUserMedia(constraintsAux).then(function (audioOnlyStream) {\n            _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n            mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n            successCallback(mediaStream);\n          }).catch(function (error) {\n            _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n            mediaStream.getAudioTracks().forEach(function (track) {\n              track.stop();\n            });\n            mediaStream.getVideoTracks().forEach(function (track) {\n              track.stop();\n            });\n            errorCallback(_this.openvidu.generateAudioDeviceError(error, constraints));\n            return;\n          });\n        } else {\n          successCallback(mediaStream);\n        }\n      };\n\n      var getMediaError = function (error) {\n        logger.error(\"getMediaError: \".concat(error.toString()));\n\n        _this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n\n        if (error.name === 'Error') {\n          // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n          error.name = error.constructor.name;\n        }\n\n        var errorName, errorMessage;\n\n        switch (error.name.toLowerCase()) {\n          case 'notfounderror':\n            navigator.mediaDevices.getUserMedia({\n              audio: false,\n              video: constraints.video\n            }).then(function (mediaStream) {\n              mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n              errorMessage = error.toString();\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            }).catch(function (e) {\n              errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n              errorMessage = error.toString();\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            });\n            break;\n\n          case 'notallowederror':\n            errorName = _this.stream.isSendScreen() ? OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED : OpenViduError_1.OpenViduErrorName.DEVICE_ACCESS_DENIED;\n            errorMessage = error.toString();\n            errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            break;\n\n          case 'overconstrainederror':\n            navigator.mediaDevices.getUserMedia({\n              audio: false,\n              video: constraints.video\n            }).then(function (mediaStream) {\n              mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n\n              if (error.constraint.toLowerCase() === 'deviceid') {\n                errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                errorMessage = \"Audio input device with deviceId '\" + constraints.audio.deviceId.exact + \"' not found\";\n              } else {\n                errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                errorMessage = \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n              }\n\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            }).catch(function (e) {\n              if (error.constraint.toLowerCase() === 'deviceid') {\n                errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                errorMessage = \"Video input device with deviceId '\" + constraints.video.deviceId.exact + \"' not found\";\n              } else {\n                errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                errorMessage = \"Video input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n              }\n\n              errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            });\n            break;\n\n          case 'aborterror':\n          case 'notreadableerror':\n            errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n            errorMessage = error.toString();\n            errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            break;\n\n          default:\n            errorName = OpenViduError_1.OpenViduErrorName.GENERIC_ERROR;\n            errorMessage = error.toString();\n            errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n            break;\n        }\n      };\n\n      _this.openvidu.generateMediaConstraints(_this.properties).then(function (myConstraints) {\n        var _a, _b;\n\n        if (!!myConstraints.videoTrack && !!myConstraints.audioTrack || !!myConstraints.audioTrack && ((_a = myConstraints.constraints) === null || _a === void 0 ? void 0 : _a.video) === false || !!myConstraints.videoTrack && ((_b = myConstraints.constraints) === null || _b === void 0 ? void 0 : _b.audio) === false) {\n          // No need to call getUserMedia at all. MediaStreamTracks already provided\n          successCallback(_this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), _this.stream)); // Return as we do not need to process further\n\n          return;\n        }\n\n        constraints = myConstraints.constraints;\n        var outboundStreamOptions = {\n          mediaConstraints: constraints,\n          publisherProperties: _this.properties\n        };\n\n        _this.stream.setOutboundStreamOptions(outboundStreamOptions);\n\n        var definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n        constraintsAux.audio = _this.stream.isSendScreen() ? false : definedAudioConstraint;\n        constraintsAux.video = constraints.video;\n        startTime = Date.now();\n\n        _this.setPermissionDialogTimer(timeForDialogEvent);\n\n        if (_this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron()) {\n          navigator.mediaDevices['getDisplayMedia']({\n            video: true\n          }).then(function (mediaStream) {\n            _this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n\n            getMediaSuccess(mediaStream, definedAudioConstraint);\n          }).catch(function (error) {\n            getMediaError(error);\n          });\n        } else {\n          _this.stream.lastVideoTrackConstraints = constraintsAux.video;\n          navigator.mediaDevices.getUserMedia(constraintsAux).then(function (mediaStream) {\n            _this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, _this.stream);\n\n            getMediaSuccess(mediaStream, definedAudioConstraint);\n          }).catch(function (error) {\n            getMediaError(error);\n          });\n        }\n      }).catch(function (error) {\n        errorCallback(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.replaceTrackAux = function (track, updateLastConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trackOriginalEnabledValue, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            trackOriginalEnabledValue = track.enabled;\n\n            if (track.kind === 'video') {\n              track.enabled = this.stream.videoActive;\n            } else if (track.kind === 'audio') {\n              track.enabled = this.stream.audioActive;\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7,, 8]);\n\n            if (!this.stream.isLocalStreamPublished) return [3\n            /*break*/\n            , 4]; // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n            // If it has not been published yet, replacing it on the MediaStream object is enough\n\n            return [4\n            /*yield*/\n            , this.replaceTrackInMediaStream(track, updateLastConstraints)];\n\n          case 2:\n            // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n            // If it has not been published yet, replacing it on the MediaStream object is enough\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.replaceTrackInRtcRtpSender(track)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            return [4\n            /*yield*/\n            , this.replaceTrackInMediaStream(track, updateLastConstraints)];\n\n          case 5:\n            // Publisher not published. Simply replace the track on the local MediaStream\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            error_2 = _a.sent();\n            track.enabled = trackOriginalEnabledValue;\n            throw error_2;\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   *\n   * To obtain the videoDimensions we wait for the video reference to have enough metadata\n   * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n   * use the HTMLVideoElement properties videoWidth and videoHeight\n   */\n\n\n  Publisher.prototype.getVideoDimensions = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n      var requiresDomInsertion = platform.isIonicIos() || platform.isIOSWithSafari();\n      var loadedmetadataListener;\n\n      var resolveDimensions = function () {\n        var width;\n        var height;\n\n        if (typeof _this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n          var settings = _this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n\n          width = settings.width || _this.videoReference.videoWidth;\n          height = settings.height || _this.videoReference.videoHeight;\n        } else {\n          logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n          width = _this.videoReference.videoWidth;\n          height = _this.videoReference.videoHeight;\n        }\n\n        if (loadedmetadataListener != null) {\n          _this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n        }\n\n        if (requiresDomInsertion) {\n          document.body.removeChild(_this.videoReference);\n        }\n\n        return resolve({\n          width: width,\n          height: height\n        });\n      };\n\n      if (_this.videoReference.readyState >= 1) {\n        // The video already has metadata available\n        // No need of loadedmetadata event\n        resolveDimensions();\n      } else {\n        // The video does not have metadata available yet\n        // Must listen to loadedmetadata event\n        loadedmetadataListener = function () {\n          if (!_this.videoReference.videoWidth) {\n            var interval_1 = setInterval(function () {\n              if (!!_this.videoReference.videoWidth) {\n                clearInterval(interval_1);\n                resolveDimensions();\n              }\n            }, 40);\n          } else {\n            resolveDimensions();\n          }\n        };\n\n        _this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n\n        if (requiresDomInsertion) {\n          document.body.appendChild(_this.videoReference);\n        }\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.reestablishStreamPlayingEvent = function () {\n    if (this.ee.getListeners('streamPlaying').length > 0) {\n      this.addPlayEventToFirstVideo();\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.initializeVideoReference = function (mediaStream) {\n    this.videoReference = document.createElement('video');\n    this.videoReference.setAttribute('muted', 'true');\n    this.videoReference.style.display = 'none';\n\n    if (platform.isSafariBrowser() || platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser())) {\n      this.videoReference.setAttribute('playsinline', 'true');\n    }\n\n    this.stream.setMediaStream(mediaStream);\n\n    if (!!this.firstVideoElement) {\n      this.createVideoElement(this.firstVideoElement.targetElement, this.properties.insertMode);\n    }\n\n    this.videoReference.srcObject = mediaStream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Publisher.prototype.replaceTrackInMediaStream = function (track, updateLastConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mediaStream, removedTrack;\n      return __generator(this, function (_a) {\n        mediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n\n        if (track.kind === 'video') {\n          removedTrack = mediaStream.getVideoTracks()[0];\n\n          if (updateLastConstraints) {\n            this.stream.lastVideoTrackConstraints = track.getConstraints();\n          }\n        } else {\n          removedTrack = mediaStream.getAudioTracks()[0];\n        }\n\n        mediaStream.removeTrack(removedTrack);\n        removedTrack.stop();\n        mediaStream.addTrack(track);\n\n        if (track.kind === 'video' && this.stream.isLocalStreamPublished && updateLastConstraints) {\n          this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n          this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /* Private methods */\n\n\n  Publisher.prototype.setPermissionDialogTimer = function (waitTime) {\n    var _this = this;\n\n    this.permissionDialogTimeout = setTimeout(function () {\n      _this.emitEvent('accessDialogOpened', []);\n    }, waitTime);\n  };\n\n  Publisher.prototype.clearPermissionDialogTimer = function (startTime, waitTime) {\n    clearTimeout(this.permissionDialogTimeout);\n\n    if (Date.now() - startTime > waitTime) {\n      // Permission dialog was shown and now is closed\n      this.emitEvent('accessDialogClosed', []);\n    }\n  };\n\n  Publisher.prototype.replaceTrackInRtcRtpSender = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      var senders, sender;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            senders = this.stream.getRTCPeerConnection().getSenders();\n\n            if (track.kind === 'video') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'video';\n              });\n\n              if (!sender) {\n                throw new Error('There\\'s no replaceable track for that kind of MediaStreamTrack in this Publisher object');\n              }\n            } else if (track.kind === 'audio') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'audio';\n              });\n\n              if (!sender) {\n                throw new Error('There\\'s no replaceable track for that kind of MediaStreamTrack in this Publisher object');\n              }\n            } else {\n              throw new Error('Unknown track kind ' + track.kind);\n            }\n\n            return [4\n            /*yield*/\n            , sender.replaceTrack(track)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Publisher;\n}(StreamManager_1.StreamManager);\n\nexports.Publisher = Publisher;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","__extends","targEl","properties","openvidu","_super","Stream_1","session","Session_1","publisherProperties","mediaConstraints","_this","Platform_1","stream","ee","on","reason","isLocalStreamPublished","streamEvent","StreamEvent_1","emitEvent","callDefaultBehavior","Publisher","enabled","audioActive","affectedMediaStream","displayMyRemote","localMediaStreamWhenSubscribedToRemote","getMediaStream","getAudioTracks","forEach","track","streamId","sendRequest","property","newValue","error","response","StreamPropertyChangedEvent_1","sendVideoData","streamManager","info","resource","Promise","resolve","reject","videoActive","affectedMediaStream_1","mustRestartMediaStream_1","getVideoTracks","stop","readyState","filter","type","startsWith","lastVBFilter","removeFilterAux","_a","oldVideoTrack","removeTrack","replaceVideoTrack","tr","addTrack","replaceTrackInRtcRtpSender","setTimeout","options","lastExecMethod","method","Object","assign","params","applyFilter","MediaStreamTrack","navigator","mediaDevices","getUserMedia","audio","video","lastVideoTrackConstraints","mediaStream","error_1","value","undefined","isSubscribedToRemote","subscribeToMyRemote","handler","call","accessAllowed","accessDenied","once","off","replaceTrackAux","constraints","constraintsAux","timeForDialogEvent","startTime","errorCallback","openViduError","name","concat","message","successCallback","audioSource","videoSource","outboundStreamOpts","publishAudio","publishVideo","_i","contentHint","length","_d","_b","typeOfVideo","TypeOfVideo_1","SCREEN","CUSTOM","warn","CAMERA","IPCAM","initializeVideoReference","updateMediaStreamInVideos","firstVideoElement","isSendVideo","getVideoDimensions","then","videoDimensions","width","dimensions","height","isSendScreen","screenShareResizeInterval","setInterval","settings","getSettings","newWidth","newHeight","widthChanged","heightChanged","sendVideoDimensionsChangedEvent","isLocalStreamReadyToPublish","getMediaSuccess","definedAudioConstraint","clearPermissionDialogTimer","isSendAudio","Date","now","setPermissionDialogTimer","audioOnlyStream","catch","generateAudioDeviceError","getMediaError","toString","constructor","errorName","errorMessage","toLowerCase","OpenViduError_1","INPUT_AUDIO_DEVICE_NOT_FOUND","INPUT_VIDEO_DEVICE_NOT_FOUND","SCREEN_CAPTURE_DENIED","DEVICE_ACCESS_DENIED","constraint","deviceId","exact","PUBLISHER_PROPERTIES_ERROR","DEVICE_ALREADY_IN_USE","GENERIC_ERROR","generateMediaConstraints","myConstraints","videoTrack","audioTrack","addAlreadyProvidedTracks","MediaStream","outboundStreamOptions","setOutboundStreamOptions","isElectron","updateLastConstraints","trackOriginalEnabledValue","kind","replaceTrackInMediaStream","error_2","requiresDomInsertion","isIonicIos","isIOSWithSafari","loadedmetadataListener","resolveDimensions","videoReference","videoWidth","videoHeight","getDescription","removeEventListener","document","body","removeChild","interval_1","clearInterval","addEventListener","appendChild","getListeners","addPlayEventToFirstVideo","createElement","setAttribute","style","display","isSafariBrowser","isIPhoneOrIPad","isChromeMobileBrowser","isEdgeMobileBrowser","isOperaMobileBrowser","isFirefoxMobileBrowser","setMediaStream","createVideoElement","targetElement","insertMode","srcObject","removedTrack","getConstraints","sendNewVideoDimensionsIfRequired","waitTime","permissionDialogTimeout","clearTimeout","senders","getRTCPeerConnection","getSenders","sender","find","s","Error","replaceTrack","StreamManager_1","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenVidu\\Publisher.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { OpenVidu } from './OpenVidu';\nimport { Session } from './Session';\nimport { Stream } from './Stream';\nimport { StreamManager } from './StreamManager';\nimport { PublisherProperties } from '../OpenViduInternal/Interfaces/Public/PublisherProperties';\nimport { PublisherEventMap } from '../OpenViduInternal/Events/EventMap/PublisherEventMap';\nimport { StreamEvent } from '../OpenViduInternal/Events/StreamEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { VideoInsertMode } from '../OpenViduInternal/Enums/VideoInsertMode';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\nimport { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with [[OpenVidu.initPublisher]] method.\n *\n * See available event listeners at [[PublisherEventMap]].\n */\nexport class Publisher extends StreamManager {\n\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n    accessAllowed = false;\n\n    /**\n     * Whether you have called [[Publisher.subscribeToRemote]] with value `true` or `false` (*false* by default)\n     */\n    isSubscribedToRemote = false;\n\n    /**\n     * The [[Session]] to which the Publisher belongs\n     */\n    session: Session; // Initialized by Session.publish(Publisher)\n\n    private accessDenied = false;\n    protected properties: PublisherProperties;\n    private permissionDialogTimeout: NodeJS.Timer;\n\n    /**\n     * @hidden\n     */\n    openvidu: OpenVidu;\n    /**\n     * @hidden\n     */\n    videoReference: HTMLVideoElement;\n    /**\n     * @hidden\n     */\n    screenShareResizeInterval: NodeJS.Timer;\n\n    /**\n     * @hidden\n     */\n    constructor(targEl: string | HTMLElement, properties: PublisherProperties, openvidu: OpenVidu) {\n        super(new Stream((!!openvidu.session) ? openvidu.session : new Session(openvidu), { publisherProperties: properties, mediaConstraints: {} }), targEl);\n        platform = PlatformUtils.getInstance();\n        this.properties = properties;\n        this.openvidu = openvidu;\n\n        this.stream.ee.on('local-stream-destroyed', (reason: string) => {\n            this.stream.isLocalStreamPublished = false;\n            const streamEvent = new StreamEvent(true, this, 'streamDestroyed', this.stream, reason);\n            this.emitEvent('streamDestroyed', [streamEvent]);\n            streamEvent.callDefaultBehavior();\n        });\n    }\n\n\n    /**\n     * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n     *\n     * #### Events dispatched\n     *\n     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n     *\n     * The [[Session]] object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n     * The [[Publisher]] object of the local participant will also dispatch the exact same event\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n     * The respective [[Subscriber]] object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n     *\n     * See [[StreamPropertyChangedEvent]] to learn more.\n     *\n     * @param enabled `true` to publish the audio stream, `false` to unpublish it\n     */\n    publishAudio(enabled: boolean): void {\n        if (this.stream.audioActive !== enabled) {\n            const affectedMediaStream: MediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote! : this.stream.getMediaStream();\n            affectedMediaStream.getAudioTracks().forEach((track) => {\n                track.enabled = enabled;\n            });\n            if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest(\n                    'streamPropertyChanged',\n                    {\n                        streamId: this.stream.streamId,\n                        property: 'audioActive',\n                        newValue: enabled,\n                        reason: 'publishAudio'\n                    },\n                    (error, response) => {\n                        if (error) {\n                            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                        } else {\n                            this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this.session, this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n                            this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this, this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n                            this.session.sendVideoData(this.stream.streamManager);\n                        }\n                    });\n            }\n            this.stream.audioActive = enabled;\n            logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n        }\n    }\n\n\n    /**\n     * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n     *\n     * #### Events dispatched\n     *\n     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n     *\n     * The [[Session]] object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n     * The [[Publisher]] object of the local participant will also dispatch the exact same event\n     *\n     * The [[Session]] object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n     * The respective [[Subscriber]] object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n     *\n     * See [[StreamPropertyChangedEvent]] to learn more.\n     *\n     * @param enabled `true` to publish the video stream, `false` to unpublish it\n     * @param resource\n     * - If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n     * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n     * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.</li>\n     * - If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n     * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n     * will be used instead.\n     */\n    publishVideo<T extends boolean>(enabled: T, resource?: T extends false ? boolean : MediaStreamTrack): Promise<void> {\n\n        return new Promise(async (resolve, reject) => {\n\n            if (this.stream.videoActive !== enabled) {\n\n                const affectedMediaStream: MediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote! : this.stream.getMediaStream();\n                let mustRestartMediaStream = false;\n                affectedMediaStream.getVideoTracks().forEach((track) => {\n                    track.enabled = enabled;\n                    if (!enabled && resource === true) {\n                        track.stop();\n                    } else if (enabled && track.readyState === 'ended') {\n                        // Resource was freed\n                        mustRestartMediaStream = true;\n                    }\n                });\n\n                // There is a Virtual Background filter applied that must be removed in case the hardware must be freed \n                if (!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:')) {\n                    this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n                    await this.stream.removeFilterAux(true);\n                }\n\n                if (mustRestartMediaStream) {\n                    const oldVideoTrack = affectedMediaStream.getVideoTracks()[0];\n                    affectedMediaStream.removeTrack(oldVideoTrack);\n\n                    const replaceVideoTrack = async (tr: MediaStreamTrack) => {\n                        affectedMediaStream.addTrack(tr);\n                        if (this.stream.isLocalStreamPublished) {\n                            await this.replaceTrackInRtcRtpSender(tr);\n                        }\n                        if (!!this.stream.lastVBFilter) {\n                            setTimeout(async () => {\n                                let options = this.stream.lastVBFilter!.options;\n                                const lastExecMethod = this.stream.lastVBFilter!.lastExecMethod;\n                                if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                    options = Object.assign({}, options, lastExecMethod.params);\n                                }\n                                await this.stream.applyFilter(this.stream.lastVBFilter!.type, options);\n                                delete this.stream.lastVBFilter;\n                            }, 1);\n                        }\n                    }\n\n                    if (!!resource && resource instanceof MediaStreamTrack) {\n                        await replaceVideoTrack(resource);\n                    } else {\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: this.stream.lastVideoTrackConstraints });\n                            await replaceVideoTrack(mediaStream.getVideoTracks()[0]);\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                }\n\n                if (!!this.session && !!this.stream.streamId) {\n                    this.session.openvidu.sendRequest(\n                        'streamPropertyChanged',\n                        {\n                            streamId: this.stream.streamId,\n                            property: 'videoActive',\n                            newValue: enabled,\n                            reason: 'publishVideo'\n                        },\n                        (error, response) => {\n                            if (error) {\n                                logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                            } else {\n                                this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this.session, this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n                                this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent(this, this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n                                this.session.sendVideoData(this.stream.streamManager);\n                            }\n                        });\n                }\n                this.stream.videoActive = enabled;\n                logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n                return resolve();\n            }\n        });\n    }\n\n\n    /**\n     * Call this method before [[Session.publish]] if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n     */\n    subscribeToRemote(value?: boolean): void {\n        value = (value !== undefined) ? value : true;\n        this.isSubscribedToRemote = value;\n        this.stream.subscribeToMyRemote(value);\n    }\n\n\n    /**\n     * See [[EventDispatcher.on]]\n     */\n    on<K extends keyof PublisherEventMap>(type: K, handler: (event: PublisherEventMap[K]) => void): this {\n\n        super.on(<any>type, handler);\n\n        if (type === 'streamCreated') {\n            if (!!this.stream && this.stream.isLocalStreamPublished) {\n                this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n            } else {\n                this.stream.ee.on('stream-created-by-publisher', () => {\n                    this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n                });\n            }\n        }\n        if (type === 'accessAllowed') {\n            if (this.accessAllowed) {\n                this.emitEvent('accessAllowed', []);\n            }\n        }\n        if (type === 'accessDenied') {\n            if (this.accessDenied) {\n                this.emitEvent('accessDenied', []);\n            }\n        }\n        return this;\n    }\n\n\n    /**\n     * See [[EventDispatcher.once]]\n     */\n    once<K extends keyof PublisherEventMap>(type: K, handler: (event: PublisherEventMap[K]) => void): this {\n\n        super.once(<any>type, handler);\n\n        if (type === 'streamCreated') {\n            if (!!this.stream && this.stream.isLocalStreamPublished) {\n                this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n            } else {\n                this.stream.ee.once('stream-created-by-publisher', () => {\n                    this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n                });\n            }\n        }\n        if (type === 'accessAllowed') {\n            if (this.accessAllowed) {\n                this.emitEvent('accessAllowed', []);\n            }\n        }\n        if (type === 'accessDenied') {\n            if (this.accessDenied) {\n                this.emitEvent('accessDenied', []);\n            }\n        }\n        return this;\n    }\n\n\n    /**\n     * See [[EventDispatcher.off]]\n     */\n    off<K extends keyof PublisherEventMap>(type: K, handler?: (event: PublisherEventMap[K]) => void): this {\n        super.off(<any>type, handler);\n        return this;\n    }\n\n\n    /**\n     * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n     * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n     * and publishing the new one).\n     *\n     * You can get this new MediaStreamTrack by using the native Web API or simply with [[OpenVidu.getUserMedia]] method.\n     *\n     * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n     * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n     * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n     *\n     * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n     * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n     */\n    async replaceTrack(track: MediaStreamTrack): Promise<void> {\n        return this.replaceTrackAux(track, true);\n    }\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    initialize(): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            let constraints: MediaStreamConstraints = {};\n            let constraintsAux: MediaStreamConstraints = {};\n            const timeForDialogEvent = 2000;\n            let startTime;\n\n            const errorCallback = (openViduError: OpenViduError) => {\n                this.accessDenied = true;\n                this.accessAllowed = false;\n                logger.error(`Publisher initialization failed. ${openViduError.name}: ${openViduError.message}`)\n                return reject(openViduError);\n            };\n\n            const successCallback = (mediaStream: MediaStream) => {\n                this.accessAllowed = true;\n                this.accessDenied = false;\n\n                if (typeof MediaStreamTrack !== 'undefined' && this.properties.audioSource instanceof MediaStreamTrack) {\n                    mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n                    mediaStream.addTrack((<MediaStreamTrack>this.properties.audioSource));\n                }\n\n                if (typeof MediaStreamTrack !== 'undefined' && this.properties.videoSource instanceof MediaStreamTrack) {\n                    mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n                    mediaStream.addTrack((<MediaStreamTrack>this.properties.videoSource));\n                }\n\n                // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n                if (!!mediaStream.getAudioTracks()[0]) {\n                    const enabled = (this.stream.audioActive !== undefined && this.stream.audioActive !== null) ? this.stream.audioActive : !!this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n                    mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!mediaStream.getVideoTracks()[0]) {\n                    const enabled = (this.stream.videoActive !== undefined && this.stream.videoActive !== null) ? this.stream.videoActive : !!this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n                    mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n\n                // Set Content Hint on all MediaStreamTracks\n                for (const track of mediaStream.getAudioTracks()) {\n                    if (!track.contentHint?.length) {\n                        // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n                        // https://w3c.github.io/mst-content-hint/#audio-content-hints\n                        track.contentHint = '';\n                        logger.info(`Audio track Content Hint set: '${track.contentHint}'`);\n                    }\n                }\n                for (const track of mediaStream.getVideoTracks()) {\n                    if (!track.contentHint?.length) {\n                        // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n                        // https://w3c.github.io/mst-content-hint/#video-content-hints\n                        switch (this.stream.typeOfVideo) {\n                            case TypeOfVideo.SCREEN:\n                                track.contentHint = \"detail\";\n                                break;\n                            case TypeOfVideo.CUSTOM:\n                                logger.warn(\"CUSTOM type video track was provided without Content Hint!\");\n                                track.contentHint = \"motion\";\n                                break;\n                            case TypeOfVideo.CAMERA:\n                            case TypeOfVideo.IPCAM:\n                            default:\n                                track.contentHint = \"motion\";\n                                break;\n                        }\n                        logger.info(`Video track Content Hint set: '${track.contentHint}'`);\n                    }\n                }\n\n                this.initializeVideoReference(mediaStream);\n\n                if (!this.stream.displayMyRemote()) {\n                    // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n                    // avoid early 'streamPlaying' event\n                    this.stream.updateMediaStreamInVideos();\n                }\n                delete this.firstVideoElement;\n\n                if (this.stream.isSendVideo()) {\n                    // Has video track\n                    this.getVideoDimensions().then(dimensions => {\n                        this.stream.videoDimensions = {\n                            width: dimensions.width,\n                            height: dimensions.height\n                        };\n\n                        if (this.stream.isSendScreen()) {\n                            // Set interval to listen for screen resize events\n                            this.screenShareResizeInterval = setInterval(() => {\n                                const settings: MediaTrackSettings = mediaStream.getVideoTracks()[0].getSettings();\n                                const newWidth = settings.width;\n                                const newHeight = settings.height;\n                                const widthChanged = newWidth != null && newWidth !== this.stream.videoDimensions.width;\n                                const heightChanged = newHeight != null && newHeight !== this.stream.videoDimensions.height;\n                                if (this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                                    this.openvidu.sendVideoDimensionsChangedEvent(\n                                        this,\n                                        'screenResized',\n                                        this.stream.videoDimensions.width,\n                                        this.stream.videoDimensions.height,\n                                        newWidth || 0,\n                                        newHeight || 0\n                                    );\n                                }\n                            }, 650);\n                        }\n\n                        this.stream.isLocalStreamReadyToPublish = true;\n                        this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                    });\n                } else {\n                    // Only audio track (no videoDimensions)\n                    this.stream.isLocalStreamReadyToPublish = true;\n                    this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                }\n\n                return resolve();\n            };\n\n            const getMediaSuccess = (mediaStream: MediaStream, definedAudioConstraint) => {\n                this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                if (this.stream.isSendScreen() && this.stream.isSendAudio()) {\n                    // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n                    constraintsAux.audio = definedAudioConstraint;\n                    constraintsAux.video = false;\n                    startTime = Date.now();\n                    this.setPermissionDialogTimer(timeForDialogEvent);\n\n                    navigator.mediaDevices.getUserMedia(constraintsAux)\n                        .then(audioOnlyStream => {\n                            this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                            mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n                            successCallback(mediaStream);\n                        })\n                        .catch(error => {\n                            this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                            mediaStream.getAudioTracks().forEach((track) => {\n                                track.stop();\n                            });\n                            mediaStream.getVideoTracks().forEach((track) => {\n                                track.stop();\n                            });\n                            errorCallback(this.openvidu.generateAudioDeviceError(error, constraints));\n                            return;\n                        });\n                } else {\n                    successCallback(mediaStream);\n                }\n            };\n\n            const getMediaError = error => {\n                logger.error(`getMediaError: ${error.toString()}`);\n                this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                if (error.name === 'Error') {\n                    // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n                    error.name = error.constructor.name;\n                }\n                let errorName, errorMessage;\n                switch (error.name.toLowerCase()) {\n                    case 'notfounderror':\n                        navigator.mediaDevices.getUserMedia({\n                            audio: false,\n                            video: constraints.video\n                        })\n                            .then(mediaStream => {\n                                mediaStream.getVideoTracks().forEach((track) => {\n                                    track.stop();\n                                });\n                                errorName = OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                                errorMessage = error.toString();\n                                errorCallback(new OpenViduError(errorName, errorMessage));\n                            }).catch(e => {\n                                errorName = OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                                errorMessage = error.toString();\n                                errorCallback(new OpenViduError(errorName, errorMessage));\n                            });\n                        break;\n                    case 'notallowederror':\n                        errorName = this.stream.isSendScreen() ? OpenViduErrorName.SCREEN_CAPTURE_DENIED : OpenViduErrorName.DEVICE_ACCESS_DENIED;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                    case 'overconstrainederror':\n                        navigator.mediaDevices.getUserMedia({\n                            audio: false,\n                            video: constraints.video\n                        })\n                            .then(mediaStream => {\n                                mediaStream.getVideoTracks().forEach((track) => {\n                                    track.stop();\n                                });\n                                if (error.constraint.toLowerCase() === 'deviceid') {\n                                    errorName = OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                                    errorMessage = \"Audio input device with deviceId '\" + (<ConstrainDOMStringParameters>(<MediaTrackConstraints>constraints.audio).deviceId!!).exact + \"' not found\";\n                                } else {\n                                    errorName = OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                                    errorMessage = \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                                }\n                                errorCallback(new OpenViduError(errorName, errorMessage));\n                            }).catch(e => {\n                                if (error.constraint.toLowerCase() === 'deviceid') {\n                                    errorName = OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                                    errorMessage = \"Video input device with deviceId '\" + (<ConstrainDOMStringParameters>(<MediaTrackConstraints>constraints.video).deviceId!!).exact + \"' not found\";\n                                } else {\n                                    errorName = OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                                    errorMessage = \"Video input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                                }\n                                errorCallback(new OpenViduError(errorName, errorMessage));\n                            });\n                        break;\n                    case 'aborterror':\n                    case 'notreadableerror':\n                        errorName = OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                    default:\n                        errorName = OpenViduErrorName.GENERIC_ERROR;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                }\n            }\n\n            this.openvidu.generateMediaConstraints(this.properties)\n                .then(myConstraints => {\n\n                    if (!!myConstraints.videoTrack && !!myConstraints.audioTrack ||\n                        !!myConstraints.audioTrack && myConstraints.constraints?.video === false ||\n                        !!myConstraints.videoTrack && myConstraints.constraints?.audio === false) {\n                        // No need to call getUserMedia at all. MediaStreamTracks already provided\n                        successCallback(this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), this.stream));\n                        // Return as we do not need to process further\n                        return;\n                    }\n\n                    constraints = myConstraints.constraints;\n\n                    const outboundStreamOptions = {\n                        mediaConstraints: constraints,\n                        publisherProperties: this.properties\n                    };\n                    this.stream.setOutboundStreamOptions(outboundStreamOptions);\n\n                    const definedAudioConstraint = ((constraints.audio === undefined) ? true : constraints.audio);\n                    constraintsAux.audio = this.stream.isSendScreen() ? false : definedAudioConstraint;\n                    constraintsAux.video = constraints.video;\n                    startTime = Date.now();\n                    this.setPermissionDialogTimer(timeForDialogEvent);\n\n                    if (this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron()) {\n                        navigator.mediaDevices['getDisplayMedia']({ video: true })\n                            .then(mediaStream => {\n                                this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n                                getMediaSuccess(mediaStream, definedAudioConstraint);\n                            })\n                            .catch(error => {\n                                getMediaError(error);\n                            });\n                    } else {\n                        this.stream.lastVideoTrackConstraints = constraintsAux.video;\n                        navigator.mediaDevices.getUserMedia(constraintsAux)\n                            .then(mediaStream => {\n                                this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, this.stream);\n                                getMediaSuccess(mediaStream, definedAudioConstraint);\n                            })\n                            .catch(error => {\n                                getMediaError(error);\n                            });\n                    }\n\n                })\n                .catch((error: OpenViduError) => {\n                    errorCallback(error);\n                });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    async replaceTrackAux(track: MediaStreamTrack, updateLastConstraints: boolean): Promise<void> {\n        // Set field \"enabled\" of the new track to the previous value\n        const trackOriginalEnabledValue: boolean = track.enabled;\n        if (track.kind === 'video') {\n            track.enabled = this.stream.videoActive;\n        } else if (track.kind === 'audio') {\n            track.enabled = this.stream.audioActive;\n        }\n        try {\n            if (this.stream.isLocalStreamPublished) {\n                // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n                // If it has not been published yet, replacing it on the MediaStream object is enough\n                await this.replaceTrackInMediaStream(track, updateLastConstraints);\n                return await this.replaceTrackInRtcRtpSender(track);\n            } else {\n                // Publisher not published. Simply replace the track on the local MediaStream\n                return await this.replaceTrackInMediaStream(track, updateLastConstraints);\n            }\n        } catch (error) {\n            track.enabled = trackOriginalEnabledValue;\n            throw error;\n        }\n    }\n\n    /**\n     * @hidden\n     *\n     * To obtain the videoDimensions we wait for the video reference to have enough metadata\n     * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n     * use the HTMLVideoElement properties videoWidth and videoHeight\n     */\n    getVideoDimensions(): Promise<{ width: number, height: number }> {\n        return new Promise((resolve, reject) => {\n\n            // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n            const requiresDomInsertion: boolean = platform.isIonicIos() || platform.isIOSWithSafari();\n\n            let loadedmetadataListener;\n            const resolveDimensions = () => {\n                let width: number;\n                let height: number;\n                if (typeof this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n                    const settings = this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n                    width = settings.width || this.videoReference.videoWidth;\n                    height = settings.height || this.videoReference.videoHeight;\n                } else {\n                    logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n                    width = this.videoReference.videoWidth;\n                    height = this.videoReference.videoHeight;\n                }\n\n                if (loadedmetadataListener != null) {\n                    this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n                }\n                if (requiresDomInsertion) {\n                    document.body.removeChild(this.videoReference);\n                }\n\n                return resolve({ width, height });\n            }\n\n            if (this.videoReference.readyState >= 1) {\n                // The video already has metadata available\n                // No need of loadedmetadata event\n                resolveDimensions();\n            } else {\n                // The video does not have metadata available yet\n                // Must listen to loadedmetadata event\n                loadedmetadataListener = () => {\n                    if (!this.videoReference.videoWidth) {\n                        let interval = setInterval(() => {\n                            if (!!this.videoReference.videoWidth) {\n                                clearInterval(interval);\n                                resolveDimensions();\n                            }\n                        }, 40);\n                    } else {\n                        resolveDimensions();\n                    }\n                };\n                this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n                if (requiresDomInsertion) {\n                    document.body.appendChild(this.videoReference);\n                }\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    reestablishStreamPlayingEvent() {\n        if (this.ee.getListeners('streamPlaying').length > 0) {\n            this.addPlayEventToFirstVideo();\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initializeVideoReference(mediaStream: MediaStream) {\n        this.videoReference = document.createElement('video');\n        this.videoReference.setAttribute('muted', 'true');\n        this.videoReference.style.display = 'none';\n        if (platform.isSafariBrowser() || (platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser()))) {\n            this.videoReference.setAttribute('playsinline', 'true');\n        }\n        this.stream.setMediaStream(mediaStream);\n        if (!!this.firstVideoElement) {\n            this.createVideoElement(this.firstVideoElement.targetElement, <VideoInsertMode>this.properties.insertMode);\n        }\n        this.videoReference.srcObject = mediaStream;\n    }\n\n    /**\n     * @hidden\n     */\n    async replaceTrackInMediaStream(track: MediaStreamTrack, updateLastConstraints: boolean): Promise<void> {\n        const mediaStream: MediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote! : this.stream.getMediaStream();\n        let removedTrack: MediaStreamTrack;\n        if (track.kind === 'video') {\n            removedTrack = mediaStream.getVideoTracks()[0];\n            if (updateLastConstraints) {\n                this.stream.lastVideoTrackConstraints = track.getConstraints();\n            }\n        } else {\n            removedTrack = mediaStream.getAudioTracks()[0];\n        }\n        mediaStream.removeTrack(removedTrack);\n        removedTrack.stop();\n        mediaStream.addTrack(track);\n        if (track.kind === 'video' && this.stream.isLocalStreamPublished && updateLastConstraints) {\n            this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n            this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n        }\n    }\n\n    /* Private methods */\n\n    private setPermissionDialogTimer(waitTime: number): void {\n        this.permissionDialogTimeout = setTimeout(() => {\n            this.emitEvent('accessDialogOpened', []);\n        }, waitTime);\n    }\n\n    private clearPermissionDialogTimer(startTime: number, waitTime: number): void {\n        clearTimeout(this.permissionDialogTimeout);\n        if ((Date.now() - startTime) > waitTime) {\n            // Permission dialog was shown and now is closed\n            this.emitEvent('accessDialogClosed', []);\n        }\n    }\n\n    private async replaceTrackInRtcRtpSender(track: MediaStreamTrack): Promise<void> {\n        const senders: RTCRtpSender[] = this.stream.getRTCPeerConnection().getSenders();\n        let sender: RTCRtpSender | undefined;\n        if (track.kind === 'video') {\n            sender = senders.find(s => !!s.track && s.track.kind === 'video');\n            if (!sender) {\n                throw new Error('There\\'s no replaceable track for that kind of MediaStreamTrack in this Publisher object');\n            }\n        } else if (track.kind === 'audio') {\n            sender = senders.find(s => !!s.track && s.track.kind === 'audio');\n            if (!sender) {\n                throw new Error('There\\'s no replaceable track for that kind of MediaStreamTrack in this Publisher object');\n            }\n        } else {\n            throw new Error('Unknown track kind ' + track.kind);\n        }\n        await (sender as RTCRtpSender).replaceTrack(track);\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var defineProperty_IE8 = false;\n\nif (Object.defineProperty) {\n  try {\n    Object.defineProperty({}, \"x\", {});\n  } catch (e) {\n    defineProperty_IE8 = true;\n  }\n}\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function () {},\n        fBound = function () {\n      return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('inherits');\n\nvar packers = require('./packers');\n\nvar Mapper = require('./Mapper');\n\nvar BASE_TIMEOUT = 5000;\n\nfunction unifyResponseMethods(responseMethods) {\n  if (!responseMethods) return {};\n\n  for (var key in responseMethods) {\n    var value = responseMethods[key];\n    if (typeof value == 'string') responseMethods[key] = {\n      response: value\n    };\n  }\n\n  ;\n  return responseMethods;\n}\n\n;\n\nfunction unifyTransport(transport) {\n  if (!transport) return;\n  if (transport instanceof Function) return {\n    send: transport\n  };\n  if (transport.send instanceof Function) return transport;\n\n  if (transport.postMessage instanceof Function) {\n    transport.send = transport.postMessage;\n    return transport;\n  }\n\n  if (transport.write instanceof Function) {\n    transport.send = transport.write;\n    return transport;\n  }\n\n  if (transport.onmessage !== undefined) return;\n  if (transport.pause instanceof Function) return;\n  throw new SyntaxError(\"Transport is not a function nor a valid object\");\n}\n\n;\n\nfunction RpcNotification(method, params) {\n  if (defineProperty_IE8) {\n    this.method = method;\n    this.params = params;\n  } else {\n    Object.defineProperty(this, 'method', {\n      value: method,\n      enumerable: true\n    });\n    Object.defineProperty(this, 'params', {\n      value: params,\n      enumerable: true\n    });\n  }\n}\n\n;\n\nfunction RpcBuilder(packer, options, transport, onRequest) {\n  var self = this;\n  if (!packer) throw new SyntaxError('Packer is not defined');\n  if (!packer.pack || !packer.unpack) throw new SyntaxError('Packer is invalid');\n  var responseMethods = unifyResponseMethods(packer.responseMethods);\n\n  if (options instanceof Function) {\n    if (transport != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n    onRequest = options;\n    transport = undefined;\n    options = undefined;\n  }\n\n  ;\n\n  if (options && options.send instanceof Function) {\n    if (transport && !(transport instanceof Function)) throw new SyntaxError(\"Only a function can be after transport\");\n    onRequest = transport;\n    transport = options;\n    options = undefined;\n  }\n\n  ;\n\n  if (transport instanceof Function) {\n    if (onRequest != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n    onRequest = transport;\n    transport = undefined;\n  }\n\n  ;\n  if (transport && transport.send instanceof Function) if (onRequest && !(onRequest instanceof Function)) throw new SyntaxError(\"Only a function can be after transport\");\n  options = options || {};\n  EventEmitter.call(this);\n  if (onRequest) this.on('request', onRequest);\n  if (defineProperty_IE8) this.peerID = options.peerID;else Object.defineProperty(this, 'peerID', {\n    value: options.peerID\n  });\n  var max_retries = options.max_retries || 0;\n\n  function transportMessage(event) {\n    self.decode(event.data || event);\n  }\n\n  ;\n\n  this.getTransport = function () {\n    return transport;\n  };\n\n  this.setTransport = function (value) {\n    if (transport) {\n      if (transport.removeEventListener) transport.removeEventListener('message', transportMessage);else if (transport.removeListener) transport.removeListener('data', transportMessage);\n    }\n\n    ;\n\n    if (value) {\n      if (value.addEventListener) value.addEventListener('message', transportMessage);else if (value.addListener) value.addListener('data', transportMessage);\n    }\n\n    ;\n    transport = unifyTransport(value);\n  };\n\n  if (!defineProperty_IE8) Object.defineProperty(this, 'transport', {\n    get: this.getTransport.bind(this),\n    set: this.setTransport.bind(this)\n  });\n  this.setTransport(transport);\n  var request_timeout = options.request_timeout || BASE_TIMEOUT;\n  var ping_request_timeout = options.ping_request_timeout || request_timeout;\n  var response_timeout = options.response_timeout || BASE_TIMEOUT;\n  var duplicates_timeout = options.duplicates_timeout || BASE_TIMEOUT;\n  var requestID = 0;\n  var requests = new Mapper();\n  var responses = new Mapper();\n  var processedResponses = new Mapper();\n  var message2Key = {};\n\n  function storeResponse(message, id, dest) {\n    var response = {\n      message: message,\n      timeout: setTimeout(function () {\n        responses.remove(id, dest);\n      }, response_timeout)\n    };\n    responses.set(response, id, dest);\n  }\n\n  ;\n\n  function storeProcessedResponse(ack, from) {\n    var timeout = setTimeout(function () {\n      processedResponses.remove(ack, from);\n    }, duplicates_timeout);\n    processedResponses.set(timeout, ack, from);\n  }\n\n  ;\n\n  function RpcRequest(method, params, id, from, transport) {\n    RpcNotification.call(this, method, params);\n\n    this.getTransport = function () {\n      return transport;\n    };\n\n    this.setTransport = function (value) {\n      transport = unifyTransport(value);\n    };\n\n    if (!defineProperty_IE8) Object.defineProperty(this, 'transport', {\n      get: this.getTransport.bind(this),\n      set: this.setTransport.bind(this)\n    });\n    var response = responses.get(id, from);\n\n    if (!(transport || self.getTransport())) {\n      if (defineProperty_IE8) this.duplicated = Boolean(response);else Object.defineProperty(this, 'duplicated', {\n        value: Boolean(response)\n      });\n    }\n\n    var responseMethod = responseMethods[method];\n    this.pack = packer.pack.bind(packer, this, id);\n\n    this.reply = function (error, result, transport) {\n      if (error instanceof Function || error && error.send instanceof Function) {\n        if (result != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n        transport = error;\n        result = null;\n        error = undefined;\n      } else if (result instanceof Function || result && result.send instanceof Function) {\n        if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n        transport = result;\n        result = null;\n      }\n\n      ;\n      transport = unifyTransport(transport);\n      if (response) clearTimeout(response.timeout);\n\n      if (from != undefined) {\n        if (error) error.dest = from;\n        if (result) result.dest = from;\n      }\n\n      ;\n      var message;\n\n      if (error || result != undefined) {\n        if (self.peerID != undefined) {\n          if (error) error.from = self.peerID;else result.from = self.peerID;\n        }\n\n        if (responseMethod) {\n          if (responseMethod.error == undefined && error) message = {\n            error: error\n          };else {\n            var method = error ? responseMethod.error : responseMethod.response;\n            message = {\n              method: method,\n              params: error || result\n            };\n          }\n        } else message = {\n          error: error,\n          result: result\n        };\n\n        message = packer.pack(message, id);\n      } else if (response) message = response.message;else message = packer.pack({\n        result: null\n      }, id);\n\n      storeResponse(message, id, from);\n      transport = transport || this.getTransport() || self.getTransport();\n      if (transport) return transport.send(message);\n      return message;\n    };\n  }\n\n  ;\n  inherits(RpcRequest, RpcNotification);\n\n  function cancel(message) {\n    var key = message2Key[message];\n    if (!key) return;\n    delete message2Key[message];\n    var request = requests.pop(key.id, key.dest);\n    if (!request) return;\n    clearTimeout(request.timeout);\n    storeProcessedResponse(key.id, key.dest);\n  }\n\n  ;\n\n  this.cancel = function (message) {\n    if (message) return cancel(message);\n\n    for (var message in message2Key) cancel(message);\n  };\n\n  this.close = function () {\n    var transport = this.getTransport();\n    if (transport && transport.close) transport.close(4003, \"Cancel request\");\n    this.cancel();\n    processedResponses.forEach(clearTimeout);\n    responses.forEach(function (response) {\n      clearTimeout(response.timeout);\n    });\n  };\n\n  this.encode = function (method, params, dest, transport, callback) {\n    if (params instanceof Function) {\n      if (dest != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = params;\n      transport = undefined;\n      dest = undefined;\n      params = undefined;\n    } else if (dest instanceof Function) {\n      if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = dest;\n      transport = undefined;\n      dest = undefined;\n    } else if (transport instanceof Function) {\n      if (callback != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = transport;\n      transport = undefined;\n    }\n\n    ;\n\n    if (self.peerID != undefined) {\n      params = params || {};\n      params.from = self.peerID;\n    }\n\n    ;\n\n    if (dest != undefined) {\n      params = params || {};\n      params.dest = dest;\n    }\n\n    ;\n    var message = {\n      method: method,\n      params: params\n    };\n\n    if (callback) {\n      var id = requestID++;\n      var retried = 0;\n      message = packer.pack(message, id);\n\n      function dispatchCallback(error, result) {\n        self.cancel(message);\n        callback(error, result);\n      }\n\n      ;\n      var request = {\n        message: message,\n        callback: dispatchCallback,\n        responseMethods: responseMethods[method] || {}\n      };\n      var encode_transport = unifyTransport(transport);\n\n      function sendRequest(transport) {\n        var rt = method === 'ping' ? ping_request_timeout : request_timeout;\n        request.timeout = setTimeout(timeout, rt * Math.pow(2, retried++));\n        message2Key[message] = {\n          id: id,\n          dest: dest\n        };\n        requests.set(request, id, dest);\n        transport = transport || encode_transport || self.getTransport();\n        if (transport) return transport.send(message);\n        return message;\n      }\n\n      ;\n\n      function retry(transport) {\n        transport = unifyTransport(transport);\n        console.warn(retried + ' retry for request message:', message);\n        var timeout = processedResponses.pop(id, dest);\n        clearTimeout(timeout);\n        return sendRequest(transport);\n      }\n\n      ;\n\n      function timeout() {\n        if (retried < max_retries) return retry(transport);\n        var error = new Error('Request has timed out');\n        error.request = message;\n        error.retry = retry;\n        dispatchCallback(error);\n      }\n\n      ;\n      return sendRequest(transport);\n    }\n\n    ;\n    message = packer.pack(message);\n    transport = transport || this.getTransport();\n    if (transport) return transport.send(message);\n    return message;\n  };\n\n  this.decode = function (message, transport) {\n    if (!message) throw new TypeError(\"Message is not defined\");\n\n    try {\n      message = packer.unpack(message);\n    } catch (e) {\n      return console.debug(e, message);\n    }\n\n    ;\n    var id = message.id;\n    var ack = message.ack;\n    var method = message.method;\n    var params = message.params || {};\n    var from = params.from;\n    var dest = params.dest;\n    if (self.peerID != undefined && from == self.peerID) return;\n\n    if (id == undefined && ack == undefined) {\n      var notification = new RpcNotification(method, params);\n      if (self.emit('request', notification)) return;\n      return notification;\n    }\n\n    ;\n\n    function processRequest() {\n      transport = unifyTransport(transport) || self.getTransport();\n\n      if (transport) {\n        var response = responses.get(id, from);\n        if (response) return transport.send(response.message);\n      }\n\n      ;\n      var idAck = id != undefined ? id : ack;\n      var request = new RpcRequest(method, params, idAck, from, transport);\n      if (self.emit('request', request)) return;\n      return request;\n    }\n\n    ;\n\n    function processResponse(request, error, result) {\n      request.callback(error, result);\n    }\n\n    ;\n\n    function duplicatedResponse(timeout) {\n      console.warn(\"Response already processed\", message);\n      clearTimeout(timeout);\n      storeProcessedResponse(ack, from);\n    }\n\n    ;\n\n    if (method) {\n      if (dest == undefined || dest == self.peerID) {\n        var request = requests.get(ack, from);\n\n        if (request) {\n          var responseMethods = request.responseMethods;\n          if (method == responseMethods.error) return processResponse(request, params);\n          if (method == responseMethods.response) return processResponse(request, null, params);\n          return processRequest();\n        }\n\n        var processed = processedResponses.get(ack, from);\n        if (processed) return duplicatedResponse(processed);\n      }\n\n      return processRequest();\n    }\n\n    ;\n    var error = message.error;\n    var result = message.result;\n    if (error && error.dest && error.dest != self.peerID) return;\n    if (result && result.dest && result.dest != self.peerID) return;\n    var request = requests.get(ack, from);\n\n    if (!request) {\n      var processed = processedResponses.get(ack, from);\n      if (processed) return duplicatedResponse(processed);\n      return console.warn(\"No callback was defined for this message\", message);\n    }\n\n    ;\n    processResponse(request, error, result);\n  };\n}\n\n;\ninherits(RpcBuilder, EventEmitter);\nRpcBuilder.RpcNotification = RpcNotification;\nmodule.exports = RpcBuilder;\n\nvar clients = require('./clients');\n\nvar transports = require('./clients/transports');\n\nRpcBuilder.clients = clients;\nRpcBuilder.clients.transports = transports;\nRpcBuilder.packers = packers;","map":{"version":3,"mappings":"AAkBA,IAAIA,kBAAkB,GAAG,KAAzB;;AACA,IAAIC,MAAM,CAACC,cAAX,EAA2B;EACzB,IAAI;IACFD,MAAM,CAACC,cAAP,CAAsB,EAAtB,EAA0B,GAA1B,EAA+B,EAA/B;EACD,CAFD,CAEE,OAAOC,CAAP,EAAU;IACVH,kBAAkB,GAAG,IAArB;EACD;AACF;;AAGD,IAAI,CAACI,QAAQ,CAACC,SAAT,CAAmBC,IAAxB,EAA8B;EAC5BF,QAAQ,CAACC,SAAT,CAAmBC,IAAnB,GAA0B,UAAUC,KAAV,EAAe;IACvC,IAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;MAG9B,MAAM,IAAIC,SAAJ,CAAc,sEAAd,CAAN;IACD;;IAED,IAAIC,KAAK,GAAGC,KAAK,CAACL,SAAN,CAAgBM,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAZ;IAAA,IACEC,OAAO,GAAG,IADZ;IAAA,IAEEC,IAAI,GAAG,aAAc,CAFvB;IAAA,IAGEC,MAAM,GAAG;MACP,OAAOF,OAAO,CAACG,KAAR,CAAc,gBAAgBF,IAAhB,IAAwBR,KAAxB,GACnB,IADmB,GAEnBA,KAFK,EAGLE,KAAK,CAACS,MAAN,CAAaR,KAAK,CAACL,SAAN,CAAgBM,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAb,CAHK,CAAP;IAID,CARH;;IAUAE,IAAI,CAACV,SAAL,GAAiB,KAAKA,SAAtB;IACAW,MAAM,CAACX,SAAP,GAAmB,IAAIU,IAAJ,EAAnB;IAEA,OAAOC,MAAP;EACD,CArBD;AAsBD;;AAGD,IAAIG,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAArC;;AAEA,IAAIE,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AAEA,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAApB;;AAGA,IAAII,YAAY,GAAG,IAAnB;;AAGA,SAASC,oBAAT,CAA8BC,eAA9B,EAA6C;EAC3C,IAAI,CAACA,eAAL,EAAsB,OAAO,EAAP;;EAEtB,KAAK,IAAIC,GAAT,IAAgBD,eAAhB,EAAiC;IAC/B,IAAIE,KAAK,GAAGF,eAAe,CAACC,GAAD,CAA3B;IAEA,IAAI,OAAOC,KAAP,IAAgB,QAApB,EACEF,eAAe,CAACC,GAAD,CAAf,GAAuB;MACrBE,QAAQ,EAAED;IADW,CAAvB;EAGH;;EAAA;EAED,OAAOF,eAAP;AACD;;AAAA;;AAED,SAASI,cAAT,CAAwBC,SAAxB,EAAiC;EAC/B,IAAI,CAACA,SAAL,EAAgB;EAGhB,IAAIA,SAAS,YAAY3B,QAAzB,EACE,OAAO;IACL4B,IAAI,EAAED;EADD,CAAP;EAKF,IAAIA,SAAS,CAACC,IAAV,YAA0B5B,QAA9B,EACE,OAAO2B,SAAP;;EAGF,IAAIA,SAAS,CAACE,WAAV,YAAiC7B,QAArC,EAA+C;IAC7C2B,SAAS,CAACC,IAAV,GAAiBD,SAAS,CAACE,WAA3B;IACA,OAAOF,SAAP;EACD;;EAGD,IAAIA,SAAS,CAACG,KAAV,YAA2B9B,QAA/B,EAAyC;IACvC2B,SAAS,CAACC,IAAV,GAAiBD,SAAS,CAACG,KAA3B;IACA,OAAOH,SAAP;EACD;;EAGD,IAAIA,SAAS,CAACI,SAAV,KAAwBC,SAA5B,EAAuC;EACvC,IAAIL,SAAS,CAACM,KAAV,YAA2BjC,QAA/B,EAAyC;EAEzC,MAAM,IAAIkC,WAAJ,CAAgB,gDAAhB,CAAN;AACD;;AAAA;;AAaD,SAASC,eAAT,CAAyBC,MAAzB,EAAiCC,MAAjC,EAAuC;EACrC,IAAIzC,kBAAJ,EAAwB;IACtB,KAAKwC,MAAL,GAAcA,MAAd;IACA,KAAKC,MAAL,GAAcA,MAAd;EACD,CAHD,MAGO;IACLxC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;MACpC0B,KAAK,EAAEY,MAD6B;MAEpCE,UAAU,EAAE;IAFwB,CAAtC;IAIAzC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;MACpC0B,KAAK,EAAEa,MAD6B;MAEpCC,UAAU,EAAE;IAFwB,CAAtC;EAID;AACF;;AAAA;;AAgBD,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,OAA5B,EAAqCd,SAArC,EAAgDe,SAAhD,EAAyD;EACvD,IAAIC,IAAI,GAAG,IAAX;EAEA,IAAI,CAACH,MAAL,EACE,MAAM,IAAIN,WAAJ,CAAgB,uBAAhB,CAAN;EAEF,IAAI,CAACM,MAAM,CAACI,IAAR,IAAgB,CAACJ,MAAM,CAACK,MAA5B,EACE,MAAM,IAAIX,WAAJ,CAAgB,mBAAhB,CAAN;EAEF,IAAIZ,eAAe,GAAGD,oBAAoB,CAACmB,MAAM,CAAClB,eAAR,CAA1C;;EAGA,IAAImB,OAAO,YAAYzC,QAAvB,EAAiC;IAC/B,IAAI2B,SAAS,IAAIK,SAAjB,EACE,MAAM,IAAIE,WAAJ,CAAgB,2CAAhB,CAAN;IAEFQ,SAAS,GAAGD,OAAZ;IACAd,SAAS,GAAGK,SAAZ;IACAS,OAAO,GAAGT,SAAV;EACD;;EAAA;;EAED,IAAIS,OAAO,IAAIA,OAAO,CAACb,IAAR,YAAwB5B,QAAvC,EAAiD;IAC/C,IAAI2B,SAAS,IAAI,EAAEA,SAAS,YAAY3B,QAAvB,CAAjB,EACE,MAAM,IAAIkC,WAAJ,CAAgB,wCAAhB,CAAN;IAEFQ,SAAS,GAAGf,SAAZ;IACAA,SAAS,GAAGc,OAAZ;IACAA,OAAO,GAAGT,SAAV;EACD;;EAAA;;EAED,IAAIL,SAAS,YAAY3B,QAAzB,EAAmC;IACjC,IAAI0C,SAAS,IAAIV,SAAjB,EACE,MAAM,IAAIE,WAAJ,CAAgB,2CAAhB,CAAN;IAEFQ,SAAS,GAAGf,SAAZ;IACAA,SAAS,GAAGK,SAAZ;EACD;;EAAA;EAED,IAAIL,SAAS,IAAIA,SAAS,CAACC,IAAV,YAA0B5B,QAA3C,EACE,IAAI0C,SAAS,IAAI,EAAEA,SAAS,YAAY1C,QAAvB,CAAjB,EACE,MAAM,IAAIkC,WAAJ,CAAgB,wCAAhB,CAAN;EAEJO,OAAO,GAAGA,OAAO,IAAI,EAArB;EAGA1B,YAAY,CAACP,IAAb,CAAkB,IAAlB;EAEA,IAAIkC,SAAJ,EACE,KAAKI,EAAL,CAAQ,SAAR,EAAmBJ,SAAnB;EAGF,IAAI9C,kBAAJ,EACE,KAAKmD,MAAL,GAAcN,OAAO,CAACM,MAAtB,CADF,KAGElD,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;IACpC0B,KAAK,EAAEiB,OAAO,CAACM;EADqB,CAAtC;EAIF,IAAIC,WAAW,GAAGP,OAAO,CAACO,WAAR,IAAuB,CAAzC;;EAGA,SAASC,gBAAT,CAA0BC,KAA1B,EAA+B;IAC7BP,IAAI,CAACQ,MAAL,CAAYD,KAAK,CAACE,IAAN,IAAcF,KAA1B;EACD;;EAAA;;EAED,KAAKG,YAAL,GAAoB;IAClB,OAAO1B,SAAP;EACD,CAFD;;EAGA,KAAK2B,YAAL,GAAoB,UAAU9B,KAAV,EAAe;IAEjC,IAAIG,SAAJ,EAAe;MAEb,IAAIA,SAAS,CAAC4B,mBAAd,EACE5B,SAAS,CAAC4B,mBAAV,CAA8B,SAA9B,EAAyCN,gBAAzC,EADF,KAIK,IAAItB,SAAS,CAAC6B,cAAd,EACH7B,SAAS,CAAC6B,cAAV,CAAyB,MAAzB,EAAiCP,gBAAjC;IACH;;IAAA;;IAGD,IAAIzB,KAAJ,EAAW;MAET,IAAIA,KAAK,CAACiC,gBAAV,EACEjC,KAAK,CAACiC,gBAAN,CAAuB,SAAvB,EAAkCR,gBAAlC,EADF,KAIK,IAAIzB,KAAK,CAACkC,WAAV,EACHlC,KAAK,CAACkC,WAAN,CAAkB,MAAlB,EAA0BT,gBAA1B;IACH;;IAAA;IAEDtB,SAAS,GAAGD,cAAc,CAACF,KAAD,CAA1B;EACD,CAxBD;;EA0BA,IAAI,CAAC5B,kBAAL,EACEC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;IACvC6D,GAAG,EAAE,KAAKN,YAAL,CAAkBnD,IAAlB,CAAuB,IAAvB,CADkC;IAEvC0D,GAAG,EAAE,KAAKN,YAAL,CAAkBpD,IAAlB,CAAuB,IAAvB;EAFkC,CAAzC;EAKF,KAAKoD,YAAL,CAAkB3B,SAAlB;EAGA,IAAIkC,eAAe,GAAGpB,OAAO,CAACoB,eAAR,IAA2BzC,YAAjD;EACA,IAAI0C,oBAAoB,GAAGrB,OAAO,CAACqB,oBAAR,IAAgCD,eAA3D;EACA,IAAIE,gBAAgB,GAAGtB,OAAO,CAACsB,gBAAR,IAA4B3C,YAAnD;EACA,IAAI4C,kBAAkB,GAAGvB,OAAO,CAACuB,kBAAR,IAA8B5C,YAAvD;EAGA,IAAI6C,SAAS,GAAG,CAAhB;EAEA,IAAIC,QAAQ,GAAG,IAAI/C,MAAJ,EAAf;EACA,IAAIgD,SAAS,GAAG,IAAIhD,MAAJ,EAAhB;EACA,IAAIiD,kBAAkB,GAAG,IAAIjD,MAAJ,EAAzB;EAEA,IAAIkD,WAAW,GAAG,EAAlB;;EAMA,SAASC,aAAT,CAAuBC,OAAvB,EAAgCC,EAAhC,EAAoCC,IAApC,EAAwC;IACtC,IAAIhD,QAAQ,GAAG;MACb8C,OAAO,EAAEA,OADI;MAGbG,OAAO,EAAEC,UAAU,CAAC;QAChBR,SAAS,CAACS,MAAV,CAAiBJ,EAAjB,EAAqBC,IAArB;MACD,CAFgB,EAGjBV,gBAHiB;IAHN,CAAf;IASAI,SAAS,CAACP,GAAV,CAAcnC,QAAd,EAAwB+C,EAAxB,EAA4BC,IAA5B;EACD;;EAAA;;EAKD,SAASI,sBAAT,CAAgCC,GAAhC,EAAqCC,IAArC,EAAyC;IACvC,IAAIL,OAAO,GAAGC,UAAU,CAAC;MACrBP,kBAAkB,CAACQ,MAAnB,CAA0BE,GAA1B,EAA+BC,IAA/B;IACD,CAFqB,EAGtBf,kBAHsB,CAAxB;IAKAI,kBAAkB,CAACR,GAAnB,CAAuBc,OAAvB,EAAgCI,GAAhC,EAAqCC,IAArC;EACD;;EAAA;;EAgBD,SAASC,UAAT,CAAoB5C,MAApB,EAA4BC,MAA5B,EAAoCmC,EAApC,EAAwCO,IAAxC,EAA8CpD,SAA9C,EAAuD;IACrDQ,eAAe,CAAC3B,IAAhB,CAAqB,IAArB,EAA2B4B,MAA3B,EAAmCC,MAAnC;;IAEA,KAAKgB,YAAL,GAAoB;MAClB,OAAO1B,SAAP;IACD,CAFD;;IAGA,KAAK2B,YAAL,GAAoB,UAAU9B,KAAV,EAAe;MACjCG,SAAS,GAAGD,cAAc,CAACF,KAAD,CAA1B;IACD,CAFD;;IAIA,IAAI,CAAC5B,kBAAL,EACEC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;MACvC6D,GAAG,EAAE,KAAKN,YAAL,CAAkBnD,IAAlB,CAAuB,IAAvB,CADkC;MAEvC0D,GAAG,EAAE,KAAKN,YAAL,CAAkBpD,IAAlB,CAAuB,IAAvB;IAFkC,CAAzC;IAKF,IAAIuB,QAAQ,GAAG0C,SAAS,CAACR,GAAV,CAAca,EAAd,EAAkBO,IAAlB,CAAf;;IAKA,IAAI,EAAEpD,SAAS,IAAIgB,IAAI,CAACU,YAAL,EAAf,CAAJ,EAAyC;MACvC,IAAIzD,kBAAJ,EACE,KAAKqF,UAAL,GAAkBC,OAAO,CAACzD,QAAD,CAAzB,CADF,KAGE5B,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;QACxC0B,KAAK,EAAE0D,OAAO,CAACzD,QAAD;MAD0B,CAA1C;IAGH;;IAED,IAAI0D,cAAc,GAAG7D,eAAe,CAACc,MAAD,CAApC;IAEA,KAAKQ,IAAL,GAAYJ,MAAM,CAACI,IAAP,CAAY1C,IAAZ,CAAiBsC,MAAjB,EAAyB,IAAzB,EAA+BgC,EAA/B,CAAZ;;IAUA,KAAKY,KAAL,GAAa,UAAUC,KAAV,EAAiBC,MAAjB,EAAyB3D,SAAzB,EAAkC;MAE7C,IAAI0D,KAAK,YAAYrF,QAAjB,IAA6BqF,KAAK,IAAIA,KAAK,CAACzD,IAAN,YAAsB5B,QAAhE,EAA0E;QACxE,IAAIsF,MAAM,IAAItD,SAAd,EACE,MAAM,IAAIE,WAAJ,CAAgB,0CAAhB,CAAN;QAEFP,SAAS,GAAG0D,KAAZ;QACAC,MAAM,GAAG,IAAT;QACAD,KAAK,GAAGrD,SAAR;MACD,CAPD,MAOO,IAAIsD,MAAM,YAAYtF,QAAlB,IACTsF,MAAM,IAAIA,MAAM,CAAC1D,IAAP,YAAuB5B,QAD5B,EACsC;QAC3C,IAAI2B,SAAS,IAAIK,SAAjB,EACE,MAAM,IAAIE,WAAJ,CAAgB,0CAAhB,CAAN;QAEFP,SAAS,GAAG2D,MAAZ;QACAA,MAAM,GAAG,IAAT;MACD;;MAAA;MAED3D,SAAS,GAAGD,cAAc,CAACC,SAAD,CAA1B;MAGA,IAAIF,QAAJ,EACE8D,YAAY,CAAC9D,QAAQ,CAACiD,OAAV,CAAZ;;MAEF,IAAIK,IAAI,IAAI/C,SAAZ,EAAuB;QACrB,IAAIqD,KAAJ,EACEA,KAAK,CAACZ,IAAN,GAAaM,IAAb;QAEF,IAAIO,MAAJ,EACEA,MAAM,CAACb,IAAP,GAAcM,IAAd;MACH;;MAAA;MAED,IAAIR,OAAJ;;MAGA,IAAIc,KAAK,IAAIC,MAAM,IAAItD,SAAvB,EAAkC;QAChC,IAAIW,IAAI,CAACI,MAAL,IAAef,SAAnB,EAA8B;UAC5B,IAAIqD,KAAJ,EACEA,KAAK,CAACN,IAAN,GAAapC,IAAI,CAACI,MAAlB,CADF,KAGEuC,MAAM,CAACP,IAAP,GAAcpC,IAAI,CAACI,MAAnB;QACH;;QAGD,IAAIoC,cAAJ,EAAoB;UAClB,IAAIA,cAAc,CAACE,KAAf,IAAwBrD,SAAxB,IAAqCqD,KAAzC,EACEd,OAAO,GAAG;YACRc,KAAK,EAAEA;UADC,CAAV,CADF,KAKK;YACH,IAAIjD,MAAM,GAAGiD,KAAK,GAChBF,cAAc,CAACE,KADC,GAEhBF,cAAc,CAAC1D,QAFjB;YAIA8C,OAAO,GAAG;cACRnC,MAAM,EAAEA,MADA;cAERC,MAAM,EAAEgD,KAAK,IAAIC;YAFT,CAAV;UAID;QACF,CAhBD,MAiBEf,OAAO,GAAG;UACRc,KAAK,EAAEA,KADC;UAERC,MAAM,EAAEA;QAFA,CAAV;;QAKFf,OAAO,GAAG/B,MAAM,CAACI,IAAP,CAAY2B,OAAZ,EAAqBC,EAArB,CAAV;MACD,CAhCD,MAmCK,IAAI/C,QAAJ,EACH8C,OAAO,GAAG9C,QAAQ,CAAC8C,OAAnB,CADG,KAKHA,OAAO,GAAG/B,MAAM,CAACI,IAAP,CAAY;QACpB0C,MAAM,EAAE;MADY,CAAZ,EAEPd,EAFO,CAAV;;MAKFF,aAAa,CAACC,OAAD,EAAUC,EAAV,EAAcO,IAAd,CAAb;MAGApD,SAAS,GAAGA,SAAS,IAAI,KAAK0B,YAAL,EAAb,IAAoCV,IAAI,CAACU,YAAL,EAAhD;MAEA,IAAI1B,SAAJ,EACE,OAAOA,SAAS,CAACC,IAAV,CAAe2C,OAAf,CAAP;MAEF,OAAOA,OAAP;IACD,CAzFD;EA0FD;;EAAA;EACDtD,QAAQ,CAAC+D,UAAD,EAAa7C,eAAb,CAAR;;EAGA,SAASqD,MAAT,CAAgBjB,OAAhB,EAAuB;IACrB,IAAIhD,GAAG,GAAG8C,WAAW,CAACE,OAAD,CAArB;IACA,IAAI,CAAChD,GAAL,EAAU;IAEV,OAAO8C,WAAW,CAACE,OAAD,CAAlB;IAEA,IAAIkB,OAAO,GAAGvB,QAAQ,CAACwB,GAAT,CAAanE,GAAG,CAACiD,EAAjB,EAAqBjD,GAAG,CAACkD,IAAzB,CAAd;IACA,IAAI,CAACgB,OAAL,EAAc;IAEdF,YAAY,CAACE,OAAO,CAACf,OAAT,CAAZ;IAGAG,sBAAsB,CAACtD,GAAG,CAACiD,EAAL,EAASjD,GAAG,CAACkD,IAAb,CAAtB;EACD;;EAAA;;EAOD,KAAKe,MAAL,GAAc,UAAUjB,OAAV,EAAiB;IAC7B,IAAIA,OAAJ,EAAa,OAAOiB,MAAM,CAACjB,OAAD,CAAb;;IAEb,KAAK,IAAIA,OAAT,IAAoBF,WAApB,EACEmB,MAAM,CAACjB,OAAD,CAAN;EACH,CALD;;EAQA,KAAKoB,KAAL,GAAa;IAEX,IAAIhE,SAAS,GAAG,KAAK0B,YAAL,EAAhB;IACA,IAAI1B,SAAS,IAAIA,SAAS,CAACgE,KAA3B,EACEhE,SAAS,CAACgE,KAAV,CAAgB,IAAhB,EAAsB,gBAAtB;IAGF,KAAKH,MAAL;IAEApB,kBAAkB,CAACwB,OAAnB,CAA2BL,YAA3B;IAGApB,SAAS,CAACyB,OAAV,CAAkB,UAAUnE,QAAV,EAAkB;MAClC8D,YAAY,CAAC9D,QAAQ,CAACiD,OAAV,CAAZ;IACD,CAFD;EAGD,CAfD;;EA8BA,KAAKmB,MAAL,GAAc,UAAUzD,MAAV,EAAkBC,MAAlB,EAA0BoC,IAA1B,EAAgC9C,SAAhC,EAA2CmE,QAA3C,EAAmD;IAE/D,IAAIzD,MAAM,YAAYrC,QAAtB,EAAgC;MAC9B,IAAIyE,IAAI,IAAIzC,SAAZ,EACE,MAAM,IAAIE,WAAJ,CAAgB,0CAAhB,CAAN;MAEF4D,QAAQ,GAAGzD,MAAX;MACAV,SAAS,GAAGK,SAAZ;MACAyC,IAAI,GAAGzC,SAAP;MACAK,MAAM,GAAGL,SAAT;IACD,CARD,MAQO,IAAIyC,IAAI,YAAYzE,QAApB,EAA8B;MACnC,IAAI2B,SAAS,IAAIK,SAAjB,EACE,MAAM,IAAIE,WAAJ,CAAgB,0CAAhB,CAAN;MAEF4D,QAAQ,GAAGrB,IAAX;MACA9C,SAAS,GAAGK,SAAZ;MACAyC,IAAI,GAAGzC,SAAP;IACD,CAPM,MAOA,IAAIL,SAAS,YAAY3B,QAAzB,EAAmC;MACxC,IAAI8F,QAAQ,IAAI9D,SAAhB,EACE,MAAM,IAAIE,WAAJ,CAAgB,0CAAhB,CAAN;MAEF4D,QAAQ,GAAGnE,SAAX;MACAA,SAAS,GAAGK,SAAZ;IACD;;IAAA;;IAED,IAAIW,IAAI,CAACI,MAAL,IAAef,SAAnB,EAA8B;MAC5BK,MAAM,GAAGA,MAAM,IAAI,EAAnB;MAEAA,MAAM,CAAC0C,IAAP,GAAcpC,IAAI,CAACI,MAAnB;IACD;;IAAA;;IAED,IAAI0B,IAAI,IAAIzC,SAAZ,EAAuB;MACrBK,MAAM,GAAGA,MAAM,IAAI,EAAnB;MAEAA,MAAM,CAACoC,IAAP,GAAcA,IAAd;IACD;;IAAA;IAGD,IAAIF,OAAO,GAAG;MACZnC,MAAM,EAAEA,MADI;MAEZC,MAAM,EAAEA;IAFI,CAAd;;IAKA,IAAIyD,QAAJ,EAAc;MACZ,IAAItB,EAAE,GAAGP,SAAS,EAAlB;MACA,IAAI8B,OAAO,GAAG,CAAd;MAEAxB,OAAO,GAAG/B,MAAM,CAACI,IAAP,CAAY2B,OAAZ,EAAqBC,EAArB,CAAV;;MAEA,SAASwB,gBAAT,CAA0BX,KAA1B,EAAiCC,MAAjC,EAAuC;QACrC3C,IAAI,CAAC6C,MAAL,CAAYjB,OAAZ;QAEAuB,QAAQ,CAACT,KAAD,EAAQC,MAAR,CAAR;MACD;;MAAA;MAED,IAAIG,OAAO,GAAG;QACZlB,OAAO,EAAEA,OADG;QAEZuB,QAAQ,EAAEE,gBAFE;QAGZ1E,eAAe,EAAEA,eAAe,CAACc,MAAD,CAAf,IAA2B;MAHhC,CAAd;MAMA,IAAI6D,gBAAgB,GAAGvE,cAAc,CAACC,SAAD,CAArC;;MAEA,SAASuE,WAAT,CAAqBvE,SAArB,EAA8B;QAC5B,IAAIwE,EAAE,GAAI/D,MAAM,KAAK,MAAX,GAAoB0B,oBAApB,GAA2CD,eAArD;QACA4B,OAAO,CAACf,OAAR,GAAkBC,UAAU,CAACD,OAAD,EAAUyB,EAAE,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYN,OAAO,EAAnB,CAAf,CAA5B;QACA1B,WAAW,CAACE,OAAD,CAAX,GAAuB;UACrBC,EAAE,EAAEA,EADiB;UAErBC,IAAI,EAAEA;QAFe,CAAvB;QAIAP,QAAQ,CAACN,GAAT,CAAa6B,OAAb,EAAsBjB,EAAtB,EAA0BC,IAA1B;QAEA9C,SAAS,GAAGA,SAAS,IAAIsE,gBAAb,IAAiCtD,IAAI,CAACU,YAAL,EAA7C;QACA,IAAI1B,SAAJ,EACE,OAAOA,SAAS,CAACC,IAAV,CAAe2C,OAAf,CAAP;QAEF,OAAOA,OAAP;MACD;;MAAA;;MAED,SAAS+B,KAAT,CAAe3E,SAAf,EAAwB;QACtBA,SAAS,GAAGD,cAAc,CAACC,SAAD,CAA1B;QAEA4E,OAAO,CAACC,IAAR,CAAaT,OAAO,GAAG,6BAAvB,EAAsDxB,OAAtD;QAEA,IAAIG,OAAO,GAAGN,kBAAkB,CAACsB,GAAnB,CAAuBlB,EAAvB,EAA2BC,IAA3B,CAAd;QACAc,YAAY,CAACb,OAAD,CAAZ;QAEA,OAAOwB,WAAW,CAACvE,SAAD,CAAlB;MACD;;MAAA;;MAED,SAAS+C,OAAT,GAAgB;QACd,IAAIqB,OAAO,GAAG/C,WAAd,EACE,OAAOsD,KAAK,CAAC3E,SAAD,CAAZ;QAEF,IAAI0D,KAAK,GAAG,IAAIoB,KAAJ,CAAU,uBAAV,CAAZ;QACApB,KAAK,CAACI,OAAN,GAAgBlB,OAAhB;QAEAc,KAAK,CAACiB,KAAN,GAAcA,KAAd;QAEAN,gBAAgB,CAACX,KAAD,CAAhB;MACD;;MAAA;MAED,OAAOa,WAAW,CAACvE,SAAD,CAAlB;IACD;;IAAA;IAGD4C,OAAO,GAAG/B,MAAM,CAACI,IAAP,CAAY2B,OAAZ,CAAV;IAEA5C,SAAS,GAAGA,SAAS,IAAI,KAAK0B,YAAL,EAAzB;IACA,IAAI1B,SAAJ,EACE,OAAOA,SAAS,CAACC,IAAV,CAAe2C,OAAf,CAAP;IAEF,OAAOA,OAAP;EACD,CAjHD;;EA8HA,KAAKpB,MAAL,GAAc,UAAUoB,OAAV,EAAmB5C,SAAnB,EAA4B;IACxC,IAAI,CAAC4C,OAAL,EACE,MAAM,IAAInE,SAAJ,CAAc,wBAAd,CAAN;;IAEF,IAAI;MACFmE,OAAO,GAAG/B,MAAM,CAACK,MAAP,CAAc0B,OAAd,CAAV;IACD,CAFD,CAEE,OAAOxE,CAAP,EAAU;MAEV,OAAOwG,OAAO,CAACG,KAAR,CAAc3G,CAAd,EAAiBwE,OAAjB,CAAP;IACD;;IAAA;IAED,IAAIC,EAAE,GAAGD,OAAO,CAACC,EAAjB;IACA,IAAIM,GAAG,GAAGP,OAAO,CAACO,GAAlB;IACA,IAAI1C,MAAM,GAAGmC,OAAO,CAACnC,MAArB;IACA,IAAIC,MAAM,GAAGkC,OAAO,CAAClC,MAAR,IAAkB,EAA/B;IAEA,IAAI0C,IAAI,GAAG1C,MAAM,CAAC0C,IAAlB;IACA,IAAIN,IAAI,GAAGpC,MAAM,CAACoC,IAAlB;IAGA,IAAI9B,IAAI,CAACI,MAAL,IAAef,SAAf,IAA4B+C,IAAI,IAAIpC,IAAI,CAACI,MAA7C,EAAqD;;IAGrD,IAAIyB,EAAE,IAAIxC,SAAN,IAAmB8C,GAAG,IAAI9C,SAA9B,EAAyC;MACvC,IAAI2E,YAAY,GAAG,IAAIxE,eAAJ,CAAoBC,MAApB,EAA4BC,MAA5B,CAAnB;MAEA,IAAIM,IAAI,CAACiE,IAAL,CAAU,SAAV,EAAqBD,YAArB,CAAJ,EAAwC;MACxC,OAAOA,YAAP;IACD;;IAAA;;IAGD,SAASE,cAAT,GAAuB;MAErBlF,SAAS,GAAGD,cAAc,CAACC,SAAD,CAAd,IAA6BgB,IAAI,CAACU,YAAL,EAAzC;;MACA,IAAI1B,SAAJ,EAAe;QACb,IAAIF,QAAQ,GAAG0C,SAAS,CAACR,GAAV,CAAca,EAAd,EAAkBO,IAAlB,CAAf;QACA,IAAItD,QAAJ,EACE,OAAOE,SAAS,CAACC,IAAV,CAAeH,QAAQ,CAAC8C,OAAxB,CAAP;MACH;;MAAA;MAED,IAAIuC,KAAK,GAAItC,EAAE,IAAIxC,SAAP,GAAoBwC,EAApB,GAAyBM,GAArC;MACA,IAAIW,OAAO,GAAG,IAAIT,UAAJ,CAAe5C,MAAf,EAAuBC,MAAvB,EAA+ByE,KAA/B,EAAsC/B,IAAtC,EAA4CpD,SAA5C,CAAd;MAEA,IAAIgB,IAAI,CAACiE,IAAL,CAAU,SAAV,EAAqBnB,OAArB,CAAJ,EAAmC;MACnC,OAAOA,OAAP;IACD;;IAAA;;IAED,SAASsB,eAAT,CAAyBtB,OAAzB,EAAkCJ,KAAlC,EAAyCC,MAAzC,EAA+C;MAC7CG,OAAO,CAACK,QAAR,CAAiBT,KAAjB,EAAwBC,MAAxB;IACD;;IAAA;;IAED,SAAS0B,kBAAT,CAA4BtC,OAA5B,EAAmC;MACjC6B,OAAO,CAACC,IAAR,CAAa,4BAAb,EAA2CjC,OAA3C;MAGAgB,YAAY,CAACb,OAAD,CAAZ;MACAG,sBAAsB,CAACC,GAAD,EAAMC,IAAN,CAAtB;IACD;;IAAA;;IAID,IAAI3C,MAAJ,EAAY;MAEV,IAAIqC,IAAI,IAAIzC,SAAR,IAAqByC,IAAI,IAAI9B,IAAI,CAACI,MAAtC,EAA8C;QAC5C,IAAI0C,OAAO,GAAGvB,QAAQ,CAACP,GAAT,CAAamB,GAAb,EAAkBC,IAAlB,CAAd;;QACA,IAAIU,OAAJ,EAAa;UACX,IAAInE,eAAe,GAAGmE,OAAO,CAACnE,eAA9B;UAEA,IAAIc,MAAM,IAAId,eAAe,CAAC+D,KAA9B,EACE,OAAO0B,eAAe,CAACtB,OAAD,EAAUpD,MAAV,CAAtB;UAEF,IAAID,MAAM,IAAId,eAAe,CAACG,QAA9B,EACE,OAAOsF,eAAe,CAACtB,OAAD,EAAU,IAAV,EAAgBpD,MAAhB,CAAtB;UAEF,OAAOwE,cAAc,EAArB;QACD;;QAED,IAAII,SAAS,GAAG7C,kBAAkB,CAACT,GAAnB,CAAuBmB,GAAvB,EAA4BC,IAA5B,CAAhB;QACA,IAAIkC,SAAJ,EACE,OAAOD,kBAAkB,CAACC,SAAD,CAAzB;MACH;;MAGD,OAAOJ,cAAc,EAArB;IACD;;IAAA;IAED,IAAIxB,KAAK,GAAGd,OAAO,CAACc,KAApB;IACA,IAAIC,MAAM,GAAGf,OAAO,CAACe,MAArB;IAGA,IAAID,KAAK,IAAIA,KAAK,CAACZ,IAAf,IAAuBY,KAAK,CAACZ,IAAN,IAAc9B,IAAI,CAACI,MAA9C,EAAsD;IACtD,IAAIuC,MAAM,IAAIA,MAAM,CAACb,IAAjB,IAAyBa,MAAM,CAACb,IAAP,IAAe9B,IAAI,CAACI,MAAjD,EAAyD;IAGzD,IAAI0C,OAAO,GAAGvB,QAAQ,CAACP,GAAT,CAAamB,GAAb,EAAkBC,IAAlB,CAAd;;IACA,IAAI,CAACU,OAAL,EAAc;MACZ,IAAIwB,SAAS,GAAG7C,kBAAkB,CAACT,GAAnB,CAAuBmB,GAAvB,EAA4BC,IAA5B,CAAhB;MACA,IAAIkC,SAAJ,EACE,OAAOD,kBAAkB,CAACC,SAAD,CAAzB;MAEF,OAAOV,OAAO,CAACC,IAAR,CAAa,0CAAb,EAAyDjC,OAAzD,CAAP;IACD;;IAAA;IAGDwC,eAAe,CAACtB,OAAD,EAAUJ,KAAV,EAAiBC,MAAjB,CAAf;EACD,CAzGD;AA0GD;;AAAA;AACDrE,QAAQ,CAACsB,UAAD,EAAaxB,YAAb,CAAR;AAGAwB,UAAU,CAACJ,eAAX,GAA6BA,eAA7B;AAGA+E,MAAM,CAACC,OAAP,GAAiB5E,UAAjB;;AAEA,IAAI6E,OAAO,GAAGpG,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIqG,UAAU,GAAGrG,OAAO,CAAC,sBAAD,CAAxB;;AAEAuB,UAAU,CAAC6E,OAAX,GAAqBA,OAArB;AACA7E,UAAU,CAAC6E,OAAX,CAAmBC,UAAnB,GAAgCA,UAAhC;AACA9E,UAAU,CAACrB,OAAX,GAAqBA,OAArB","names":["defineProperty_IE8","Object","defineProperty","e","Function","prototype","bind","oThis","TypeError","aArgs","Array","slice","call","arguments","fToBind","fNOP","fBound","apply","concat","EventEmitter","require","inherits","packers","Mapper","BASE_TIMEOUT","unifyResponseMethods","responseMethods","key","value","response","unifyTransport","transport","send","postMessage","write","onmessage","undefined","pause","SyntaxError","RpcNotification","method","params","enumerable","RpcBuilder","packer","options","onRequest","self","pack","unpack","on","peerID","max_retries","transportMessage","event","decode","data","getTransport","setTransport","removeEventListener","removeListener","addEventListener","addListener","get","set","request_timeout","ping_request_timeout","response_timeout","duplicates_timeout","requestID","requests","responses","processedResponses","message2Key","storeResponse","message","id","dest","timeout","setTimeout","remove","storeProcessedResponse","ack","from","RpcRequest","duplicated","Boolean","responseMethod","reply","error","result","clearTimeout","cancel","request","pop","close","forEach","encode","callback","retried","dispatchCallback","encode_transport","sendRequest","rt","Math","pow","retry","console","warn","Error","debug","notification","emit","processRequest","idAck","processResponse","duplicatedResponse","processed","module","exports","clients","transports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenViduInternal\\KurentoUtils\\kurento-jsonrpc\\index.js"],"sourcesContent":["/*\n * (C) Copyright 2014 Kurento (http://kurento.org/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n\nvar defineProperty_IE8 = false\nif (Object.defineProperty) {\n  try {\n    Object.defineProperty({}, \"x\", {});\n  } catch (e) {\n    defineProperty_IE8 = true\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n      fToBind = this,\n      fNOP = function () {},\n      fBound = function () {\n        return fToBind.apply(this instanceof fNOP && oThis ?\n          this :\n          oThis,\n          aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('inherits');\n\nvar packers = require('./packers');\nvar Mapper = require('./Mapper');\n\n\nvar BASE_TIMEOUT = 5000;\n\n\nfunction unifyResponseMethods(responseMethods) {\n  if (!responseMethods) return {};\n\n  for (var key in responseMethods) {\n    var value = responseMethods[key];\n\n    if (typeof value == 'string')\n      responseMethods[key] = {\n        response: value\n      }\n  };\n\n  return responseMethods;\n};\n\nfunction unifyTransport(transport) {\n  if (!transport) return;\n\n  // Transport as a function\n  if (transport instanceof Function)\n    return {\n      send: transport\n    };\n\n  // WebSocket & DataChannel\n  if (transport.send instanceof Function)\n    return transport;\n\n  // Message API (Inter-window & WebWorker)\n  if (transport.postMessage instanceof Function) {\n    transport.send = transport.postMessage;\n    return transport;\n  }\n\n  // Stream API\n  if (transport.write instanceof Function) {\n    transport.send = transport.write;\n    return transport;\n  }\n\n  // Transports that only can receive messages, but not send\n  if (transport.onmessage !== undefined) return;\n  if (transport.pause instanceof Function) return;\n\n  throw new SyntaxError(\"Transport is not a function nor a valid object\");\n};\n\n\n/**\n * Representation of a RPC notification\n *\n * @class\n *\n * @constructor\n *\n * @param {String} method -method of the notification\n * @param params - parameters of the notification\n */\nfunction RpcNotification(method, params) {\n  if (defineProperty_IE8) {\n    this.method = method\n    this.params = params\n  } else {\n    Object.defineProperty(this, 'method', {\n      value: method,\n      enumerable: true\n    });\n    Object.defineProperty(this, 'params', {\n      value: params,\n      enumerable: true\n    });\n  }\n};\n\n\n/**\n * @class\n *\n * @constructor\n *\n * @param {object} packer\n *\n * @param {object} [options]\n *\n * @param {object} [transport]\n *\n * @param {Function} [onRequest]\n */\nfunction RpcBuilder(packer, options, transport, onRequest) {\n  var self = this;\n\n  if (!packer)\n    throw new SyntaxError('Packer is not defined');\n\n  if (!packer.pack || !packer.unpack)\n    throw new SyntaxError('Packer is invalid');\n\n  var responseMethods = unifyResponseMethods(packer.responseMethods);\n\n\n  if (options instanceof Function) {\n    if (transport != undefined)\n      throw new SyntaxError(\"There can't be parameters after onRequest\");\n\n    onRequest = options;\n    transport = undefined;\n    options = undefined;\n  };\n\n  if (options && options.send instanceof Function) {\n    if (transport && !(transport instanceof Function))\n      throw new SyntaxError(\"Only a function can be after transport\");\n\n    onRequest = transport;\n    transport = options;\n    options = undefined;\n  };\n\n  if (transport instanceof Function) {\n    if (onRequest != undefined)\n      throw new SyntaxError(\"There can't be parameters after onRequest\");\n\n    onRequest = transport;\n    transport = undefined;\n  };\n\n  if (transport && transport.send instanceof Function)\n    if (onRequest && !(onRequest instanceof Function))\n      throw new SyntaxError(\"Only a function can be after transport\");\n\n  options = options || {};\n\n\n  EventEmitter.call(this);\n\n  if (onRequest)\n    this.on('request', onRequest);\n\n\n  if (defineProperty_IE8)\n    this.peerID = options.peerID\n  else\n    Object.defineProperty(this, 'peerID', {\n      value: options.peerID\n    });\n\n  var max_retries = options.max_retries || 0;\n\n\n  function transportMessage(event) {\n    self.decode(event.data || event);\n  };\n\n  this.getTransport = function () {\n    return transport;\n  }\n  this.setTransport = function (value) {\n    // Remove listener from old transport\n    if (transport) {\n      // W3C transports\n      if (transport.removeEventListener)\n        transport.removeEventListener('message', transportMessage);\n\n      // Node.js Streams API\n      else if (transport.removeListener)\n        transport.removeListener('data', transportMessage);\n    };\n\n    // Set listener on new transport\n    if (value) {\n      // W3C transports\n      if (value.addEventListener)\n        value.addEventListener('message', transportMessage);\n\n      // Node.js Streams API\n      else if (value.addListener)\n        value.addListener('data', transportMessage);\n    };\n\n    transport = unifyTransport(value);\n  }\n\n  if (!defineProperty_IE8)\n    Object.defineProperty(this, 'transport', {\n      get: this.getTransport.bind(this),\n      set: this.setTransport.bind(this)\n    })\n\n  this.setTransport(transport);\n\n\n  var request_timeout = options.request_timeout || BASE_TIMEOUT;\n  var ping_request_timeout = options.ping_request_timeout || request_timeout;\n  var response_timeout = options.response_timeout || BASE_TIMEOUT;\n  var duplicates_timeout = options.duplicates_timeout || BASE_TIMEOUT;\n\n\n  var requestID = 0;\n\n  var requests = new Mapper();\n  var responses = new Mapper();\n  var processedResponses = new Mapper();\n\n  var message2Key = {};\n\n\n  /**\n   * Store the response to prevent to process duplicate request later\n   */\n  function storeResponse(message, id, dest) {\n    var response = {\n      message: message,\n      /** Timeout to auto-clean old responses */\n      timeout: setTimeout(function () {\n          responses.remove(id, dest);\n        },\n        response_timeout)\n    };\n\n    responses.set(response, id, dest);\n  };\n\n  /**\n   * Store the response to ignore duplicated messages later\n   */\n  function storeProcessedResponse(ack, from) {\n    var timeout = setTimeout(function () {\n        processedResponses.remove(ack, from);\n      },\n      duplicates_timeout);\n\n    processedResponses.set(timeout, ack, from);\n  };\n\n\n  /**\n   * Representation of a RPC request\n   *\n   * @class\n   * @extends RpcNotification\n   *\n   * @constructor\n   *\n   * @param {String} method -method of the notification\n   * @param params - parameters of the notification\n   * @param {Integer} id - identifier of the request\n   * @param [from] - source of the notification\n   */\n  function RpcRequest(method, params, id, from, transport) {\n    RpcNotification.call(this, method, params);\n\n    this.getTransport = function () {\n      return transport;\n    }\n    this.setTransport = function (value) {\n      transport = unifyTransport(value);\n    }\n\n    if (!defineProperty_IE8)\n      Object.defineProperty(this, 'transport', {\n        get: this.getTransport.bind(this),\n        set: this.setTransport.bind(this)\n      })\n\n    var response = responses.get(id, from);\n\n    /**\n     * @constant {Boolean} duplicated\n     */\n    if (!(transport || self.getTransport())) {\n      if (defineProperty_IE8)\n        this.duplicated = Boolean(response)\n      else\n        Object.defineProperty(this, 'duplicated', {\n          value: Boolean(response)\n        });\n    }\n\n    var responseMethod = responseMethods[method];\n\n    this.pack = packer.pack.bind(packer, this, id)\n\n    /**\n     * Generate a response to this request\n     *\n     * @param {Error} [error]\n     * @param {*} [result]\n     *\n     * @returns {string}\n     */\n    this.reply = function (error, result, transport) {\n      // Fix optional parameters\n      if (error instanceof Function || error && error.send instanceof Function) {\n        if (result != undefined)\n          throw new SyntaxError(\"There can't be parameters after callback\");\n\n        transport = error;\n        result = null;\n        error = undefined;\n      } else if (result instanceof Function ||\n        result && result.send instanceof Function) {\n        if (transport != undefined)\n          throw new SyntaxError(\"There can't be parameters after callback\");\n\n        transport = result;\n        result = null;\n      };\n\n      transport = unifyTransport(transport);\n\n      // Duplicated request, remove old response timeout\n      if (response)\n        clearTimeout(response.timeout);\n\n      if (from != undefined) {\n        if (error)\n          error.dest = from;\n\n        if (result)\n          result.dest = from;\n      };\n\n      var message;\n\n      // New request or overriden one, create new response with provided data\n      if (error || result != undefined) {\n        if (self.peerID != undefined) {\n          if (error)\n            error.from = self.peerID;\n          else\n            result.from = self.peerID;\n        }\n\n        // Protocol indicates that responses has own request methods\n        if (responseMethod) {\n          if (responseMethod.error == undefined && error)\n            message = {\n              error: error\n            };\n\n          else {\n            var method = error ?\n              responseMethod.error :\n              responseMethod.response;\n\n            message = {\n              method: method,\n              params: error || result\n            };\n          }\n        } else\n          message = {\n            error: error,\n            result: result\n          };\n\n        message = packer.pack(message, id);\n      }\n\n      // Duplicate & not-overriden request, re-send old response\n      else if (response)\n        message = response.message;\n\n      // New empty reply, response null value\n      else\n        message = packer.pack({\n          result: null\n        }, id);\n\n      // Store the response to prevent to process a duplicated request later\n      storeResponse(message, id, from);\n\n      // Return the stored response so it can be directly send back\n      transport = transport || this.getTransport() || self.getTransport();\n\n      if (transport)\n        return transport.send(message);\n\n      return message;\n    }\n  };\n  inherits(RpcRequest, RpcNotification);\n\n\n  function cancel(message) {\n    var key = message2Key[message];\n    if (!key) return;\n\n    delete message2Key[message];\n\n    var request = requests.pop(key.id, key.dest);\n    if (!request) return;\n\n    clearTimeout(request.timeout);\n\n    // Start duplicated responses timeout\n    storeProcessedResponse(key.id, key.dest);\n  };\n\n  /**\n   * Allow to cancel a request and don't wait for a response\n   *\n   * If `message` is not given, cancel all the request\n   */\n  this.cancel = function (message) {\n    if (message) return cancel(message);\n\n    for (var message in message2Key)\n      cancel(message);\n  };\n\n\n  this.close = function () {\n    // Prevent to receive new messages\n    var transport = this.getTransport();\n    if (transport && transport.close)\n      transport.close(4003, \"Cancel request\");\n\n    // Request & processed responses\n    this.cancel();\n\n    processedResponses.forEach(clearTimeout);\n\n    // Responses\n    responses.forEach(function (response) {\n      clearTimeout(response.timeout);\n    });\n  };\n\n\n  /**\n   * Generates and encode a JsonRPC 2.0 message\n   *\n   * @param {String} method -method of the notification\n   * @param params - parameters of the notification\n   * @param [dest] - destination of the notification\n   * @param {object} [transport] - transport where to send the message\n   * @param [callback] - function called when a response to this request is\n   *   received. If not defined, a notification will be send instead\n   *\n   * @returns {string} A raw JsonRPC 2.0 request or notification string\n   */\n  this.encode = function (method, params, dest, transport, callback) {\n    // Fix optional parameters\n    if (params instanceof Function) {\n      if (dest != undefined)\n        throw new SyntaxError(\"There can't be parameters after callback\");\n\n      callback = params;\n      transport = undefined;\n      dest = undefined;\n      params = undefined;\n    } else if (dest instanceof Function) {\n      if (transport != undefined)\n        throw new SyntaxError(\"There can't be parameters after callback\");\n\n      callback = dest;\n      transport = undefined;\n      dest = undefined;\n    } else if (transport instanceof Function) {\n      if (callback != undefined)\n        throw new SyntaxError(\"There can't be parameters after callback\");\n\n      callback = transport;\n      transport = undefined;\n    };\n\n    if (self.peerID != undefined) {\n      params = params || {};\n\n      params.from = self.peerID;\n    };\n\n    if (dest != undefined) {\n      params = params || {};\n\n      params.dest = dest;\n    };\n\n    // Encode message\n    var message = {\n      method: method,\n      params: params\n    };\n\n    if (callback) {\n      var id = requestID++;\n      var retried = 0;\n\n      message = packer.pack(message, id);\n\n      function dispatchCallback(error, result) {\n        self.cancel(message);\n\n        callback(error, result);\n      };\n\n      var request = {\n        message: message,\n        callback: dispatchCallback,\n        responseMethods: responseMethods[method] || {}\n      };\n\n      var encode_transport = unifyTransport(transport);\n\n      function sendRequest(transport) {\n        var rt = (method === 'ping' ? ping_request_timeout : request_timeout);\n        request.timeout = setTimeout(timeout, rt * Math.pow(2, retried++));\n        message2Key[message] = {\n          id: id,\n          dest: dest\n        };\n        requests.set(request, id, dest);\n\n        transport = transport || encode_transport || self.getTransport();\n        if (transport)\n          return transport.send(message);\n\n        return message;\n      };\n\n      function retry(transport) {\n        transport = unifyTransport(transport);\n\n        console.warn(retried + ' retry for request message:', message);\n\n        var timeout = processedResponses.pop(id, dest);\n        clearTimeout(timeout);\n\n        return sendRequest(transport);\n      };\n\n      function timeout() {\n        if (retried < max_retries)\n          return retry(transport);\n\n        var error = new Error('Request has timed out');\n        error.request = message;\n\n        error.retry = retry;\n\n        dispatchCallback(error)\n      };\n\n      return sendRequest(transport);\n    };\n\n    // Return the packed message\n    message = packer.pack(message);\n\n    transport = transport || this.getTransport();\n    if (transport)\n      return transport.send(message);\n\n    return message;\n  };\n\n  /**\n   * Decode and process a JsonRPC 2.0 message\n   *\n   * @param {string} message - string with the content of the message\n   *\n   * @returns {RpcNotification|RpcRequest|undefined} - the representation of the\n   *   notification or the request. If a response was processed, it will return\n   *   `undefined` to notify that it was processed\n   *\n   * @throws {TypeError} - Message is not defined\n   */\n  this.decode = function (message, transport) {\n    if (!message)\n      throw new TypeError(\"Message is not defined\");\n\n    try {\n      message = packer.unpack(message);\n    } catch (e) {\n      // Ignore invalid messages\n      return console.debug(e, message);\n    };\n\n    var id = message.id;\n    var ack = message.ack;\n    var method = message.method;\n    var params = message.params || {};\n\n    var from = params.from;\n    var dest = params.dest;\n\n    // Ignore messages send by us\n    if (self.peerID != undefined && from == self.peerID) return;\n\n    // Notification\n    if (id == undefined && ack == undefined) {\n      var notification = new RpcNotification(method, params);\n\n      if (self.emit('request', notification)) return;\n      return notification;\n    };\n\n\n    function processRequest() {\n      // If we have a transport and it's a duplicated request, reply inmediatly\n      transport = unifyTransport(transport) || self.getTransport();\n      if (transport) {\n        var response = responses.get(id, from);\n        if (response)\n          return transport.send(response.message);\n      };\n\n      var idAck = (id != undefined) ? id : ack;\n      var request = new RpcRequest(method, params, idAck, from, transport);\n\n      if (self.emit('request', request)) return;\n      return request;\n    };\n\n    function processResponse(request, error, result) {\n      request.callback(error, result);\n    };\n\n    function duplicatedResponse(timeout) {\n      console.warn(\"Response already processed\", message);\n\n      // Update duplicated responses timeout\n      clearTimeout(timeout);\n      storeProcessedResponse(ack, from);\n    };\n\n\n    // Request, or response with own method\n    if (method) {\n      // Check if it's a response with own method\n      if (dest == undefined || dest == self.peerID) {\n        var request = requests.get(ack, from);\n        if (request) {\n          var responseMethods = request.responseMethods;\n\n          if (method == responseMethods.error)\n            return processResponse(request, params);\n\n          if (method == responseMethods.response)\n            return processResponse(request, null, params);\n\n          return processRequest();\n        }\n\n        var processed = processedResponses.get(ack, from);\n        if (processed)\n          return duplicatedResponse(processed);\n      }\n\n      // Request\n      return processRequest();\n    };\n\n    var error = message.error;\n    var result = message.result;\n\n    // Ignore responses not send to us\n    if (error && error.dest && error.dest != self.peerID) return;\n    if (result && result.dest && result.dest != self.peerID) return;\n\n    // Response\n    var request = requests.get(ack, from);\n    if (!request) {\n      var processed = processedResponses.get(ack, from);\n      if (processed)\n        return duplicatedResponse(processed);\n\n      return console.warn(\"No callback was defined for this message\", message);\n    };\n\n    // Process response\n    processResponse(request, error, result);\n  };\n};\ninherits(RpcBuilder, EventEmitter);\n\n\nRpcBuilder.RpcNotification = RpcNotification;\n\n\nmodule.exports = RpcBuilder;\n\nvar clients = require('./clients');\nvar transports = require('./clients/transports');\n\nRpcBuilder.clients = clients;\nRpcBuilder.clients.transports = transports;\nRpcBuilder.packers = packers;"]},"metadata":{},"sourceType":"script"}
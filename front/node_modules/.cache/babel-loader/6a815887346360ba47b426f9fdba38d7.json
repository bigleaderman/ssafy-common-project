{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OpenVidu = void 0;\n\nvar LocalRecorder_1 = require(\"./LocalRecorder\");\n\nvar Publisher_1 = require(\"./Publisher\");\n\nvar Session_1 = require(\"./Session\");\n\nvar SessionDisconnectedEvent_1 = require(\"../OpenViduInternal/Events/SessionDisconnectedEvent\");\n\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\n\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\n\nvar VideoInsertMode_1 = require(\"../OpenViduInternal/Enums/VideoInsertMode\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar screenSharingAuto = require(\"../OpenViduInternal/ScreenSharing/Screen-Capturing-Auto\");\n\nvar screenSharing = require(\"../OpenViduInternal/ScreenSharing/Screen-Capturing\");\n\nvar OpenViduLoggerConfiguration_1 = require(\"../OpenViduInternal/Logger/OpenViduLoggerConfiguration\");\n/**\n * @hidden\n */\n\n\nvar EventEmitter = require(\"wolfy87-eventemitter\");\n/**\n * @hidden\n */\n\n\nvar RpcBuilder = require(\"../OpenViduInternal/KurentoUtils/kurento-jsonrpc\");\n/**\n * @hidden\n */\n\n\nvar packageJson = require('../../package.json');\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Entrypoint of OpenVidu Browser library.\n * Use it to initialize objects of type [[Session]], [[Publisher]] and [[LocalRecorder]]\n */\n\nvar OpenVidu =\n/** @class */\nfunction () {\n  function OpenVidu() {\n    var _this = this;\n\n    this.masterNodeHasCrashed = false;\n    /**\n     * @hidden\n     */\n\n    this.publishers = [];\n    /**\n     * @hidden\n     */\n\n    this.secret = '';\n    /**\n     * @hidden\n     */\n\n    this.recorder = false;\n    /**\n     * @hidden\n     */\n\n    this.life = -1;\n    /**\n     * @hidden\n     */\n\n    this.advancedConfiguration = {};\n    /**\n     * @hidden\n     */\n\n    this.webrtcStatsInterval = -1;\n    /**\n     * @hidden\n     */\n\n    this.sendBrowserLogs = OpenViduLoggerConfiguration_1.OpenViduLoggerConfiguration.disabled;\n    /**\n     * @hidden\n     */\n\n    this.isAtLeastPro = false;\n    /**\n     * @hidden\n     */\n\n    this.isEnterprise = false;\n    /**\n     * @hidden\n     */\n\n    this.ee = new EventEmitter();\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.libraryVersion = packageJson.version;\n    logger.info(\"OpenVidu initialized\");\n    logger.info('Platform detected: ' + platform.getDescription());\n    logger.info('openvidu-browser version: ' + this.libraryVersion);\n\n    if (platform.isMobileDevice() || platform.isReactNative()) {\n      // Listen to orientationchange only on mobile devices\n      this.onOrientationChanged(function () {\n        _this.publishers.forEach(function (publisher) {\n          if (publisher.stream.isLocalStreamPublished && !!publisher.stream && !!publisher.stream.hasVideo) {\n            _this.sendNewVideoDimensionsIfRequired(publisher, 'deviceRotated', 75, 10);\n          }\n        });\n      });\n    }\n  }\n  /**\n   * Returns new session\n   */\n\n\n  OpenVidu.prototype.initSession = function () {\n    this.session = new Session_1.Session(this);\n    return this.session;\n  };\n  /**\n   * Returns a new publisher\n   *\n   * #### Events dispatched\n   *\n   * The [[Publisher]] object will dispatch an `accessDialogOpened` event, only if the pop-up shown by the browser to request permissions for the camera is opened. You can use this event to alert the user about granting permissions\n   * for your website. An `accessDialogClosed` event will also be dispatched after user clicks on \"Allow\" or \"Block\" in the pop-up.\n   *\n   * The [[Publisher]] object will dispatch an `accessAllowed` or `accessDenied` event once it has been granted access to the requested input devices or not.\n   *\n   * The [[Publisher]] object will dispatch a `videoElementCreated` event once a HTML video element has been added to DOM (only if you\n   * [let OpenVidu take care of the video players](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)). See [[VideoElementEvent]] to learn more.\n   *\n   * The [[Publisher]] object will dispatch a `streamPlaying` event once the local streams starts playing. See [[StreamManagerEvent]] to learn more.\n   *\n   * @param targetElement  HTML DOM element (or its `id` attribute) in which the video element of the Publisher will be inserted (see [[PublisherProperties.insertMode]]). If *null* or *undefined* no default video will be created for this Publisher.\n   * You can always call method [[Publisher.addVideoElement]] or [[Publisher.createVideoElement]] to manage the video elements on your own (see [Manage video players](/en/stable/cheatsheet/manage-videos) section)\n   * @param completionHandler `error` parameter is null if `initPublisher` succeeds, and is defined if it fails.\n   *                          `completionHandler` function is called before the Publisher dispatches an `accessAllowed` or an `accessDenied` event\n   */\n\n\n  OpenVidu.prototype.initPublisher = function (targetElement, param2, param3) {\n    var properties;\n\n    if (!!param2 && typeof param2 !== 'function') {\n      // Matches 'initPublisher(targetElement, properties)' or 'initPublisher(targetElement, properties, completionHandler)'\n      properties = param2;\n      properties = {\n        audioSource: typeof properties.audioSource !== 'undefined' ? properties.audioSource : undefined,\n        frameRate: typeof MediaStreamTrack !== 'undefined' && properties.videoSource instanceof MediaStreamTrack ? undefined : typeof properties.frameRate !== 'undefined' ? properties.frameRate : undefined,\n        insertMode: typeof properties.insertMode !== 'undefined' ? typeof properties.insertMode === 'string' ? VideoInsertMode_1.VideoInsertMode[properties.insertMode] : properties.insertMode : VideoInsertMode_1.VideoInsertMode.APPEND,\n        mirror: typeof properties.mirror !== 'undefined' ? properties.mirror : true,\n        publishAudio: typeof properties.publishAudio !== 'undefined' ? properties.publishAudio : true,\n        publishVideo: typeof properties.publishVideo !== 'undefined' ? properties.publishVideo : true,\n        resolution: typeof MediaStreamTrack !== 'undefined' && properties.videoSource instanceof MediaStreamTrack ? undefined : typeof properties.resolution !== 'undefined' ? properties.resolution : '640x480',\n        videoSource: typeof properties.videoSource !== 'undefined' ? properties.videoSource : undefined,\n        videoSimulcast: properties.videoSimulcast,\n        filter: properties.filter\n      };\n    } else {\n      // Matches 'initPublisher(targetElement)' or 'initPublisher(targetElement, completionHandler)'\n      properties = {\n        insertMode: VideoInsertMode_1.VideoInsertMode.APPEND,\n        mirror: true,\n        publishAudio: true,\n        publishVideo: true,\n        resolution: '640x480'\n      };\n    }\n\n    var publisher = new Publisher_1.Publisher(targetElement, properties, this);\n    var completionHandler;\n\n    if (!!param2 && typeof param2 === 'function') {\n      completionHandler = param2;\n    } else if (!!param3) {\n      completionHandler = param3;\n    }\n\n    publisher.initialize().then(function () {\n      if (completionHandler !== undefined) {\n        completionHandler(undefined);\n      }\n\n      publisher.emitEvent('accessAllowed', []);\n    }).catch(function (error) {\n      if (completionHandler !== undefined) {\n        completionHandler(error);\n      }\n\n      publisher.emitEvent('accessDenied', [error]);\n    });\n    this.publishers.push(publisher);\n    return publisher;\n  };\n\n  OpenVidu.prototype.initPublisherAsync = function (targetElement, properties) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var publisher;\n\n      var callback = function callback(error) {\n        if (!!error) {\n          return reject(error);\n        } else {\n          return resolve(publisher);\n        }\n      };\n\n      if (!!properties) {\n        publisher = _this.initPublisher(targetElement, properties, callback);\n      } else {\n        publisher = _this.initPublisher(targetElement, callback);\n      }\n    });\n  };\n  /**\n   * Returns a new local recorder for recording streams straight away from the browser\n   * @param stream  Stream to record\n   */\n\n\n  OpenVidu.prototype.initLocalRecorder = function (stream) {\n    return new LocalRecorder_1.LocalRecorder(stream);\n  };\n  /**\n   * Checks if the browser supports OpenVidu\n   * @returns 1 if the browser supports OpenVidu, 0 otherwise\n   */\n\n\n  OpenVidu.prototype.checkSystemRequirements = function () {\n    if (platform.isIPhoneOrIPad()) {\n      if (platform.isIOSWithSafari() || platform.isIonicIos() || platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser()) {\n        return 1;\n      }\n\n      return 0;\n    } // Accept: Chrome (desktop and Android), Firefox (desktop and Android), Opera (desktop and Android),\n    // Safari (OSX and iOS), Edge Chromium (>= 80), Ionic (Android and iOS), Samsung Internet Browser (Android)\n\n\n    if (platform.isChromeBrowser() || platform.isChromeMobileBrowser() || platform.isFirefoxBrowser() || platform.isFirefoxMobileBrowser() || platform.isOperaBrowser() || platform.isOperaMobileBrowser() || platform.isEdgeBrowser() || platform.isEdgeMobileBrowser() || platform.isSafariBrowser() || platform.isAndroidBrowser() || platform.isElectron() || platform.isSamsungBrowser()) {\n      return 1;\n    } // Reject iPhones and iPads if not Safari ('Safari' also covers Ionic for iOS)\n    // Reject others browsers not mentioned above\n\n\n    return 0;\n  };\n  /**\n   * Checks if the browser supports screen-sharing. Desktop Chrome, Firefox and Opera support screen-sharing\n   * @returns 1 if the browser supports screen-sharing, 0 otherwise\n   */\n\n\n  OpenVidu.prototype.checkScreenSharingCapabilities = function () {\n    return platform.canScreenShare();\n  };\n  /**\n   * Collects information about the media input devices available on the system. You can pass property `deviceId` of a [[Device]] object as value of `audioSource` or `videoSource` properties in [[initPublisher]] method\n   */\n\n\n  OpenVidu.prototype.getDevices = function () {\n    return new Promise(function (resolve, reject) {\n      navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {\n        var _a;\n\n        var devices = []; // Ionic Android  devices\n\n        if (platform.isIonicAndroid() && typeof cordova != \"undefined\" && ((_a = cordova === null || cordova === void 0 ? void 0 : cordova.plugins) === null || _a === void 0 ? void 0 : _a.EnumerateDevicesPlugin)) {\n          cordova.plugins.EnumerateDevicesPlugin.getEnumerateDevices().then(function (pluginDevices) {\n            var pluginAudioDevices = [];\n            var videoDevices = [];\n            var audioDevices = [];\n            pluginAudioDevices = pluginDevices.filter(function (device) {\n              return device.kind === 'audioinput';\n            });\n            videoDevices = deviceInfos.filter(function (device) {\n              return device.kind === 'videoinput';\n            });\n            audioDevices = deviceInfos.filter(function (device) {\n              return device.kind === 'audioinput';\n            });\n            videoDevices.forEach(function (deviceInfo, index) {\n              if (!deviceInfo.label) {\n                var label = \"\";\n\n                if (index === 0) {\n                  label = \"Front Camera\";\n                } else if (index === 1) {\n                  label = \"Back Camera\";\n                } else {\n                  label = \"Unknown Camera\";\n                }\n\n                devices.push({\n                  kind: deviceInfo.kind,\n                  deviceId: deviceInfo.deviceId,\n                  label: label\n                });\n              } else {\n                devices.push({\n                  kind: deviceInfo.kind,\n                  deviceId: deviceInfo.deviceId,\n                  label: deviceInfo.label\n                });\n              }\n            });\n            audioDevices.forEach(function (deviceInfo, index) {\n              if (!deviceInfo.label) {\n                var label = \"\";\n\n                switch (index) {\n                  case 0:\n                    // Default Microphone\n                    label = 'Default';\n                    break;\n\n                  case 1:\n                    // Microphone + Speakerphone\n                    var defaultMatch = pluginAudioDevices.filter(function (d) {\n                      return d.label.includes('Built');\n                    })[0];\n                    label = defaultMatch ? defaultMatch.label : 'Built-in Microphone';\n                    break;\n\n                  case 2:\n                    // Headset Microphone\n                    var wiredMatch = pluginAudioDevices.filter(function (d) {\n                      return d.label.includes('Wired');\n                    })[0];\n\n                    if (wiredMatch) {\n                      label = wiredMatch.label;\n                    } else {\n                      label = 'Headset earpiece';\n                    }\n\n                    break;\n\n                  case 3:\n                    var wirelessMatch = pluginAudioDevices.filter(function (d) {\n                      return d.label.includes('Bluetooth');\n                    })[0];\n                    label = wirelessMatch ? wirelessMatch.label : 'Wireless';\n                    break;\n\n                  default:\n                    label = \"Unknown Microphone\";\n                    break;\n                }\n\n                devices.push({\n                  kind: deviceInfo.kind,\n                  deviceId: deviceInfo.deviceId,\n                  label: label\n                });\n              } else {\n                devices.push({\n                  kind: deviceInfo.kind,\n                  deviceId: deviceInfo.deviceId,\n                  label: deviceInfo.label\n                });\n              }\n            });\n            return resolve(devices);\n          });\n        } else {\n          // Rest of platforms\n          deviceInfos.forEach(function (deviceInfo) {\n            if (deviceInfo.kind === 'audioinput' || deviceInfo.kind === 'videoinput') {\n              devices.push({\n                kind: deviceInfo.kind,\n                deviceId: deviceInfo.deviceId,\n                label: deviceInfo.label\n              });\n            }\n          });\n          return resolve(devices);\n        }\n      }).catch(function (error) {\n        logger.error('Error getting devices', error);\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * Get a MediaStream object that you can customize before calling [[initPublisher]] (pass _MediaStreamTrack_ property of the _MediaStream_ value resolved by the Promise as `audioSource` or `videoSource` properties in [[initPublisher]])\n   *\n   * Parameter `options` is the same as in [[initPublisher]] second parameter (of type [[PublisherProperties]]), but only the following properties will be applied: `audioSource`, `videoSource`, `frameRate`, `resolution`\n   *\n   * To customize the Publisher's video, the API for HTMLCanvasElement is very useful. For example, to get a black-and-white video at 10 fps and HD resolution with no sound:\n   * ```\n   * var OV = new OpenVidu();\n   * var FRAME_RATE = 10;\n   *\n   * OV.getUserMedia({\n   *    audioSource: false,\n   *    videoSource: undefined,\n   *    resolution: '1280x720',\n   *    frameRate: FRAME_RATE\n   * })\n   * .then(mediaStream => {\n   *\n   *    var videoTrack = mediaStream.getVideoTracks()[0];\n   *    var video = document.createElement('video');\n   *    video.srcObject = new MediaStream([videoTrack]);\n   *\n   *    var canvas = document.createElement('canvas');\n   *    var ctx = canvas.getContext('2d');\n   *    ctx.filter = 'grayscale(100%)';\n   *\n   *    video.addEventListener('play', () => {\n   *      var loop = () => {\n   *        if (!video.paused && !video.ended) {\n   *          ctx.drawImage(video, 0, 0, 300, 170);\n   *          setTimeout(loop, 1000/ FRAME_RATE); // Drawing at 10 fps\n   *        }\n   *      };\n   *      loop();\n   *    });\n   *    video.play();\n   *\n   *    var grayVideoTrack = canvas.captureStream(FRAME_RATE).getVideoTracks()[0];\n   *    var publisher = this.OV.initPublisher(\n   *      myHtmlTarget,\n   *      {\n   *        audioSource: false,\n   *        videoSource: grayVideoTrack\n   *      });\n   * });\n   * ```\n   */\n\n\n  OpenVidu.prototype.getUserMedia = function (options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var askForAudioStreamOnly = function askForAudioStreamOnly(previousMediaStream, constraints) {\n        var definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n        var constraintsAux = {\n          audio: definedAudioConstraint,\n          video: false\n        };\n        navigator.mediaDevices.getUserMedia(constraintsAux).then(function (audioOnlyStream) {\n          previousMediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n          return resolve(previousMediaStream);\n        }).catch(function (error) {\n          previousMediaStream.getAudioTracks().forEach(function (track) {\n            track.stop();\n          });\n          previousMediaStream.getVideoTracks().forEach(function (track) {\n            track.stop();\n          });\n          return reject(_this.generateAudioDeviceError(error, constraintsAux));\n        });\n      };\n\n      _this.generateMediaConstraints(options).then(function (myConstraints) {\n        var _a, _b;\n\n        if (!!myConstraints.videoTrack && !!myConstraints.audioTrack || !!myConstraints.audioTrack && ((_a = myConstraints.constraints) === null || _a === void 0 ? void 0 : _a.video) === false || !!myConstraints.videoTrack && ((_b = myConstraints.constraints) === null || _b === void 0 ? void 0 : _b.audio) === false) {\n          // No need to call getUserMedia at all. Both tracks provided, or only AUDIO track provided or only VIDEO track provided\n          return resolve(_this.addAlreadyProvidedTracks(myConstraints, new MediaStream()));\n        } else {\n          // getUserMedia must be called. AUDIO or VIDEO are requesting a new track\n          // Delete already provided constraints for audio or video\n          if (!!myConstraints.videoTrack) {\n            delete myConstraints.constraints.video;\n          }\n\n          if (!!myConstraints.audioTrack) {\n            delete myConstraints.constraints.audio;\n          }\n\n          var mustAskForAudioTrackLater_1 = false;\n\n          if (typeof options.videoSource === 'string') {\n            // Video is deviceId or screen sharing\n            if (options.videoSource === 'screen' || options.videoSource === 'window' || platform.isElectron() && options.videoSource.startsWith('screen:')) {\n              // Video is screen sharing\n              mustAskForAudioTrackLater_1 = !myConstraints.audioTrack && options.audioSource !== null && options.audioSource !== false;\n\n              if (navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron()) {\n                // getDisplayMedia supported\n                navigator.mediaDevices['getDisplayMedia']({\n                  video: true\n                }).then(function (mediaStream) {\n                  _this.addAlreadyProvidedTracks(myConstraints, mediaStream);\n\n                  if (mustAskForAudioTrackLater_1) {\n                    askForAudioStreamOnly(mediaStream, myConstraints.constraints);\n                    return;\n                  } else {\n                    return resolve(mediaStream);\n                  }\n                }).catch(function (error) {\n                  var errorName = OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED;\n                  var errorMessage = error.toString();\n                  return reject(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                });\n                return;\n              } else {// getDisplayMedia NOT supported. Can perform getUserMedia below with already calculated constraints\n              }\n            } else {// Video is deviceId. Can perform getUserMedia below with already calculated constraints\n            }\n          } // Use already calculated constraints\n\n\n          var constraintsAux = mustAskForAudioTrackLater_1 ? {\n            video: myConstraints.constraints.video\n          } : myConstraints.constraints;\n          navigator.mediaDevices.getUserMedia(constraintsAux).then(function (mediaStream) {\n            _this.addAlreadyProvidedTracks(myConstraints, mediaStream);\n\n            if (mustAskForAudioTrackLater_1) {\n              askForAudioStreamOnly(mediaStream, myConstraints.constraints);\n              return;\n            } else {\n              return resolve(mediaStream);\n            }\n          }).catch(function (error) {\n            var errorName;\n            var errorMessage = error.toString();\n\n            if (!(options.videoSource === 'screen')) {\n              errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ACCESS_DENIED;\n            } else {\n              errorName = OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED;\n            }\n\n            return reject(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n          });\n        }\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /* tslint:disable:no-empty */\n\n  /**\n   * Disable all logging except error level\n   */\n\n\n  OpenVidu.prototype.enableProdMode = function () {\n    logger.enableProdMode();\n  };\n  /* tslint:enable:no-empty */\n\n  /**\n   * Set OpenVidu advanced configuration options. `configuration` is an object of type [[OpenViduAdvancedConfiguration]]. Call this method to override previous values at any moment.\n   */\n\n\n  OpenVidu.prototype.setAdvancedConfiguration = function (configuration) {\n    this.advancedConfiguration = configuration;\n  };\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.onOrientationChanged = function (handler) {\n    window.addEventListener('orientationchange', handler);\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.sendNewVideoDimensionsIfRequired = function (publisher, reason, WAIT_INTERVAL, MAX_ATTEMPTS) {\n    var _this = this;\n\n    var attempts = 0;\n    var oldWidth = publisher.stream.videoDimensions.width;\n    var oldHeight = publisher.stream.videoDimensions.height;\n    var repeatUntilChangeOrMaxAttempts = setInterval(function () {\n      attempts++;\n\n      if (attempts > MAX_ATTEMPTS) {\n        clearTimeout(repeatUntilChangeOrMaxAttempts);\n      }\n\n      publisher.getVideoDimensions().then(function (newDimensions) {\n        if (newDimensions.width !== oldWidth || newDimensions.height !== oldHeight) {\n          clearTimeout(repeatUntilChangeOrMaxAttempts);\n\n          _this.sendVideoDimensionsChangedEvent(publisher, reason, oldWidth, oldHeight, newDimensions.width, newDimensions.height);\n        }\n      });\n    }, WAIT_INTERVAL);\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.sendVideoDimensionsChangedEvent = function (publisher, reason, oldWidth, oldHeight, newWidth, newHeight) {\n    var _this = this;\n\n    publisher.stream.videoDimensions = {\n      width: newWidth || 0,\n      height: newHeight || 0\n    };\n    this.sendRequest('streamPropertyChanged', {\n      streamId: publisher.stream.streamId,\n      property: 'videoDimensions',\n      newValue: JSON.stringify(publisher.stream.videoDimensions),\n      reason: reason\n    }, function (error, response) {\n      if (error) {\n        logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n      } else {\n        _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, publisher.stream, 'videoDimensions', publisher.stream.videoDimensions, {\n          width: oldWidth,\n          height: oldHeight\n        }, reason)]);\n\n        publisher.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(publisher, publisher.stream, 'videoDimensions', publisher.stream.videoDimensions, {\n          width: oldWidth,\n          height: oldHeight\n        }, reason)]);\n\n        _this.session.sendVideoData(publisher);\n      }\n    });\n  };\n\n  ;\n  /**\n   * @hidden\n   */\n\n  OpenVidu.prototype.generateMediaConstraints = function (publisherProperties) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var myConstraints = {\n        audioTrack: undefined,\n        videoTrack: undefined,\n        constraints: {\n          audio: undefined,\n          video: undefined\n        }\n      };\n      var audioSource = publisherProperties.audioSource;\n      var videoSource = publisherProperties.videoSource; // CASE 1: null/false\n\n      if (audioSource === null || audioSource === false) {\n        // No audio track\n        myConstraints.constraints.audio = false;\n      }\n\n      if (videoSource === null || videoSource === false) {\n        // No video track\n        myConstraints.constraints.video = false;\n      }\n\n      if (myConstraints.constraints.audio === false && myConstraints.constraints.video === false) {\n        // ERROR! audioSource and videoSource cannot be both false at the same time\n        return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.NO_INPUT_SOURCE_SET, \"Properties 'audioSource' and 'videoSource' cannot be set to false or null at the same time\"));\n      } // CASE 2: MediaStreamTracks\n\n\n      if (typeof MediaStreamTrack !== 'undefined' && audioSource instanceof MediaStreamTrack) {\n        // Already provided audio track\n        myConstraints.audioTrack = audioSource;\n      }\n\n      if (typeof MediaStreamTrack !== 'undefined' && videoSource instanceof MediaStreamTrack) {\n        // Already provided video track\n        myConstraints.videoTrack = videoSource;\n      } // CASE 3: Default tracks\n\n\n      if (audioSource === undefined) {\n        myConstraints.constraints.audio = true;\n      }\n\n      if (videoSource === undefined) {\n        myConstraints.constraints.video = {\n          width: {\n            ideal: 640\n          },\n          height: {\n            ideal: 480\n          }\n        };\n      } // CASE 3.5: give values to resolution and frameRate if video not null/false\n\n\n      if (videoSource !== null && videoSource !== false) {\n        if (!!publisherProperties.resolution) {\n          var widthAndHeight = publisherProperties.resolution.toLowerCase().split('x');\n          var idealWidth = Number(widthAndHeight[0]);\n          var idealHeight = Number(widthAndHeight[1]);\n          myConstraints.constraints.video = {\n            width: {\n              ideal: idealWidth\n            },\n            height: {\n              ideal: idealHeight\n            }\n          };\n        }\n\n        if (!!publisherProperties.frameRate) {\n          myConstraints.constraints.video.frameRate = {\n            ideal: publisherProperties.frameRate\n          };\n        }\n      } // CASE 4: deviceId or screen sharing\n\n\n      _this.configureDeviceIdOrScreensharing(myConstraints, publisherProperties, resolve, reject);\n\n      return resolve(myConstraints);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.startWs = function (onConnectSucces) {\n    var config = {\n      heartbeat: 5000,\n      ws: {\n        uri: this.wsUri + '?sessionId=' + this.session.sessionId,\n        onconnected: onConnectSucces,\n        ondisconnect: this.disconnectCallback.bind(this),\n        onreconnecting: this.reconnectingCallback.bind(this),\n        onreconnected: this.reconnectedCallback.bind(this),\n        ismasternodecrashed: this.isMasterNodeCrashed.bind(this)\n      },\n      rpc: {\n        requestTimeout: 10000,\n        heartbeatRequestTimeout: 5000,\n        participantJoined: this.session.onParticipantJoined.bind(this.session),\n        participantPublished: this.session.onParticipantPublished.bind(this.session),\n        participantUnpublished: this.session.onParticipantUnpublished.bind(this.session),\n        participantLeft: this.session.onParticipantLeft.bind(this.session),\n        participantEvicted: this.session.onParticipantEvicted.bind(this.session),\n        recordingStarted: this.session.onRecordingStarted.bind(this.session),\n        recordingStopped: this.session.onRecordingStopped.bind(this.session),\n        sendMessage: this.session.onNewMessage.bind(this.session),\n        streamPropertyChanged: this.session.onStreamPropertyChanged.bind(this.session),\n        connectionPropertyChanged: this.session.onConnectionPropertyChanged.bind(this.session),\n        networkQualityLevelChanged: this.session.onNetworkQualityLevelChangedChanged.bind(this.session),\n        filterEventDispatched: this.session.onFilterEventDispatched.bind(this.session),\n        iceCandidate: this.session.recvIceCandidate.bind(this.session),\n        mediaError: this.session.onMediaError.bind(this.session),\n        masterNodeCrashedNotification: this.onMasterNodeCrashedNotification.bind(this),\n        forciblyReconnectSubscriber: this.session.onForciblyReconnectSubscriber.bind(this.session)\n      }\n    };\n    this.jsonRpcClient = new RpcBuilder.clients.JsonRpcClient(config);\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.onMasterNodeCrashedNotification = function (response) {\n    console.error('Master Node has crashed');\n    this.masterNodeHasCrashed = true;\n    this.session.onLostConnection(\"nodeCrashed\");\n    this.jsonRpcClient.close(4103, \"Master Node has crashed\");\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.getWsReadyState = function () {\n    return this.jsonRpcClient.getReadyState();\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.closeWs = function () {\n    this.jsonRpcClient.close(4102, \"Connection closed by client\");\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.sendRequest = function (method, params, callback) {\n    if (params && params instanceof Function) {\n      callback = params;\n      params = {};\n    }\n\n    logger.debug('Sending request: {method:\"' + method + '\", params: ' + JSON.stringify(params) + '}');\n    this.jsonRpcClient.send(method, params, callback);\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.getWsUri = function () {\n    return this.wsUri;\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.getSecret = function () {\n    return this.secret;\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.getRecorder = function () {\n    return this.recorder;\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.generateAudioDeviceError = function (error, constraints) {\n    if (error.name === 'Error') {\n      // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n      error.name = error.constructor.name;\n    }\n\n    var errorName, errorMessage;\n\n    switch (error.name.toLowerCase()) {\n      case 'notfounderror':\n        errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n        errorMessage = error.toString();\n        return new OpenViduError_1.OpenViduError(errorName, errorMessage);\n\n      case 'notallowederror':\n        errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ACCESS_DENIED;\n        errorMessage = error.toString();\n        return new OpenViduError_1.OpenViduError(errorName, errorMessage);\n\n      case 'overconstrainederror':\n        if (error.constraint.toLowerCase() === 'deviceid') {\n          errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n          errorMessage = \"Audio input device with deviceId '\" + constraints.audio.deviceId.exact + \"' not found\";\n        } else {\n          errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n          errorMessage = \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n        }\n\n        return new OpenViduError_1.OpenViduError(errorName, errorMessage);\n\n      case 'notreadableerror':\n        errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n        errorMessage = error.toString();\n        return new OpenViduError_1.OpenViduError(errorName, errorMessage);\n\n      default:\n        return new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_GENERIC_ERROR, error.toString());\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.addAlreadyProvidedTracks = function (myConstraints, mediaStream, stream) {\n    if (!!myConstraints.videoTrack) {\n      mediaStream.addTrack(myConstraints.videoTrack);\n\n      if (!!stream) {\n        if (!!myConstraints.constraints.video) {\n          stream.lastVideoTrackConstraints = myConstraints.constraints.video;\n        } else {\n          stream.lastVideoTrackConstraints = myConstraints.videoTrack.getConstraints();\n        }\n      }\n    }\n\n    if (!!myConstraints.audioTrack) {\n      mediaStream.addTrack(myConstraints.audioTrack);\n    }\n\n    return mediaStream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.configureDeviceIdOrScreensharing = function (myConstraints, publisherProperties, resolve, reject) {\n    var _this = this;\n\n    var audioSource = publisherProperties.audioSource;\n    var videoSource = publisherProperties.videoSource;\n\n    if (typeof audioSource === 'string') {\n      myConstraints.constraints.audio = {\n        deviceId: {\n          exact: audioSource\n        }\n      };\n    }\n\n    if (typeof videoSource === 'string') {\n      if (!this.isScreenShare(videoSource)) {\n        this.setVideoSource(myConstraints, videoSource);\n      } else {\n        // Screen sharing\n        if (!this.checkScreenSharingCapabilities()) {\n          var error = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_SHARING_NOT_SUPPORTED, 'You can only screen share in desktop Chrome, Firefox, Opera, Safari (>=13.0), Edge (>= 80) or Electron. Detected client: ' + platform.getName() + ' ' + platform.getVersion());\n          logger.error(error);\n          return reject(error);\n        } else {\n          if (platform.isElectron()) {\n            var prefix = \"screen:\";\n            var videoSourceString = videoSource;\n            var electronScreenId = videoSourceString.substr(videoSourceString.indexOf(prefix) + prefix.length);\n            myConstraints.constraints.video = {\n              mandatory: {\n                chromeMediaSource: 'desktop',\n                chromeMediaSourceId: electronScreenId\n              }\n            };\n            return resolve(myConstraints);\n          } else {\n            if (!!this.advancedConfiguration.screenShareChromeExtension && !(platform.isFirefoxBrowser() || platform.isFirefoxMobileBrowser()) && !navigator.mediaDevices['getDisplayMedia']) {\n              // Custom screen sharing extension for Chrome (and Opera) and no support for MediaDevices.getDisplayMedia()\n              screenSharing.getScreenConstraints(function (error, screenConstraints) {\n                if (!!error || !!screenConstraints.mandatory && screenConstraints.mandatory.chromeMediaSource === 'screen') {\n                  if (error === 'permission-denied' || error === 'PermissionDeniedError') {\n                    var error_1 = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED, 'You must allow access to one window of your desktop');\n                    logger.error(error_1);\n                    return reject(error_1);\n                  } else {\n                    var extensionId = _this.advancedConfiguration.screenShareChromeExtension.split('/').pop().trim();\n\n                    screenSharing.getChromeExtensionStatus(extensionId, function (status) {\n                      if (status === 'installed-disabled') {\n                        var error_2 = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_EXTENSION_DISABLED, 'You must enable the screen extension');\n                        logger.error(error_2);\n                        return reject(error_2);\n                      }\n\n                      if (status === 'not-installed') {\n                        var error_3 = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_EXTENSION_NOT_INSTALLED, _this.advancedConfiguration.screenShareChromeExtension);\n                        logger.error(error_3);\n                        return reject(error_3);\n                      }\n                    });\n                    return;\n                  }\n                } else {\n                  myConstraints.constraints.video = screenConstraints;\n                  return resolve(myConstraints);\n                }\n              });\n              return;\n            } else {\n              if (navigator.mediaDevices['getDisplayMedia']) {\n                // getDisplayMedia support (Chrome >= 72, Firefox >= 66, Safari >= 13)\n                return resolve(myConstraints);\n              } else {\n                // Default screen sharing extension for Chrome/Opera, or is Firefox < 66\n                var firefoxString = platform.isFirefoxBrowser() || platform.isFirefoxMobileBrowser() ? publisherProperties.videoSource : undefined;\n                screenSharingAuto.getScreenId(firefoxString, function (error, sourceId, screenConstraints) {\n                  if (!!error) {\n                    if (error === 'not-installed') {\n                      var extensionUrl = !!_this.advancedConfiguration.screenShareChromeExtension ? _this.advancedConfiguration.screenShareChromeExtension : 'https://chrome.google.com/webstore/detail/openvidu-screensharing/lfcgfepafnobdloecchnfaclibenjold';\n                      var err = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_EXTENSION_NOT_INSTALLED, extensionUrl);\n                      logger.error(err);\n                      return reject(err);\n                    } else if (error === 'installed-disabled') {\n                      var err = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_EXTENSION_DISABLED, 'You must enable the screen extension');\n                      logger.error(err);\n                      return reject(err);\n                    } else if (error === 'permission-denied') {\n                      var err = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED, 'You must allow access to one window of your desktop');\n                      logger.error(err);\n                      return reject(err);\n                    } else {\n                      var err = new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'Unknown error when accessing screen share');\n                      logger.error(err);\n                      logger.error(error);\n                      return reject(err);\n                    }\n                  } else {\n                    myConstraints.constraints.video = screenConstraints.video;\n                    return resolve(myConstraints);\n                  }\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  OpenVidu.prototype.setVideoSource = function (myConstraints, videoSource) {\n    if (!myConstraints.constraints.video) {\n      myConstraints.constraints.video = {};\n    }\n\n    myConstraints.constraints.video['deviceId'] = {\n      exact: videoSource\n    };\n  };\n  /* Private methods */\n\n\n  OpenVidu.prototype.disconnectCallback = function () {\n    logger.warn('Websocket connection lost');\n\n    if (this.isRoomAvailable()) {\n      this.session.onLostConnection('networkDisconnect');\n    } else {\n      alert('Connection error. Please reload page.');\n    }\n  };\n\n  OpenVidu.prototype.reconnectingCallback = function () {\n    logger.warn('Websocket connection lost (reconnecting)');\n\n    if (!this.isRoomAvailable()) {\n      alert('Connection error. Please reload page.');\n    } else {\n      this.session.emitEvent('reconnecting', []);\n    }\n  };\n\n  OpenVidu.prototype.reconnectWebsocketThroughRpcConnectMethod = function (rpcSessionId) {\n    var _this = this; // This RPC method allows checking:\n    // Single Master: if success, connection recovered\n    //                if error, no Master Node crashed and life will be -1. onLostConnection with reason networkDisconnect will be triggered\n    // Multi Master: if success, connection recovered\n    //               if error and Master Node crashed notification was already received, nothing must be done\n    //               if error and Master Node NOT crashed, sessionStatus method must be sent:\n    //                 if life is equal, networkDisconnect\n    //                 if life is greater, nodeCrashed\n\n\n    this.sendRequest('connect', {\n      sessionId: rpcSessionId,\n      reconnect: true\n    }, function (error, response) {\n      if (!!error) {\n        if (_this.isMasterNodeCrashed()) {\n          logger.warn('Master Node has crashed!');\n        } else {\n          logger.error(error);\n\n          var notifyLostConnection_1 = function notifyLostConnection_1(reason, errorMsg) {\n            logger.warn(errorMsg);\n\n            _this.session.onLostConnection(reason);\n\n            _this.jsonRpcClient.close(4101, \"Reconnection fault: \" + errorMsg);\n          };\n\n          var rpcSessionStatus = function rpcSessionStatus() {\n            if (_this.life === -1) {\n              // Single Master\n              notifyLostConnection_1('networkDisconnect', 'WS successfully reconnected but the user was already evicted due to timeout');\n            } else {\n              // Multi Master\n              // This RPC method is only required to find out the reason of the disconnection:\n              // whether the client lost its network connection or a Master Node crashed\n              _this.sendRequest('sessionStatus', {\n                sessionId: _this.session.sessionId\n              }, function (error, response) {\n                if (error != null) {\n                  console.error('Error checking session status', error);\n                } else {\n                  if (_this.life === response.life) {\n                    // If the life stored in the client matches the life stored in the server, it means that the client lost its network connection\n                    notifyLostConnection_1('networkDisconnect', 'WS successfully reconnected but the user was already evicted due to timeout');\n                  } else {\n                    // If the life stored in the client is below the life stored in the server, it means that the Master Node has crashed\n                    notifyLostConnection_1('nodeCrashed', 'WS successfully reconnected to OpenVidu Server but your Master Node crashed');\n                  }\n                }\n              });\n            }\n          };\n\n          if (error.code === 40007 && error.message === 'reconnection error') {\n            // Kurento error: invalid RPC sessionId. This means that the kurento-jsonrpc-server of openvidu-server where kurento-jsonrpc-client\n            // is trying to reconnect does not know about this sessionId. This can mean two things: \n            // 1) openvidu-browser managed to reconnect after a while, but openvidu-server already evicted the user for not receiving ping.\n            // 2) openvidu-server process is a different one because of a node crash.\n            // Send a \"sessionStatus\" method to check the reason\n            console.error('Invalid RPC sessionId. Client network disconnection or Master Node crash');\n            rpcSessionStatus();\n          } else {\n            rpcSessionStatus();\n          }\n        }\n      } else {\n        _this.jsonRpcClient.resetPing();\n\n        _this.session.onRecoveredConnection();\n      }\n    });\n  };\n\n  OpenVidu.prototype.reconnectedCallback = function () {\n    logger.warn('Websocket reconnected');\n\n    if (this.isRoomAvailable()) {\n      if (!!this.session.connection) {\n        this.reconnectWebsocketThroughRpcConnectMethod(this.session.connection.rpcSessionId);\n      } else {\n        logger.warn('There was no previous connection when running reconnection callback'); // Make Session object dispatch 'sessionDisconnected' event\n\n        var sessionDisconnectEvent = new SessionDisconnectedEvent_1.SessionDisconnectedEvent(this.session, 'networkDisconnect');\n        this.session.ee.emitEvent('sessionDisconnected', [sessionDisconnectEvent]);\n        sessionDisconnectEvent.callDefaultBehavior();\n      }\n    } else {\n      alert('Connection error. Please reload page.');\n    }\n  };\n\n  OpenVidu.prototype.isMasterNodeCrashed = function () {\n    return this.masterNodeHasCrashed;\n  };\n\n  OpenVidu.prototype.isRoomAvailable = function () {\n    if (this.session !== undefined && this.session instanceof Session_1.Session) {\n      return true;\n    } else {\n      logger.warn('Session instance not found');\n      return false;\n    }\n  };\n\n  OpenVidu.prototype.isScreenShare = function (videoSource) {\n    return videoSource === 'screen' || videoSource === 'window' || platform.isElectron() && videoSource.startsWith('screen:');\n  };\n\n  return OpenVidu;\n}();\n\nexports.OpenVidu = OpenVidu;","map":null,"metadata":{},"sourceType":"script"}
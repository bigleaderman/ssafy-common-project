{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connection = void 0;\n\nvar Stream_1 = require(\"./Stream\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar ExceptionEvent_1 = require(\"../OpenViduInternal/Events/ExceptionEvent\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * Represents each one of the user's connection to the session (the local one and other user's connections).\n * Therefore each [[Session]] and [[Stream]] object has an attribute of type Connection\n */\n\nvar Connection =\n/** @class */\nfunction () {\n  /**\n   * @hidden\n   */\n  function Connection(session, connectionOptions) {\n    this.session = session;\n    /**\n     * @hidden\n     */\n\n    this.disposed = false;\n    var msg = \"'Connection' created \";\n\n    if (!!connectionOptions.role) {\n      // Connection is local\n      this.localOptions = connectionOptions;\n      this.connectionId = this.localOptions.id;\n      this.creationTime = this.localOptions.createdAt;\n      this.data = this.localOptions.metadata;\n      this.rpcSessionId = this.localOptions.sessionId;\n      this.role = this.localOptions.role;\n      this.record = this.localOptions.record;\n      msg += '(local)';\n    } else {\n      // Connection is remote\n      this.remoteOptions = connectionOptions;\n      this.connectionId = this.remoteOptions.id;\n      this.creationTime = this.remoteOptions.createdAt;\n\n      if (this.remoteOptions.metadata) {\n        this.data = this.remoteOptions.metadata;\n      }\n\n      if (this.remoteOptions.streams) {\n        this.initRemoteStreams(this.remoteOptions.streams);\n      }\n\n      msg += \"(remote) with 'connectionId' [\" + this.remoteOptions.id + ']';\n    }\n\n    logger.info(msg);\n  }\n  /* Hidden methods */\n\n  /**\n   * @hidden\n   */\n\n\n  Connection.prototype.sendIceCandidate = function (candidate) {\n    var _this = this;\n\n    logger.debug((!!this.stream.outboundStreamOpts ? 'Local' : 'Remote') + 'candidate for' + this.connectionId, candidate);\n    this.session.openvidu.sendRequest('onIceCandidate', {\n      endpointName: this.connectionId,\n      candidate: candidate.candidate,\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex\n    }, function (error, response) {\n      if (error) {\n        logger.error('Error sending ICE candidate: ' + JSON.stringify(error));\n\n        _this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(_this.session, ExceptionEvent_1.ExceptionEventName.ICE_CANDIDATE_ERROR, _this.session, \"There was an unexpected error on the server-side processing an ICE candidate generated and sent by the client-side\", error)]);\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Connection.prototype.initRemoteStreams = function (options) {\n    var _this = this; // This is ready for supporting multiple streams per Connection object. Right now the loop will always run just once\n    // this.stream should also be replaced by a collection of streams to support multiple streams per Connection\n\n\n    options.forEach(function (opts) {\n      var streamOptions = {\n        id: opts.id,\n        createdAt: opts.createdAt,\n        connection: _this,\n        hasAudio: opts.hasAudio,\n        hasVideo: opts.hasVideo,\n        audioActive: opts.audioActive,\n        videoActive: opts.videoActive,\n        typeOfVideo: opts.typeOfVideo,\n        frameRate: opts.frameRate,\n        videoDimensions: !!opts.videoDimensions ? JSON.parse(opts.videoDimensions) : undefined,\n        filter: !!opts.filter ? opts.filter : undefined\n      };\n      var stream = new Stream_1.Stream(_this.session, streamOptions);\n\n      _this.addStream(stream);\n    });\n    logger.info(\"Remote 'Connection' with 'connectionId' [\" + this.connectionId + '] is now configured for receiving Streams with options: ', this.stream.inboundStreamOpts);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Connection.prototype.addStream = function (stream) {\n    stream.connection = this;\n    this.stream = stream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Connection.prototype.removeStream = function (streamId) {\n    delete this.stream;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Connection.prototype.dispose = function () {\n    if (!!this.stream) {\n      delete this.stream;\n    }\n\n    this.disposed = true;\n  };\n\n  return Connection;\n}();\n\nexports.Connection = Connection;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","session","connectionOptions","msg","role","localOptions","connectionId","id","creationTime","createdAt","data","metadata","rpcSessionId","sessionId","record","remoteOptions","streams","initRemoteStreams","info","Connection","candidate","debug","stream","outboundStreamOpts","openvidu","sendRequest","endpointName","sdpMid","sdpMLineIndex","error","response","JSON","stringify","_this","emitEvent","ExceptionEvent_1","ICE_CANDIDATE_ERROR","options","forEach","streamOptions","opts","connection","hasAudio","hasVideo","audioActive","videoActive","typeOfVideo","frameRate","videoDimensions","parse","undefined","filter","Stream_1","addStream","inboundStreamOpts","streamId","disposed","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenVidu\\Connection.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Session } from './Session';\nimport { Stream } from './Stream';\nimport { LocalConnectionOptions } from '../OpenViduInternal/Interfaces/Private/LocalConnectionOptions';\nimport { RemoteConnectionOptions } from '../OpenViduInternal/Interfaces/Private/RemoteConnectionOptions';\nimport { InboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/InboundStreamOptions';\nimport { StreamOptionsServer } from '../OpenViduInternal/Interfaces/Private/StreamOptionsServer';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { ExceptionEvent, ExceptionEventName } from '../OpenViduInternal/Events/ExceptionEvent';\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n\n/**\n * Represents each one of the user's connection to the session (the local one and other user's connections).\n * Therefore each [[Session]] and [[Stream]] object has an attribute of type Connection\n */\nexport class Connection {\n\n    /**\n     * Unique identifier of the connection\n     */\n    connectionId: string;\n\n    /**\n     * Time when this connection was created in OpenVidu Server (UTC milliseconds)\n     */\n    creationTime: number;\n\n    /**\n     * Data associated to this connection (and therefore to certain user). This is an important field:\n     * it allows you to broadcast all the information you want for each user (a username, for example)\n     */\n    data: string;\n\n    /**\n     * Role of the connection.\n     * - `SUBSCRIBER`: can subscribe to published Streams of other users by calling [[Session.subscribe]]\n     * - `PUBLISHER`: SUBSCRIBER permissions + can publish their own Streams by calling [[Session.publish]]\n     * - `MODERATOR`: SUBSCRIBER + PUBLISHER permissions + can force the unpublishing or disconnection over a third-party Stream or Connection by call [[Session.forceUnpublish]] and [[Session.forceDisconnect]]\n     *\n     * **Only defined for the local connection. In remote connections will be `undefined`**\n     */\n    role: string;\n\n    /**\n     * Whether the streams published by this Connection will be recorded or not. This only affects [INDIVIDUAL recording](/en/stable/advanced-features/recording/#individual-recording-selection) <a href=\"https://docs.openvidu.io/en/stable/openvidu-pro/\" style=\"display: inline-block; background-color: rgb(0, 136, 170); color: white; font-weight: bold; padding: 0px 5px; margin-right: 5px; border-radius: 3px; font-size: 13px; line-height:21px; font-family: Montserrat, sans-serif\">PRO</a>\n     *\n     * **Only defined for the local connection. In remote connections will be `undefined`**\n     */\n    record: boolean;\n\n    /**\n     * @hidden\n     */\n    stream?: Stream;\n\n    /**\n     * @hidden\n     */\n    localOptions: LocalConnectionOptions | undefined;\n\n    /**\n     * @hidden\n     */\n    remoteOptions: RemoteConnectionOptions | undefined;\n\n    /**\n     * @hidden\n     */\n    disposed = false;\n\n    /**\n     * @hidden\n     */\n    rpcSessionId: string;\n\n    /**\n     * @hidden\n     */\n    constructor(private session: Session, connectionOptions: LocalConnectionOptions | RemoteConnectionOptions) {\n        let msg = \"'Connection' created \";\n        if (!!(<LocalConnectionOptions>connectionOptions).role) {\n            // Connection is local\n            this.localOptions = <LocalConnectionOptions>connectionOptions;\n            this.connectionId = this.localOptions.id;\n            this.creationTime = this.localOptions.createdAt;\n            this.data = this.localOptions.metadata;\n            this.rpcSessionId = this.localOptions.sessionId;\n            this.role = this.localOptions.role;\n            this.record = this.localOptions.record;\n            msg += '(local)';\n        } else {\n            // Connection is remote\n            this.remoteOptions = <RemoteConnectionOptions>connectionOptions;\n            this.connectionId = this.remoteOptions.id;\n            this.creationTime = this.remoteOptions.createdAt;\n            if (this.remoteOptions.metadata) {\n                this.data = this.remoteOptions.metadata;\n            }\n            if (this.remoteOptions.streams) {\n                this.initRemoteStreams(this.remoteOptions.streams);\n            }\n            msg += \"(remote) with 'connectionId' [\" + this.remoteOptions.id + ']';\n        }\n        logger.info(msg);\n    }\n\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    sendIceCandidate(candidate: RTCIceCandidate): void {\n\n        logger.debug((!!this.stream!.outboundStreamOpts ? 'Local' : 'Remote') + 'candidate for' +\n            this.connectionId, candidate);\n\n        this.session.openvidu.sendRequest('onIceCandidate', {\n            endpointName: this.connectionId,\n            candidate: candidate.candidate,\n            sdpMid: candidate.sdpMid,\n            sdpMLineIndex: candidate.sdpMLineIndex\n        }, (error, response) => {\n            if (error) {\n                logger.error('Error sending ICE candidate: ' + JSON.stringify(error));\n                this.session.emitEvent('exception', [new ExceptionEvent(this.session, ExceptionEventName.ICE_CANDIDATE_ERROR, this.session, \"There was an unexpected error on the server-side processing an ICE candidate generated and sent by the client-side\", error)]);\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initRemoteStreams(options: StreamOptionsServer[]): void {\n\n        // This is ready for supporting multiple streams per Connection object. Right now the loop will always run just once\n        // this.stream should also be replaced by a collection of streams to support multiple streams per Connection\n        options.forEach(opts => {\n            const streamOptions: InboundStreamOptions = {\n                id: opts.id,\n                createdAt: opts.createdAt,\n                connection: this,\n                hasAudio: opts.hasAudio,\n                hasVideo: opts.hasVideo,\n                audioActive: opts.audioActive,\n                videoActive: opts.videoActive,\n                typeOfVideo: opts.typeOfVideo,\n                frameRate: opts.frameRate,\n                videoDimensions: !!opts.videoDimensions ? JSON.parse(opts.videoDimensions) : undefined,\n                filter: !!opts.filter ? opts.filter : undefined\n            };\n            const stream = new Stream(this.session, streamOptions);\n\n            this.addStream(stream);\n        });\n\n        logger.info(\"Remote 'Connection' with 'connectionId' [\" + this.connectionId + '] is now configured for receiving Streams with options: ', this.stream!.inboundStreamOpts);\n    }\n\n    /**\n     * @hidden\n     */\n    addStream(stream: Stream): void {\n        stream.connection = this;\n        this.stream = stream;\n    }\n\n    /**\n     * @hidden\n     */\n    removeStream(streamId: string): void {\n        delete this.stream;\n    }\n\n    /**\n     * @hidden\n     */\n    dispose(): void {\n        if (!!this.stream) {\n            delete this.stream;\n        }\n        this.disposed = true;\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}
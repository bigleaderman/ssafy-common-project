{"ast":null,"code":"\"use strict\";\n\nvar OpenViduLogger = require('../../../../Logger/OpenViduLogger').OpenViduLogger;\n\nvar Logger = OpenViduLogger.getInstance();\nvar MAX_RETRIES = 2000;\nvar RETRY_TIME_MS = 3000;\nvar CONNECTING = 0;\nvar OPEN = 1;\nvar CLOSING = 2;\nvar CLOSED = 3;\n\nfunction WebSocketWithReconnection(config) {\n  var closing = false;\n  var registerMessageHandler;\n  var wsUri = config.uri;\n  var reconnecting = false;\n  var ws = new WebSocket(wsUri);\n\n  ws.onopen = function () {\n    Logger.debug(\"WebSocket connected to \" + wsUri);\n\n    if (config.onconnected) {\n      config.onconnected();\n    }\n  };\n\n  ws.onerror = function (error) {\n    Logger.error(\"Could not connect to \" + wsUri + \" (invoking onerror if defined)\", error);\n\n    if (config.onerror) {\n      config.onerror(error);\n    }\n  };\n\n  var reconnectionOnClose = function () {\n    if (ws.readyState === CLOSED) {\n      if (closing) {\n        Logger.debug(\"Connection closed by user\");\n      } else {\n        if (config.ismasternodecrashed()) {\n          Logger.error(\"Master Node has crashed. Stopping reconnection process\");\n        } else {\n          Logger.debug(\"Connection closed unexpectedly. Reconnecting...\");\n          reconnect(MAX_RETRIES, 1);\n        }\n      }\n    } else {\n      Logger.debug(\"Close callback from previous websocket. Ignoring it\");\n    }\n  };\n\n  ws.onclose = reconnectionOnClose;\n\n  function reconnect(maxRetries, numRetries) {\n    Logger.debug(\"reconnect (attempt #\" + numRetries + \", max=\" + maxRetries + \")\");\n\n    if (numRetries === 1) {\n      if (reconnecting) {\n        Logger.warn(\"Trying to reconnect when already reconnecting... Ignoring this reconnection.\");\n        return;\n      } else {\n        reconnecting = true;\n      }\n\n      if (config.onreconnecting) {\n        config.onreconnecting();\n      }\n    }\n\n    reconnectAux(maxRetries, numRetries);\n  }\n\n  function addReconnectionQueryParamsIfMissing(uriString) {\n    var searchParams = new URLSearchParams(new URL(uriString).search);\n\n    if (!searchParams.has(\"reconnect\")) {\n      uriString = Array.from(searchParams).length > 0 ? uriString + '&reconnect=true' : uriString + '?reconnect=true';\n    }\n\n    return uriString;\n  }\n\n  function reconnectAux(maxRetries, numRetries) {\n    Logger.debug(\"Reconnection attempt #\" + numRetries);\n    ws.close(4104, 'Connection closed for reconnection');\n    wsUri = addReconnectionQueryParamsIfMissing(wsUri);\n    ws = new WebSocket(wsUri);\n\n    ws.onopen = function () {\n      Logger.debug(\"Reconnected to \" + wsUri + \" after \" + numRetries + \" attempts...\");\n      reconnecting = false;\n      registerMessageHandler();\n\n      if (config.onreconnected()) {\n        config.onreconnected();\n      }\n\n      ws.onclose = reconnectionOnClose;\n    };\n\n    ws.onerror = function (error) {\n      Logger.warn(\"Reconnection error: \", error);\n\n      if (numRetries === maxRetries) {\n        if (config.ondisconnect) {\n          config.ondisconnect();\n        }\n      } else {\n        setTimeout(function () {\n          reconnect(maxRetries, numRetries + 1);\n        }, RETRY_TIME_MS);\n      }\n    };\n  }\n\n  this.close = function (code, reason) {\n    closing = true;\n    ws.close(code, reason);\n  };\n\n  this.reconnectWs = function () {\n    Logger.debug(\"reconnectWs\");\n    reconnect(MAX_RETRIES, 1);\n  };\n\n  this.send = function (message) {\n    ws.send(message);\n  };\n\n  this.addEventListener = function (type, callback) {\n    registerMessageHandler = function () {\n      ws.addEventListener(type, callback);\n    };\n\n    registerMessageHandler();\n  };\n\n  this.getReadyState = function () {\n    return ws.readyState;\n  };\n}\n\nmodule.exports = WebSocketWithReconnection;","map":{"version":3,"mappings":"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","names":["OpenViduLogger","require","Logger","getInstance","MAX_RETRIES","RETRY_TIME_MS","CONNECTING","OPEN","CLOSING","CLOSED","WebSocketWithReconnection","config","closing","registerMessageHandler","wsUri","uri","reconnecting","ws","WebSocket","onopen","debug","onconnected","onerror","error","reconnectionOnClose","readyState","ismasternodecrashed","reconnect","onclose","maxRetries","numRetries","warn","onreconnecting","reconnectAux","addReconnectionQueryParamsIfMissing","uriString","searchParams","URLSearchParams","URL","search","has","Array","from","length","close","onreconnected","ondisconnect","setTimeout","code","reason","reconnectWs","send","message","addEventListener","type","callback","getReadyState","module","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenViduInternal\\KurentoUtils\\kurento-jsonrpc\\clients\\transports\\webSocketWithReconnection.js"],"sourcesContent":["/*\n * (C) Copyright 2013-2015 Kurento (http://kurento.org/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar OpenViduLogger = require('../../../../Logger/OpenViduLogger').OpenViduLogger;\nvar Logger = OpenViduLogger.getInstance();\n\nvar MAX_RETRIES = 2000; // Forever...\nvar RETRY_TIME_MS = 3000; // FIXME: Implement exponential wait times...\n\nvar CONNECTING = 0;\nvar OPEN = 1;\nvar CLOSING = 2;\nvar CLOSED = 3;\n\n/*\nconfig = {\nuri : wsUri,\nonconnected : callback method to invoke when connection is successful,\nondisconnect : callback method to invoke when the connection is lost (max retries for reconnecting reached),\nonreconnecting : callback method to invoke when the client is reconnecting,\nonreconnected : callback method to invoke when the client successfully reconnects,\n};\n*/\nfunction WebSocketWithReconnection(config) {\n    var closing = false;\n    var registerMessageHandler;\n    var wsUri = config.uri;\n    var reconnecting = false;\n\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = () => {\n        Logger.debug(\"WebSocket connected to \" + wsUri);\n        if (config.onconnected) {\n            config.onconnected();\n        }\n    };\n\n    ws.onerror = error => {\n        Logger.error(\n            \"Could not connect to \" + wsUri + \" (invoking onerror if defined)\",\n            error\n        );\n        if (config.onerror) {\n            config.onerror(error);\n        }\n    };\n\n    var reconnectionOnClose = () => {\n        if (ws.readyState === CLOSED) {\n            if (closing) {\n                Logger.debug(\"Connection closed by user\");\n            } else {\n                if (config.ismasternodecrashed()) {\n                    Logger.error(\"Master Node has crashed. Stopping reconnection process\");\n                } else {\n                    Logger.debug(\"Connection closed unexpectedly. Reconnecting...\");\n                    reconnect(MAX_RETRIES, 1);\n                }\n            }\n        } else {\n            Logger.debug(\"Close callback from previous websocket. Ignoring it\");\n        }\n    };\n\n    ws.onclose = reconnectionOnClose;\n\n    function reconnect(maxRetries, numRetries) {\n        Logger.debug(\n            \"reconnect (attempt #\" + numRetries + \", max=\" + maxRetries + \")\"\n        );\n        if (numRetries === 1) {\n            if (reconnecting) {\n                Logger.warn(\n                    \"Trying to reconnect when already reconnecting... Ignoring this reconnection.\"\n                );\n                return;\n            } else {\n                reconnecting = true;\n            }\n            if (config.onreconnecting) {\n                config.onreconnecting();\n            }\n        }\n        reconnectAux(maxRetries, numRetries);\n    }\n\n    function addReconnectionQueryParamsIfMissing(uriString) {\n        var searchParams = new URLSearchParams((new URL(uriString)).search);\n        if (!searchParams.has(\"reconnect\")) {\n            uriString = (Array.from(searchParams).length > 0) ? (uriString + '&reconnect=true') : (uriString + '?reconnect=true');\n        }\n        return uriString;\n    }\n\n    function reconnectAux(maxRetries, numRetries) {\n        Logger.debug(\"Reconnection attempt #\" + numRetries);\n        ws.close(4104, 'Connection closed for reconnection');\n\n        wsUri = addReconnectionQueryParamsIfMissing(wsUri);\n        ws = new WebSocket(wsUri);\n\n        ws.onopen = () => {\n            Logger.debug(\n                \"Reconnected to \" + wsUri + \" after \" + numRetries + \" attempts...\"\n            );\n            reconnecting = false;\n            registerMessageHandler();\n            if (config.onreconnected()) {\n                config.onreconnected();\n            }\n            ws.onclose = reconnectionOnClose;\n        };\n\n        ws.onerror = error => {\n            Logger.warn(\"Reconnection error: \", error);\n            if (numRetries === maxRetries) {\n                if (config.ondisconnect) {\n                    config.ondisconnect();\n                }\n            } else {\n                setTimeout(() => {\n                    reconnect(maxRetries, numRetries + 1);\n                }, RETRY_TIME_MS);\n            }\n        };\n    }\n\n    this.close = (code, reason) => {\n        closing = true;\n        ws.close(code, reason);\n    };\n\n    this.reconnectWs = () => {\n        Logger.debug(\"reconnectWs\");\n        reconnect(MAX_RETRIES, 1);\n    };\n\n    this.send = message => {\n        ws.send(message);\n    };\n\n    this.addEventListener = (type, callback) => {\n        registerMessageHandler = () => {\n            ws.addEventListener(type, callback);\n        };\n        registerMessageHandler();\n    };\n\n    this.getReadyState = () => {\n        return ws.readyState;\n    }\n}\n\nmodule.exports = WebSocketWithReconnection;"]},"metadata":{},"sourceType":"script"}
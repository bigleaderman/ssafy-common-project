{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalRecorder = void 0;\n\nvar LocalRecorderState_1 = require(\"../OpenViduInternal/Enums/LocalRecorderState\");\n\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\n\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\n\nvar Mime = require(\"mime/lite\");\n/**\n * @hidden\n */\n\n\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\n\nvar platform;\n/**\n * Easy recording of [[Stream]] objects straightaway from the browser. Initialized with [[OpenVidu.initLocalRecorder]] method\n */\n\nvar LocalRecorder =\n/** @class */\nfunction () {\n  /**\n   * @hidden\n   */\n  function LocalRecorder(stream) {\n    this.stream = stream;\n    this.chunks = [];\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n    this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n    this.state = LocalRecorderState_1.LocalRecorderState.READY;\n  }\n  /**\n   * Starts the recording of the Stream. [[state]] property must be `READY`. After method succeeds is set to `RECORDING`\n   *\n   * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n   * For example:\n   *\n   * ```javascript\n   * var OV = new OpenVidu();\n   * var publisher = await OV.initPublisherAsync();\n   * var localRecorder = OV.initLocalRecorder(publisher.stream);\n   * var options = {\n   *      mimeType: 'video/webm;codecs=vp8',\n   *      audioBitsPerSecond:128000,\n   *      videoBitsPerSecond:2500000\n   * };\n   * localRecorder.record(options);\n   * ```\n   *\n   * If not specified, the default options preferred by the platform will be used.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.record = function (options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (typeof options === 'string' || options instanceof String) {\n          return reject(\"When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \\\"\".concat(options, \"\\\" }\"));\n        }\n\n        if (typeof MediaRecorder === 'undefined') {\n          logger.error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n          throw Error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n        }\n\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.READY) {\n          throw Error('\\'LocalRecord.record()\\' needs \\'LocalRecord.state\\' to be \\'READY\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.clean()\\' or init a new LocalRecorder before');\n        }\n\n        logger.log(\"Starting local recording of stream '\" + _this.stream.streamId + \"' of connection '\" + _this.connectionId + \"'\");\n\n        if (!options) {\n          options = {\n            mimeType: 'video/webm'\n          };\n        } else if (!options.mimeType) {\n          options.mimeType = 'video/webm';\n        }\n\n        _this.mediaRecorder = new MediaRecorder(_this.stream.getMediaStream(), options);\n\n        _this.mediaRecorder.start();\n      } catch (err) {\n        return reject(err);\n      }\n\n      _this.mediaRecorder.ondataavailable = function (e) {\n        if (e.data.size > 0) {\n          _this.chunks.push(e.data);\n        }\n      };\n\n      _this.mediaRecorder.onerror = function (e) {\n        logger.error('MediaRecorder error: ', e);\n      };\n\n      _this.mediaRecorder.onstart = function () {\n        logger.log('MediaRecorder started (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onstop = function () {\n        _this.onStopDefault();\n      };\n\n      _this.mediaRecorder.onpause = function () {\n        logger.log('MediaRecorder paused (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onresume = function () {\n        logger.log('MediaRecorder resumed (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n      return resolve();\n    });\n  };\n  /**\n   * Ends the recording of the Stream. [[state]] property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.stop = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state === LocalRecorderState_1.LocalRecorderState.READY || _this.state === LocalRecorderState_1.LocalRecorderState.FINISHED) {\n          throw Error('\\'LocalRecord.stop()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' or \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' before');\n        }\n\n        _this.mediaRecorder.onstop = function () {\n          _this.onStopDefault();\n\n          return resolve();\n        };\n\n        _this.mediaRecorder.stop();\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\n   * Pauses the recording of the Stream. [[state]] property must be `RECORDING`. After method succeeds is set to `PAUSED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.pause = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.RECORDING) {\n          return reject(Error('\\'LocalRecord.pause()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' or \\'LocalRecorder.resume()\\' before'));\n        }\n\n        _this.mediaRecorder.pause();\n\n        _this.state = LocalRecorderState_1.LocalRecorderState.PAUSED;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Resumes the recording of the Stream. [[state]] property must be `PAUSED`. After method succeeds is set to `RECORDING`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.resume = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.PAUSED) {\n          throw Error('\\'LocalRecord.resume()\\' needs \\'LocalRecord.state\\' to be \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.pause()\\' before');\n        }\n\n        _this.mediaRecorder.resume();\n\n        _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.preview = function (parentElement) {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('\\'LocalRecord.preview()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before');\n    }\n\n    this.videoPreview = document.createElement('video');\n    this.videoPreview.id = this.id;\n    this.videoPreview.autoplay = true;\n\n    if (platform.isSafariBrowser()) {\n      this.videoPreview.setAttribute('playsinline', 'true');\n    }\n\n    if (typeof parentElement === 'string') {\n      var parentElementDom = document.getElementById(parentElement);\n\n      if (parentElementDom) {\n        this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n      }\n    } else {\n      this.videoPreview = parentElement.appendChild(this.videoPreview);\n    }\n\n    this.videoPreview.src = this.videoPreviewSrc;\n    return this.videoPreview;\n  };\n  /**\n   * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets [[state]] to `READY` so the recording can start again\n   */\n\n\n  LocalRecorder.prototype.clean = function () {\n    var _this = this;\n\n    var f = function () {\n      delete _this.blob;\n      _this.chunks = [];\n      _this.state = LocalRecorderState_1.LocalRecorderState.READY;\n    };\n\n    if (this.state === LocalRecorderState_1.LocalRecorderState.RECORDING || this.state === LocalRecorderState_1.LocalRecorderState.PAUSED) {\n      this.stop().then(function () {\n        return f();\n      }).catch(function () {\n        return f();\n      });\n    } else {\n      f();\n    }\n  };\n  /**\n   * Downloads the recorded video through the browser. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.download = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('\\'LocalRecord.download()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before');\n    } else {\n      var a = document.createElement('a');\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      var url = window.URL.createObjectURL(this.blob);\n      a.href = url;\n      a.download = this.id + '.' + Mime.getExtension(this.blob.type);\n      a.click();\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(a);\n    }\n  };\n  /**\n   * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.getBlob = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('Call \\'LocalRecord.stop()\\' before getting Blob file');\n    } else {\n      return this.blob;\n    }\n  };\n  /**\n   * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n   */\n\n\n  LocalRecorder.prototype.uploadAsBinary = function (endpoint, headers) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error('\\'LocalRecord.uploadAsBinary()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n      } else {\n        var http_1 = new XMLHttpRequest();\n        http_1.open('POST', endpoint, true);\n\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_1.setRequestHeader(key, headers[key]);\n          }\n        }\n\n        http_1.onreadystatechange = function () {\n          if (http_1.readyState === 4) {\n            if (http_1.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_1.responseText);\n            } else {\n              return reject(http_1.status);\n            }\n          }\n        };\n\n        http_1.send(_this.blob);\n      }\n    });\n  };\n  /**\n   * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n   */\n\n\n  LocalRecorder.prototype.uploadAsMultipartfile = function (endpoint, headers) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error('\\'LocalRecord.uploadAsMultipartfile()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n      } else {\n        var http_2 = new XMLHttpRequest();\n        http_2.open('POST', endpoint, true);\n\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_2.setRequestHeader(key, headers[key]);\n          }\n        }\n\n        var sendable = new FormData();\n        sendable.append('file', _this.blob, _this.id + '.' + Mime.getExtension(_this.blob.type));\n\n        http_2.onreadystatechange = function () {\n          if (http_2.readyState === 4) {\n            if (http_2.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_2.responseText);\n            } else {\n              return reject(http_2.status);\n            }\n          }\n        };\n\n        http_2.send(sendable);\n      }\n    });\n  };\n  /* Private methods */\n\n\n  LocalRecorder.prototype.onStopDefault = function () {\n    logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n    this.blob = new Blob(this.chunks, {\n      type: this.mediaRecorder.mimeType\n    });\n    this.chunks = [];\n    this.videoPreviewSrc = window.URL.createObjectURL(this.blob);\n    this.state = LocalRecorderState_1.LocalRecorderState.FINISHED;\n  };\n\n  return LocalRecorder;\n}();\n\nexports.LocalRecorder = LocalRecorder;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","stream","Platform_1","connectionId","connection","id","streamId","state","LocalRecorderState_1","READY","LocalRecorder","options","Promise","resolve","reject","String","MediaRecorder","error","Error","_this","log","mimeType","mediaRecorder","getMediaStream","start","err","ondataavailable","e","data","size","chunks","push","onerror","onstart","onstop","onStopDefault","onpause","onresume","RECORDING","FINISHED","stop","pause","PAUSED","resume","parentElement","videoPreview","document","createElement","autoplay","isSafariBrowser","setAttribute","parentElementDom","getElementById","appendChild","src","videoPreviewSrc","f","blob","then","catch","a","style","display","body","url","window","URL","createObjectURL","href","download","Mime","getExtension","type","click","revokeObjectURL","removeChild","endpoint","headers","http_1","XMLHttpRequest","open","keys","_i","key","setRequestHeader","onreadystatechange","readyState","status","toString","charAt","responseText","send","http_2","sendable","FormData","append","Blob","exports"],"sources":["C:\\SSAFY\\2nd semester\\S07P12D106\\front\\node_modules\\openvidu-browser\\src\\OpenVidu\\LocalRecorder.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Stream } from './Stream';\nimport { LocalRecorderState } from '../OpenViduInternal/Enums/LocalRecorderState';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\nimport Mime = require('mime/lite');\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n\n/**\n * Easy recording of [[Stream]] objects straightaway from the browser. Initialized with [[OpenVidu.initLocalRecorder]] method\n */\nexport class LocalRecorder {\n\n    state: LocalRecorderState;\n\n    private connectionId: string;\n    private mediaRecorder: MediaRecorder;\n    private chunks: any[] = [];\n    private blob?: Blob;\n    private id: string;\n    private videoPreviewSrc: string;\n    private videoPreview: HTMLVideoElement;\n\n    /**\n     * @hidden\n     */\n    constructor(private stream: Stream) {\n        platform = PlatformUtils.getInstance();\n        this.connectionId = (!!this.stream.connection) ? this.stream.connection.connectionId : 'default-connection';\n        this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n        this.state = LocalRecorderState.READY;\n    }\n\n\n    /**\n     * Starts the recording of the Stream. [[state]] property must be `READY`. After method succeeds is set to `RECORDING`\n     *\n     * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n     * For example: \n     * \n     * ```javascript\n     * var OV = new OpenVidu();\n     * var publisher = await OV.initPublisherAsync();\n     * var localRecorder = OV.initLocalRecorder(publisher.stream);\n     * var options = {\n     *      mimeType: 'video/webm;codecs=vp8',\n     *      audioBitsPerSecond:128000,\n     *      videoBitsPerSecond:2500000\n     * };\n     * localRecorder.record(options);\n     * ```\n     * \n     * If not specified, the default options preferred by the platform will be used.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n     */\n    record(options?: any): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (typeof options === 'string' || options instanceof String) {\n                    return reject(`When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \"${options}\" }`);\n                }\n                if (typeof MediaRecorder === 'undefined') {\n                    logger.error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n                    throw (Error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder'));\n                }\n                if (this.state !== LocalRecorderState.READY) {\n                    throw (Error('\\'LocalRecord.record()\\' needs \\'LocalRecord.state\\' to be \\'READY\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.clean()\\' or init a new LocalRecorder before'));\n                }\n                logger.log(\"Starting local recording of stream '\" + this.stream.streamId + \"' of connection '\" + this.connectionId + \"'\");\n\n                if (!options) {\n                    options = { mimeType: 'video/webm' };\n                } else if (!options.mimeType) {\n                    options.mimeType = 'video/webm';\n                }\n\n                this.mediaRecorder = new MediaRecorder(this.stream.getMediaStream(), options);\n                this.mediaRecorder.start();\n\n            } catch (err) {\n                return reject(err);\n            }\n\n            this.mediaRecorder.ondataavailable = (e) => {\n                if (e.data.size > 0) {\n                    this.chunks.push(e.data);\n                }\n            };\n\n            this.mediaRecorder.onerror = (e) => {\n                logger.error('MediaRecorder error: ', e);\n            };\n\n            this.mediaRecorder.onstart = () => {\n                logger.log('MediaRecorder started (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.mediaRecorder.onstop = () => {\n                this.onStopDefault();\n            };\n\n            this.mediaRecorder.onpause = () => {\n                logger.log('MediaRecorder paused (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.mediaRecorder.onresume = () => {\n                logger.log('MediaRecorder resumed (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.state = LocalRecorderState.RECORDING;\n            return resolve();\n\n        });\n    }\n\n\n    /**\n     * Ends the recording of the Stream. [[state]] property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n     */\n    stop(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state === LocalRecorderState.READY || this.state === LocalRecorderState.FINISHED) {\n                    throw (Error('\\'LocalRecord.stop()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' or \\'PAUSED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.start()\\' before'));\n                }\n                this.mediaRecorder.onstop = () => {\n                    this.onStopDefault();\n                    return resolve();\n                };\n                this.mediaRecorder.stop();\n            } catch (e) {\n                return reject(e);\n            }\n        });\n    }\n\n\n    /**\n     * Pauses the recording of the Stream. [[state]] property must be `RECORDING`. After method succeeds is set to `PAUSED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n     */\n    pause(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state !== LocalRecorderState.RECORDING) {\n                    return reject(Error('\\'LocalRecord.pause()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.start()\\' or \\'LocalRecorder.resume()\\' before'));\n                }\n                this.mediaRecorder.pause();\n                this.state = LocalRecorderState.PAUSED;\n                return resolve();\n            } catch (error) {\n                return reject(error);\n            }\n        });\n    }\n\n    /**\n     * Resumes the recording of the Stream. [[state]] property must be `PAUSED`. After method succeeds is set to `RECORDING`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n     */\n    resume(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state !== LocalRecorderState.PAUSED) {\n                    throw (Error('\\'LocalRecord.resume()\\' needs \\'LocalRecord.state\\' to be \\'PAUSED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.pause()\\' before'));\n                }\n                this.mediaRecorder.resume();\n                this.state = LocalRecorderState.RECORDING;\n                return resolve();\n            } catch (error) {\n                return reject(error);\n            }\n        });\n    }\n\n\n    /**\n     * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. [[state]] property must be `FINISHED`\n     */\n    preview(parentElement): HTMLVideoElement {\n\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw (Error('\\'LocalRecord.preview()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n        }\n\n        this.videoPreview = document.createElement('video');\n\n        this.videoPreview.id = this.id;\n        this.videoPreview.autoplay = true;\n\n        if (platform.isSafariBrowser()) {\n            this.videoPreview.setAttribute('playsinline', 'true');\n        }\n\n        if (typeof parentElement === 'string') {\n            const parentElementDom = document.getElementById(parentElement);\n            if (parentElementDom) {\n                this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n            }\n        } else {\n            this.videoPreview = parentElement.appendChild(this.videoPreview);\n        }\n\n        this.videoPreview.src = this.videoPreviewSrc;\n\n        return this.videoPreview;\n    }\n\n\n    /**\n     * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets [[state]] to `READY` so the recording can start again\n     */\n    clean(): void {\n        const f = () => {\n            delete this.blob;\n            this.chunks = [];\n            this.state = LocalRecorderState.READY;\n        };\n        if (this.state === LocalRecorderState.RECORDING || this.state === LocalRecorderState.PAUSED) {\n            this.stop().then(() => f()).catch(() => f());\n        } else {\n            f();\n        }\n    }\n\n\n    /**\n     * Downloads the recorded video through the browser. [[state]] property must be `FINISHED`\n     */\n    download(): void {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw (Error('\\'LocalRecord.download()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n        } else {\n            const a: HTMLAnchorElement = document.createElement('a');\n            a.style.display = 'none';\n            document.body.appendChild(a);\n\n            const url = window.URL.createObjectURL(<any>this.blob);\n            a.href = url;\n            a.download = this.id + '.' + Mime.getExtension(this.blob!.type);\n            a.click();\n            window.URL.revokeObjectURL(url);\n\n            document.body.removeChild(a);\n        }\n    }\n\n    /**\n     * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. [[state]] property must be `FINISHED`\n     */\n    getBlob(): Blob {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw (Error('Call \\'LocalRecord.stop()\\' before getting Blob file'));\n        } else {\n            return this.blob!;\n        }\n    }\n\n\n    /**\n     * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n     */\n    uploadAsBinary(endpoint: string, headers?: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.state !== LocalRecorderState.FINISHED) {\n                return reject(Error('\\'LocalRecord.uploadAsBinary()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n            } else {\n                const http = new XMLHttpRequest();\n                http.open('POST', endpoint, true);\n\n                if (typeof headers === 'object') {\n                    for (const key of Object.keys(headers)) {\n                        http.setRequestHeader(key, headers[key]);\n                    }\n                }\n\n                http.onreadystatechange = () => {\n                    if (http.readyState === 4) {\n                        if (http.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            return resolve(http.responseText);\n                        } else {\n                            return reject(http.status);\n                        }\n                    }\n                };\n                http.send(this.blob);\n            }\n        });\n    }\n\n\n    /**\n     * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n     */\n    uploadAsMultipartfile(endpoint: string, headers?: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.state !== LocalRecorderState.FINISHED) {\n                return reject(Error('\\'LocalRecord.uploadAsMultipartfile()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n            } else {\n                const http = new XMLHttpRequest();\n                http.open('POST', endpoint, true);\n\n                if (typeof headers === 'object') {\n                    for (const key of Object.keys(headers)) {\n                        http.setRequestHeader(key, headers[key]);\n                    }\n                }\n\n                const sendable = new FormData();\n                sendable.append('file', this.blob!, this.id + '.' + Mime.getExtension(this.blob!.type));\n\n                http.onreadystatechange = () => {\n                    if (http.readyState === 4) {\n                        if (http.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            return resolve(http.responseText);\n                        } else {\n                            return reject(http.status);\n                        }\n                    }\n                };\n\n                http.send(sendable);\n            }\n        });\n    }\n\n\n    /* Private methods */\n\n    private onStopDefault(): void {\n        logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n\n        this.blob = new Blob(this.chunks, { type: this.mediaRecorder.mimeType });\n        this.chunks = [];\n\n        this.videoPreviewSrc = window.URL.createObjectURL(this.blob);\n\n        this.state = LocalRecorderState.FINISHED;\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}